/////////////////////////////////////////////////////////////////////////////////////////
// Copyright 2008 Siemens Product Lifecycle Management Software Inc. All Rights Reserved.
//
// This software and related documentation are proprietary to 
// Siemens Product Lifecycle Management Software Inc.
//
// PLM XML Code Generator v7.0.1.19355 12/11/2018 11:03:54
// 
// Schema:	PLMXMLSchema.xsd
// Data:	2008-05-02
// Version:	6.0
// Status:	release
//
/////////////////////////////////////////////////////////////////////////////////////////

#ifndef __PLMXML60_H__
#define __PLMXML60_H__

//////////////////////////////////////////////////////////////////////
#if defined(_WIN32) || defined(_WIN64)

#ifdef PLMXML60_EXPORTS
#define PLMXML60_API __declspec(dllexport)
#else
#define PLMXML60_API __declspec(dllimport)
#endif
#else
#define PLMXML60_API
#endif

//////////////////////////////////////////////////////////////////////

#include <plmxml.h>

// <PLMXML_UserCode type="includeHeader" >
/*! \namespace plmxml60
    \brief PLM XML SDK schema specific API namespace.

    plmxml60 namespace includes schema specific auto-generated classes.
*/
// </PLMXML_UserCode>

PLMXML_BEGIN_NAMESPACE( plmxml60 )

/////////////////////////////////////////////////////////////////////////
 
// <PLMXML_UserCode type="classHeader" >
class ProductRevisionView;
//! Part class - deprecated use ProductRevisionView
typedef ProductRevisionView Part;
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassPart;

//! Checks the consistency of the run-time model represented by an object
/*!
	At the moment only objects derived from DocumentBase are supported. The 
    Document, and any referenced Documents, are checked.

    @param pObject  Object to be validated
    @param config   Configuration options

    The configuration options supported are:
 
    \verbatim
    validation
        type_checking    - specifies whether reference type-checking is
                           performed. The type of an IDREF or URI reference
                           can be specified in the schema by using the "plm:refType"
                           attribute. If this option is set to "on", type-checking
                           is performed. If set to "off", it is not. The default
                           is "on".
 
        rule
            exclude      - specifies that certain rules should not be checked. The
                           value of the option gives the names of the ignored rules,
                           separated by spaces. For example, "Occurrence_1 ProductView_2".
	\endverbatim
    
*/
PLMXML60_API plmxml_api::Result Validate( plmxml_api::Object* pObject, plmxml_api::Configuration* config = NULL );

// </PLMXML_UserCode>

////////////////////////////////////////////////////////////////////////////////////
//! eSectionDisplayEnum class
/*!
Allowed Values:
\verbatim
  eSectionDisplayEnumSlice
	"slice"
  eSectionDisplayEnumSection
	"section"
  
\endverbatim
*/
class PLMXML60_API eSectionDisplayEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eSectionDisplayEnum( const char* Type );
     
	//! Constructor
	eSectionDisplayEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	eSectionDisplayEnum( );
     
	//! Destructor 
	virtual ~eSectionDisplayEnum( );
     
	//! Assign from 'Type'
	const eSectionDisplayEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eSectionDisplayEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare SectionDisplayEnum
	friend plmxml_api::logical PLMXML60_API operator==( const eSectionDisplayEnum& e1, const eSectionDisplayEnum& e2 );
     
	//! Compare SectionDisplayEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const eSectionDisplayEnum& e1, const eSectionDisplayEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumSectionDisplayEnum;
extern PLMXML60_API eSectionDisplayEnum eSectionDisplayEnumUnset;
extern PLMXML60_API eSectionDisplayEnum eSectionDisplayEnumSlice;
extern PLMXML60_API eSectionDisplayEnum eSectionDisplayEnumSection;

////////////////////////////////////////////////////////////////////////////////////
//! eSpecificHeatCapacityEnum class
/*!
Allowed Values:
\verbatim
  eSpecificHeatCapacityEnumConstantPressure
	"constantPressure"
  eSpecificHeatCapacityEnumConstantVolume
	"constantVolume"
  
\endverbatim
*/
class PLMXML60_API eSpecificHeatCapacityEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eSpecificHeatCapacityEnum( const char* Type );
     
	//! Constructor
	eSpecificHeatCapacityEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	eSpecificHeatCapacityEnum( );
     
	//! Destructor 
	virtual ~eSpecificHeatCapacityEnum( );
     
	//! Assign from 'Type'
	const eSpecificHeatCapacityEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eSpecificHeatCapacityEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare SpecificHeatCapacityEnum
	friend plmxml_api::logical PLMXML60_API operator==( const eSpecificHeatCapacityEnum& e1, const eSpecificHeatCapacityEnum& e2 );
     
	//! Compare SpecificHeatCapacityEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const eSpecificHeatCapacityEnum& e1, const eSpecificHeatCapacityEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumSpecificHeatCapacityEnum;
extern PLMXML60_API eSpecificHeatCapacityEnum eSpecificHeatCapacityEnumUnset;
extern PLMXML60_API eSpecificHeatCapacityEnum eSpecificHeatCapacityEnumConstantPressure;
extern PLMXML60_API eSpecificHeatCapacityEnum eSpecificHeatCapacityEnumConstantVolume;

////////////////////////////////////////////////////////////////////////////////////
//! eLoadOptionRevisionType class
/*!
Allowed Values:
\verbatim
  eLoadOptionRevisionTypeLatest
	"latest"
  eLoadOptionRevisionTypeSpecified
	"specified"
  
\endverbatim
*/
class PLMXML60_API eLoadOptionRevisionType : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eLoadOptionRevisionType( const char* Type );
     
	//! Constructor
	eLoadOptionRevisionType( const plmxml_api::String& Type );
     
	//! Default Constructor
	eLoadOptionRevisionType( );
     
	//! Destructor 
	virtual ~eLoadOptionRevisionType( );
     
	//! Assign from 'Type'
	const eLoadOptionRevisionType& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eLoadOptionRevisionType& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare LoadOptionRevisionType
	friend plmxml_api::logical PLMXML60_API operator==( const eLoadOptionRevisionType& e1, const eLoadOptionRevisionType& e2 );
     
	//! Compare LoadOptionRevisionType
	friend plmxml_api::logical PLMXML60_API operator!=( const eLoadOptionRevisionType& e1, const eLoadOptionRevisionType& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumLoadOptionRevisionType;
extern PLMXML60_API eLoadOptionRevisionType eLoadOptionRevisionTypeUnset;
extern PLMXML60_API eLoadOptionRevisionType eLoadOptionRevisionTypeLatest;
extern PLMXML60_API eLoadOptionRevisionType eLoadOptionRevisionTypeSpecified;

////////////////////////////////////////////////////////////////////////////////////
//! eValidationCentroidEnum class
/*!
Allowed Values:
\verbatim
  eValidationCentroidEnumSurface
	"surface"
  eValidationCentroidEnumCurve
	"curve"
  eValidationCentroidEnumPolyline
	"polyline"
  
\endverbatim
*/
class PLMXML60_API eValidationCentroidEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eValidationCentroidEnum( const char* Type );
     
	//! Constructor
	eValidationCentroidEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	eValidationCentroidEnum( );
     
	//! Destructor 
	virtual ~eValidationCentroidEnum( );
     
	//! Assign from 'Type'
	const eValidationCentroidEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eValidationCentroidEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare ValidationCentroidEnum
	friend plmxml_api::logical PLMXML60_API operator==( const eValidationCentroidEnum& e1, const eValidationCentroidEnum& e2 );
     
	//! Compare ValidationCentroidEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const eValidationCentroidEnum& e1, const eValidationCentroidEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumValidationCentroidEnum;
extern PLMXML60_API eValidationCentroidEnum eValidationCentroidEnumUnset;
extern PLMXML60_API eValidationCentroidEnum eValidationCentroidEnumSurface;
extern PLMXML60_API eValidationCentroidEnum eValidationCentroidEnumCurve;
extern PLMXML60_API eValidationCentroidEnum eValidationCentroidEnumPolyline;

////////////////////////////////////////////////////////////////////////////////////
//! eValidationSurfaceAreaEnum class
/*!
Allowed Values:
\verbatim
  eValidationSurfaceAreaEnumAttached
	"attached"
  eValidationSurfaceAreaEnumAssociated
	"associated"
  eValidationSurfaceAreaEnumTessellated
	"tessellated"
  
\endverbatim
*/
class PLMXML60_API eValidationSurfaceAreaEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eValidationSurfaceAreaEnum( const char* Type );
     
	//! Constructor
	eValidationSurfaceAreaEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	eValidationSurfaceAreaEnum( );
     
	//! Destructor 
	virtual ~eValidationSurfaceAreaEnum( );
     
	//! Assign from 'Type'
	const eValidationSurfaceAreaEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eValidationSurfaceAreaEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare ValidationSurfaceAreaEnum
	friend plmxml_api::logical PLMXML60_API operator==( const eValidationSurfaceAreaEnum& e1, const eValidationSurfaceAreaEnum& e2 );
     
	//! Compare ValidationSurfaceAreaEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const eValidationSurfaceAreaEnum& e1, const eValidationSurfaceAreaEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumValidationSurfaceAreaEnum;
extern PLMXML60_API eValidationSurfaceAreaEnum eValidationSurfaceAreaEnumUnset;
extern PLMXML60_API eValidationSurfaceAreaEnum eValidationSurfaceAreaEnumAttached;
extern PLMXML60_API eValidationSurfaceAreaEnum eValidationSurfaceAreaEnumAssociated;
extern PLMXML60_API eValidationSurfaceAreaEnum eValidationSurfaceAreaEnumTessellated;

////////////////////////////////////////////////////////////////////////////////////
//! eSectionGeometryEnum class
/*!
Allowed Values:
\verbatim
  eSectionGeometryEnumParallelPlanes
	"parallelPlanes"
  eSectionGeometryEnumSinglePlane
	"singlePlane"
  eSectionGeometryEnumBox
	"box"
  
\endverbatim
*/
class PLMXML60_API eSectionGeometryEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eSectionGeometryEnum( const char* Type );
     
	//! Constructor
	eSectionGeometryEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	eSectionGeometryEnum( );
     
	//! Destructor 
	virtual ~eSectionGeometryEnum( );
     
	//! Assign from 'Type'
	const eSectionGeometryEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eSectionGeometryEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare SectionGeometryEnum
	friend plmxml_api::logical PLMXML60_API operator==( const eSectionGeometryEnum& e1, const eSectionGeometryEnum& e2 );
     
	//! Compare SectionGeometryEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const eSectionGeometryEnum& e1, const eSectionGeometryEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumSectionGeometryEnum;
extern PLMXML60_API eSectionGeometryEnum eSectionGeometryEnumUnset;
extern PLMXML60_API eSectionGeometryEnum eSectionGeometryEnumParallelPlanes;
extern PLMXML60_API eSectionGeometryEnum eSectionGeometryEnumSinglePlane;
extern PLMXML60_API eSectionGeometryEnum eSectionGeometryEnumBox;

////////////////////////////////////////////////////////////////////////////////////
//! eLoadOptionPreferredRepresentationsScopeType class
/*!
Allowed Values:
\verbatim
  eLoadOptionPreferredRepresentationsScopeTypeTop
	"top"
  eLoadOptionPreferredRepresentationsScopeTypeAll
	"all"
  
\endverbatim
*/
class PLMXML60_API eLoadOptionPreferredRepresentationsScopeType : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eLoadOptionPreferredRepresentationsScopeType( const char* Type );
     
	//! Constructor
	eLoadOptionPreferredRepresentationsScopeType( const plmxml_api::String& Type );
     
	//! Default Constructor
	eLoadOptionPreferredRepresentationsScopeType( );
     
	//! Destructor 
	virtual ~eLoadOptionPreferredRepresentationsScopeType( );
     
	//! Assign from 'Type'
	const eLoadOptionPreferredRepresentationsScopeType& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eLoadOptionPreferredRepresentationsScopeType& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare LoadOptionPreferredRepresentationsScopeType
	friend plmxml_api::logical PLMXML60_API operator==( const eLoadOptionPreferredRepresentationsScopeType& e1, const eLoadOptionPreferredRepresentationsScopeType& e2 );
     
	//! Compare LoadOptionPreferredRepresentationsScopeType
	friend plmxml_api::logical PLMXML60_API operator!=( const eLoadOptionPreferredRepresentationsScopeType& e1, const eLoadOptionPreferredRepresentationsScopeType& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumLoadOptionPreferredRepresentationsScopeType;
extern PLMXML60_API eLoadOptionPreferredRepresentationsScopeType eLoadOptionPreferredRepresentationsScopeTypeUnset;
extern PLMXML60_API eLoadOptionPreferredRepresentationsScopeType eLoadOptionPreferredRepresentationsScopeTypeTop;
extern PLMXML60_API eLoadOptionPreferredRepresentationsScopeType eLoadOptionPreferredRepresentationsScopeTypeAll;

////////////////////////////////////////////////////////////////////////////////////
//! eSectionEnum class
/*!
Allowed Values:
\verbatim
  eSectionEnumStandard
	"standard"
  eSectionEnumLightweight
	"lightweight"
  
\endverbatim
*/
class PLMXML60_API eSectionEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eSectionEnum( const char* Type );
     
	//! Constructor
	eSectionEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	eSectionEnum( );
     
	//! Destructor 
	virtual ~eSectionEnum( );
     
	//! Assign from 'Type'
	const eSectionEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eSectionEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare SectionEnum
	friend plmxml_api::logical PLMXML60_API operator==( const eSectionEnum& e1, const eSectionEnum& e2 );
     
	//! Compare SectionEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const eSectionEnum& e1, const eSectionEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumSectionEnum;
extern PLMXML60_API eSectionEnum eSectionEnumUnset;
extern PLMXML60_API eSectionEnum eSectionEnumStandard;
extern PLMXML60_API eSectionEnum eSectionEnumLightweight;

////////////////////////////////////////////////////////////////////////////////////
//! ePropertyFilterOperationEnum class
/*!
Allowed Values:
\verbatim
  ePropertyFilterOperationEnumLessThanOrEqual
	"lessThanOrEqual"
  ePropertyFilterOperationEnumAny
	"any"
  ePropertyFilterOperationEnumGreaterThanOrEqual
	"greaterThanOrEqual"
  ePropertyFilterOperationEnumGreaterThan
	"greaterThan"
  ePropertyFilterOperationEnumLessThan
	"lessThan"
  ePropertyFilterOperationEnumBegins
	"begins"
  ePropertyFilterOperationEnumEqual
	"equal"
  ePropertyFilterOperationEnumNotEqual
	"notEqual"
  ePropertyFilterOperationEnumRegularExpression
	"regularExpression"
  ePropertyFilterOperationEnumContains
	"contains"
  
\endverbatim
*/
class PLMXML60_API ePropertyFilterOperationEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	ePropertyFilterOperationEnum( const char* Type );
     
	//! Constructor
	ePropertyFilterOperationEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	ePropertyFilterOperationEnum( );
     
	//! Destructor 
	virtual ~ePropertyFilterOperationEnum( );
     
	//! Assign from 'Type'
	const ePropertyFilterOperationEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const ePropertyFilterOperationEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare PropertyFilterOperationEnum
	friend plmxml_api::logical PLMXML60_API operator==( const ePropertyFilterOperationEnum& e1, const ePropertyFilterOperationEnum& e2 );
     
	//! Compare PropertyFilterOperationEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const ePropertyFilterOperationEnum& e1, const ePropertyFilterOperationEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumPropertyFilterOperationEnum;
extern PLMXML60_API ePropertyFilterOperationEnum ePropertyFilterOperationEnumUnset;
extern PLMXML60_API ePropertyFilterOperationEnum ePropertyFilterOperationEnumLessThanOrEqual;
extern PLMXML60_API ePropertyFilterOperationEnum ePropertyFilterOperationEnumAny;
extern PLMXML60_API ePropertyFilterOperationEnum ePropertyFilterOperationEnumGreaterThanOrEqual;
extern PLMXML60_API ePropertyFilterOperationEnum ePropertyFilterOperationEnumGreaterThan;
extern PLMXML60_API ePropertyFilterOperationEnum ePropertyFilterOperationEnumLessThan;
extern PLMXML60_API ePropertyFilterOperationEnum ePropertyFilterOperationEnumBegins;
extern PLMXML60_API ePropertyFilterOperationEnum ePropertyFilterOperationEnumEqual;
extern PLMXML60_API ePropertyFilterOperationEnum ePropertyFilterOperationEnumNotEqual;
extern PLMXML60_API ePropertyFilterOperationEnum ePropertyFilterOperationEnumRegularExpression;
extern PLMXML60_API ePropertyFilterOperationEnum ePropertyFilterOperationEnumContains;

////////////////////////////////////////////////////////////////////////////////////
//! eLogicalOperationType class
/*!
Allowed Values:
\verbatim
  eLogicalOperationTypeEq
	"eq"
  eLogicalOperationTypeGt
	"gt"
  eLogicalOperationTypeNe
	"ne"
  eLogicalOperationTypeLe
	"le"
  eLogicalOperationTypeLt
	"lt"
  eLogicalOperationTypeGe
	"ge"
  
\endverbatim
*/
class PLMXML60_API eLogicalOperationType : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eLogicalOperationType( const char* Type );
     
	//! Constructor
	eLogicalOperationType( const plmxml_api::String& Type );
     
	//! Default Constructor
	eLogicalOperationType( );
     
	//! Destructor 
	virtual ~eLogicalOperationType( );
     
	//! Assign from 'Type'
	const eLogicalOperationType& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eLogicalOperationType& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare LogicalOperationType
	friend plmxml_api::logical PLMXML60_API operator==( const eLogicalOperationType& e1, const eLogicalOperationType& e2 );
     
	//! Compare LogicalOperationType
	friend plmxml_api::logical PLMXML60_API operator!=( const eLogicalOperationType& e1, const eLogicalOperationType& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumLogicalOperationType;
extern PLMXML60_API eLogicalOperationType eLogicalOperationTypeUnset;
extern PLMXML60_API eLogicalOperationType eLogicalOperationTypeEq;
extern PLMXML60_API eLogicalOperationType eLogicalOperationTypeGt;
extern PLMXML60_API eLogicalOperationType eLogicalOperationTypeNe;
extern PLMXML60_API eLogicalOperationType eLogicalOperationTypeLe;
extern PLMXML60_API eLogicalOperationType eLogicalOperationTypeLt;
extern PLMXML60_API eLogicalOperationType eLogicalOperationTypeGe;

////////////////////////////////////////////////////////////////////////////////////
//! eProductViewStateEnum class
/*!
Allowed Values:
\verbatim
  eProductViewStateEnumActive
	"active"
  
\endverbatim
*/
class PLMXML60_API eProductViewStateEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eProductViewStateEnum( const char* Type );
     
	//! Constructor
	eProductViewStateEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	eProductViewStateEnum( );
     
	//! Destructor 
	virtual ~eProductViewStateEnum( );
     
	//! Assign from 'Type'
	const eProductViewStateEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eProductViewStateEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare ProductViewStateEnum
	friend plmxml_api::logical PLMXML60_API operator==( const eProductViewStateEnum& e1, const eProductViewStateEnum& e2 );
     
	//! Compare ProductViewStateEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const eProductViewStateEnum& e1, const eProductViewStateEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumProductViewStateEnum;
extern PLMXML60_API eProductViewStateEnum eProductViewStateEnumUnset;
extern PLMXML60_API eProductViewStateEnum eProductViewStateEnumActive;

////////////////////////////////////////////////////////////////////////////////////
//! eGrooveEnum class
/*!
Allowed Values:
\verbatim
  eGrooveEnumJGroove
	"jGroove"
  eGrooveEnumFlaredBevel
	"flaredBevel"
  eGrooveEnumVGroove
	"vGroove"
  eGrooveEnumFlaredV
	"flaredV"
  eGrooveEnumUGroove
	"uGroove"
  eGrooveEnumBevel
	"bevel"
  eGrooveEnumSquare
	"square"
  
\endverbatim
*/
class PLMXML60_API eGrooveEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eGrooveEnum( const char* Type );
     
	//! Constructor
	eGrooveEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	eGrooveEnum( );
     
	//! Destructor 
	virtual ~eGrooveEnum( );
     
	//! Assign from 'Type'
	const eGrooveEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eGrooveEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare GrooveEnum
	friend plmxml_api::logical PLMXML60_API operator==( const eGrooveEnum& e1, const eGrooveEnum& e2 );
     
	//! Compare GrooveEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const eGrooveEnum& e1, const eGrooveEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumGrooveEnum;
extern PLMXML60_API eGrooveEnum eGrooveEnumUnset;
extern PLMXML60_API eGrooveEnum eGrooveEnumJGroove;
extern PLMXML60_API eGrooveEnum eGrooveEnumFlaredBevel;
extern PLMXML60_API eGrooveEnum eGrooveEnumVGroove;
extern PLMXML60_API eGrooveEnum eGrooveEnumFlaredV;
extern PLMXML60_API eGrooveEnum eGrooveEnumUGroove;
extern PLMXML60_API eGrooveEnum eGrooveEnumBevel;
extern PLMXML60_API eGrooveEnum eGrooveEnumSquare;

////////////////////////////////////////////////////////////////////////////////////
//! eLineThicknessEnum class
/*!
Allowed Values:
\verbatim
  eLineThicknessEnumThick
	"thick"
  eLineThicknessEnumThin
	"thin"
  eLineThicknessEnumNormal
	"normal"
  
\endverbatim
*/
class PLMXML60_API eLineThicknessEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eLineThicknessEnum( const char* Type );
     
	//! Constructor
	eLineThicknessEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	eLineThicknessEnum( );
     
	//! Destructor 
	virtual ~eLineThicknessEnum( );
     
	//! Assign from 'Type'
	const eLineThicknessEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eLineThicknessEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare LineThicknessEnum
	friend plmxml_api::logical PLMXML60_API operator==( const eLineThicknessEnum& e1, const eLineThicknessEnum& e2 );
     
	//! Compare LineThicknessEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const eLineThicknessEnum& e1, const eLineThicknessEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumLineThicknessEnum;
extern PLMXML60_API eLineThicknessEnum eLineThicknessEnumUnset;
extern PLMXML60_API eLineThicknessEnum eLineThicknessEnumThick;
extern PLMXML60_API eLineThicknessEnum eLineThicknessEnumThin;
extern PLMXML60_API eLineThicknessEnum eLineThicknessEnumNormal;

////////////////////////////////////////////////////////////////////////////////////
//! eAccessIntentEnum class
/*!
Allowed Values:
\verbatim
  eAccessIntentEnumReference
	"reference"
  eAccessIntentEnumModifiable
	"modifiable"
  eAccessIntentEnumNoAccess
	"noAccess"
  
\endverbatim
*/
class PLMXML60_API eAccessIntentEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eAccessIntentEnum( const char* Type );
     
	//! Constructor
	eAccessIntentEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	eAccessIntentEnum( );
     
	//! Destructor 
	virtual ~eAccessIntentEnum( );
     
	//! Assign from 'Type'
	const eAccessIntentEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eAccessIntentEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare AccessIntentEnum
	friend plmxml_api::logical PLMXML60_API operator==( const eAccessIntentEnum& e1, const eAccessIntentEnum& e2 );
     
	//! Compare AccessIntentEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const eAccessIntentEnum& e1, const eAccessIntentEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumAccessIntentEnum;
extern PLMXML60_API eAccessIntentEnum eAccessIntentEnumUnset;
extern PLMXML60_API eAccessIntentEnum eAccessIntentEnumReference;
extern PLMXML60_API eAccessIntentEnum eAccessIntentEnumModifiable;
extern PLMXML60_API eAccessIntentEnum eAccessIntentEnumNoAccess;

////////////////////////////////////////////////////////////////////////////////////
//! eRefSelectType class
/*!
Allowed Values:
\verbatim
  eRefSelectTypeSingle
	"single"
  eRefSelectTypeMultiple
	"multiple"
  
\endverbatim
*/
class PLMXML60_API eRefSelectType : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eRefSelectType( const char* Type );
     
	//! Constructor
	eRefSelectType( const plmxml_api::String& Type );
     
	//! Default Constructor
	eRefSelectType( );
     
	//! Destructor 
	virtual ~eRefSelectType( );
     
	//! Assign from 'Type'
	const eRefSelectType& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eRefSelectType& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare RefSelectType
	friend plmxml_api::logical PLMXML60_API operator==( const eRefSelectType& e1, const eRefSelectType& e2 );
     
	//! Compare RefSelectType
	friend plmxml_api::logical PLMXML60_API operator!=( const eRefSelectType& e1, const eRefSelectType& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumRefSelectType;
extern PLMXML60_API eRefSelectType eRefSelectTypeUnset;
extern PLMXML60_API eRefSelectType eRefSelectTypeSingle;
extern PLMXML60_API eRefSelectType eRefSelectTypeMultiple;

////////////////////////////////////////////////////////////////////////////////////
//! eExpressionFormatEnum class
/*!
Allowed Values:
\verbatim
  eExpressionFormatEnumMro
	"mro"
  eExpressionFormatEnumNx
	"nx"
  eExpressionFormatEnumExcel
	"excel"
  
\endverbatim
*/
class PLMXML60_API eExpressionFormatEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eExpressionFormatEnum( const char* Type );
     
	//! Constructor
	eExpressionFormatEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	eExpressionFormatEnum( );
     
	//! Destructor 
	virtual ~eExpressionFormatEnum( );
     
	//! Assign from 'Type'
	const eExpressionFormatEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eExpressionFormatEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare ExpressionFormatEnum
	friend plmxml_api::logical PLMXML60_API operator==( const eExpressionFormatEnum& e1, const eExpressionFormatEnum& e2 );
     
	//! Compare ExpressionFormatEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const eExpressionFormatEnum& e1, const eExpressionFormatEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumExpressionFormatEnum;
extern PLMXML60_API eExpressionFormatEnum eExpressionFormatEnumUnset;
extern PLMXML60_API eExpressionFormatEnum eExpressionFormatEnumMro;
extern PLMXML60_API eExpressionFormatEnum eExpressionFormatEnumNx;
extern PLMXML60_API eExpressionFormatEnum eExpressionFormatEnumExcel;

////////////////////////////////////////////////////////////////////////////////////
//! eTextureWrapType class
/*!
Allowed Values:
\verbatim
  eTextureWrapTypeWrap
	"wrap"
  eTextureWrapTypeClamp
	"clamp"
  
\endverbatim
*/
class PLMXML60_API eTextureWrapType : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eTextureWrapType( const char* Type );
     
	//! Constructor
	eTextureWrapType( const plmxml_api::String& Type );
     
	//! Default Constructor
	eTextureWrapType( );
     
	//! Destructor 
	virtual ~eTextureWrapType( );
     
	//! Assign from 'Type'
	const eTextureWrapType& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eTextureWrapType& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare TextureWrapType
	friend plmxml_api::logical PLMXML60_API operator==( const eTextureWrapType& e1, const eTextureWrapType& e2 );
     
	//! Compare TextureWrapType
	friend plmxml_api::logical PLMXML60_API operator!=( const eTextureWrapType& e1, const eTextureWrapType& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumTextureWrapType;
extern PLMXML60_API eTextureWrapType eTextureWrapTypeUnset;
extern PLMXML60_API eTextureWrapType eTextureWrapTypeWrap;
extern PLMXML60_API eTextureWrapType eTextureWrapTypeClamp;

////////////////////////////////////////////////////////////////////////////////////
//! eMembershipOwnerEnum class
/*!
Allowed Values:
\verbatim
  eMembershipOwnerEnumPartition
	"partition"
  eMembershipOwnerEnumDesignElement
	"designElement"
  
\endverbatim
*/
class PLMXML60_API eMembershipOwnerEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eMembershipOwnerEnum( const char* Type );
     
	//! Constructor
	eMembershipOwnerEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	eMembershipOwnerEnum( );
     
	//! Destructor 
	virtual ~eMembershipOwnerEnum( );
     
	//! Assign from 'Type'
	const eMembershipOwnerEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eMembershipOwnerEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare MembershipOwnerEnum
	friend plmxml_api::logical PLMXML60_API operator==( const eMembershipOwnerEnum& e1, const eMembershipOwnerEnum& e2 );
     
	//! Compare MembershipOwnerEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const eMembershipOwnerEnum& e1, const eMembershipOwnerEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumMembershipOwnerEnum;
extern PLMXML60_API eMembershipOwnerEnum eMembershipOwnerEnumUnset;
extern PLMXML60_API eMembershipOwnerEnum eMembershipOwnerEnumPartition;
extern PLMXML60_API eMembershipOwnerEnum eMembershipOwnerEnumDesignElement;

////////////////////////////////////////////////////////////////////////////////////
//! eProductSourceEnum class
/*!
Allowed Values:
\verbatim
  eProductSourceEnumBuy
	"buy"
  eProductSourceEnumMake
	"make"
  
\endverbatim
*/
class PLMXML60_API eProductSourceEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eProductSourceEnum( const char* Type );
     
	//! Constructor
	eProductSourceEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	eProductSourceEnum( );
     
	//! Destructor 
	virtual ~eProductSourceEnum( );
     
	//! Assign from 'Type'
	const eProductSourceEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eProductSourceEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare ProductSourceEnum
	friend plmxml_api::logical PLMXML60_API operator==( const eProductSourceEnum& e1, const eProductSourceEnum& e2 );
     
	//! Compare ProductSourceEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const eProductSourceEnum& e1, const eProductSourceEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumProductSourceEnum;
extern PLMXML60_API eProductSourceEnum eProductSourceEnumUnset;
extern PLMXML60_API eProductSourceEnum eProductSourceEnumBuy;
extern PLMXML60_API eProductSourceEnum eProductSourceEnumMake;

////////////////////////////////////////////////////////////////////////////////////
//! eAssemblyCrosshatchEnum class
/*!
Allowed Values:
\verbatim
  eAssemblyCrosshatchEnumNone
	"none"
  eAssemblyCrosshatchEnumVariable
	"variable"
  eAssemblyCrosshatchEnumDiagonal
	"diagonal"
  
\endverbatim
*/
class PLMXML60_API eAssemblyCrosshatchEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eAssemblyCrosshatchEnum( const char* Type );
     
	//! Constructor
	eAssemblyCrosshatchEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	eAssemblyCrosshatchEnum( );
     
	//! Destructor 
	virtual ~eAssemblyCrosshatchEnum( );
     
	//! Assign from 'Type'
	const eAssemblyCrosshatchEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eAssemblyCrosshatchEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare AssemblyCrosshatchEnum
	friend plmxml_api::logical PLMXML60_API operator==( const eAssemblyCrosshatchEnum& e1, const eAssemblyCrosshatchEnum& e2 );
     
	//! Compare AssemblyCrosshatchEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const eAssemblyCrosshatchEnum& e1, const eAssemblyCrosshatchEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumAssemblyCrosshatchEnum;
extern PLMXML60_API eAssemblyCrosshatchEnum eAssemblyCrosshatchEnumUnset;
extern PLMXML60_API eAssemblyCrosshatchEnum eAssemblyCrosshatchEnumNone;
extern PLMXML60_API eAssemblyCrosshatchEnum eAssemblyCrosshatchEnumVariable;
extern PLMXML60_API eAssemblyCrosshatchEnum eAssemblyCrosshatchEnumDiagonal;

////////////////////////////////////////////////////////////////////////////////////
//! eTextureMapType class
/*!
Allowed Values:
\verbatim
  eTextureMapTypeDecal
	"decal"
  eTextureMapTypeBlend
	"blend"
  eTextureMapTypeModulate
	"modulate"
  
\endverbatim
*/
class PLMXML60_API eTextureMapType : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eTextureMapType( const char* Type );
     
	//! Constructor
	eTextureMapType( const plmxml_api::String& Type );
     
	//! Default Constructor
	eTextureMapType( );
     
	//! Destructor 
	virtual ~eTextureMapType( );
     
	//! Assign from 'Type'
	const eTextureMapType& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eTextureMapType& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare TextureMapType
	friend plmxml_api::logical PLMXML60_API operator==( const eTextureMapType& e1, const eTextureMapType& e2 );
     
	//! Compare TextureMapType
	friend plmxml_api::logical PLMXML60_API operator!=( const eTextureMapType& e1, const eTextureMapType& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumTextureMapType;
extern PLMXML60_API eTextureMapType eTextureMapTypeUnset;
extern PLMXML60_API eTextureMapType eTextureMapTypeDecal;
extern PLMXML60_API eTextureMapType eTextureMapTypeBlend;
extern PLMXML60_API eTextureMapType eTextureMapTypeModulate;

////////////////////////////////////////////////////////////////////////////////////
//! eUnitPrefixType class
/*!
Allowed Values:
\verbatim
  eUnitPrefixTypePeta
	"peta"
  eUnitPrefixTypeFemto
	"femto"
  eUnitPrefixTypeDeka
	"deka"
  eUnitPrefixTypeYocto
	"yocto"
  eUnitPrefixTypePico
	"pico"
  eUnitPrefixTypeMega
	"mega"
  eUnitPrefixTypeMicro
	"micro"
  eUnitPrefixTypeHecto
	"hecto"
  eUnitPrefixTypeZepto
	"zepto"
  eUnitPrefixTypeTera
	"tera"
  eUnitPrefixTypeExa
	"exa"
  eUnitPrefixTypeNano
	"nano"
  eUnitPrefixTypeKilo
	"kilo"
  eUnitPrefixTypeAtto
	"atto"
  eUnitPrefixTypeMilli
	"milli"
  eUnitPrefixTypeCenti
	"centi"
  eUnitPrefixTypeZetta
	"zetta"
  eUnitPrefixTypeDeci
	"deci"
  eUnitPrefixTypeYotta
	"yotta"
  eUnitPrefixTypeGiga
	"giga"
  
\endverbatim
*/
class PLMXML60_API eUnitPrefixType : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eUnitPrefixType( const char* Type );
     
	//! Constructor
	eUnitPrefixType( const plmxml_api::String& Type );
     
	//! Default Constructor
	eUnitPrefixType( );
     
	//! Destructor 
	virtual ~eUnitPrefixType( );
     
	//! Assign from 'Type'
	const eUnitPrefixType& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eUnitPrefixType& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare UnitPrefixType
	friend plmxml_api::logical PLMXML60_API operator==( const eUnitPrefixType& e1, const eUnitPrefixType& e2 );
     
	//! Compare UnitPrefixType
	friend plmxml_api::logical PLMXML60_API operator!=( const eUnitPrefixType& e1, const eUnitPrefixType& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumUnitPrefixType;
extern PLMXML60_API eUnitPrefixType eUnitPrefixTypeUnset;
extern PLMXML60_API eUnitPrefixType eUnitPrefixTypePeta;
extern PLMXML60_API eUnitPrefixType eUnitPrefixTypeFemto;
extern PLMXML60_API eUnitPrefixType eUnitPrefixTypeDeka;
extern PLMXML60_API eUnitPrefixType eUnitPrefixTypeYocto;
extern PLMXML60_API eUnitPrefixType eUnitPrefixTypePico;
extern PLMXML60_API eUnitPrefixType eUnitPrefixTypeMega;
extern PLMXML60_API eUnitPrefixType eUnitPrefixTypeMicro;
extern PLMXML60_API eUnitPrefixType eUnitPrefixTypeHecto;
extern PLMXML60_API eUnitPrefixType eUnitPrefixTypeZepto;
extern PLMXML60_API eUnitPrefixType eUnitPrefixTypeTera;
extern PLMXML60_API eUnitPrefixType eUnitPrefixTypeExa;
extern PLMXML60_API eUnitPrefixType eUnitPrefixTypeNano;
extern PLMXML60_API eUnitPrefixType eUnitPrefixTypeKilo;
extern PLMXML60_API eUnitPrefixType eUnitPrefixTypeAtto;
extern PLMXML60_API eUnitPrefixType eUnitPrefixTypeMilli;
extern PLMXML60_API eUnitPrefixType eUnitPrefixTypeCenti;
extern PLMXML60_API eUnitPrefixType eUnitPrefixTypeZetta;
extern PLMXML60_API eUnitPrefixType eUnitPrefixTypeDeci;
extern PLMXML60_API eUnitPrefixType eUnitPrefixTypeYotta;
extern PLMXML60_API eUnitPrefixType eUnitPrefixTypeGiga;

////////////////////////////////////////////////////////////////////////////////////
//! eCompoundRepTypeEnum class
/*!
Allowed Values:
\verbatim
  eCompoundRepTypeEnumDefault
	"default"
  eCompoundRepTypeEnumWeld
	"weld"
  eCompoundRepTypeEnumMidsurface
	"midsurface"
  eCompoundRepTypeEnumConstruction
	"construction"
  
\endverbatim
*/
class PLMXML60_API eCompoundRepTypeEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eCompoundRepTypeEnum( const char* Type );
     
	//! Constructor
	eCompoundRepTypeEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	eCompoundRepTypeEnum( );
     
	//! Destructor 
	virtual ~eCompoundRepTypeEnum( );
     
	//! Assign from 'Type'
	const eCompoundRepTypeEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eCompoundRepTypeEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare CompoundRepTypeEnum
	friend plmxml_api::logical PLMXML60_API operator==( const eCompoundRepTypeEnum& e1, const eCompoundRepTypeEnum& e2 );
     
	//! Compare CompoundRepTypeEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const eCompoundRepTypeEnum& e1, const eCompoundRepTypeEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumCompoundRepTypeEnum;
extern PLMXML60_API eCompoundRepTypeEnum eCompoundRepTypeEnumUnset;
extern PLMXML60_API eCompoundRepTypeEnum eCompoundRepTypeEnumDefault;
extern PLMXML60_API eCompoundRepTypeEnum eCompoundRepTypeEnumWeld;
extern PLMXML60_API eCompoundRepTypeEnum eCompoundRepTypeEnumMidsurface;
extern PLMXML60_API eCompoundRepTypeEnum eCompoundRepTypeEnumConstruction;

////////////////////////////////////////////////////////////////////////////////////
//! eProductViewDefinitionType class
/*!
Allowed Values:
\verbatim
  eProductViewDefinitionTypeOverlay
	"overlay"
  eProductViewDefinitionTypeSelect
	"select"
  
\endverbatim
*/
class PLMXML60_API eProductViewDefinitionType : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eProductViewDefinitionType( const char* Type );
     
	//! Constructor
	eProductViewDefinitionType( const plmxml_api::String& Type );
     
	//! Default Constructor
	eProductViewDefinitionType( );
     
	//! Destructor 
	virtual ~eProductViewDefinitionType( );
     
	//! Assign from 'Type'
	const eProductViewDefinitionType& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eProductViewDefinitionType& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare ProductViewDefinitionType
	friend plmxml_api::logical PLMXML60_API operator==( const eProductViewDefinitionType& e1, const eProductViewDefinitionType& e2 );
     
	//! Compare ProductViewDefinitionType
	friend plmxml_api::logical PLMXML60_API operator!=( const eProductViewDefinitionType& e1, const eProductViewDefinitionType& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumProductViewDefinitionType;
extern PLMXML60_API eProductViewDefinitionType eProductViewDefinitionTypeUnset;
extern PLMXML60_API eProductViewDefinitionType eProductViewDefinitionTypeOverlay;
extern PLMXML60_API eProductViewDefinitionType eProductViewDefinitionTypeSelect;

////////////////////////////////////////////////////////////////////////////////////
//! eMassPropertyUnitType class
/*!
Allowed Values:
\verbatim
  eMassPropertyUnitTypePoundsFeet
	"pounds,feet"
  eMassPropertyUnitTypePoundsInches
	"pounds,inches"
  eMassPropertyUnitTypeGramsMillimetres
	"grams,millimetres"
  eMassPropertyUnitTypeGramsCentimetres
	"grams,centimetres"
  eMassPropertyUnitTypeKilogramsMetres
	"kilograms,metres"
  
\endverbatim
*/
class PLMXML60_API eMassPropertyUnitType : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eMassPropertyUnitType( const char* Type );
     
	//! Constructor
	eMassPropertyUnitType( const plmxml_api::String& Type );
     
	//! Default Constructor
	eMassPropertyUnitType( );
     
	//! Destructor 
	virtual ~eMassPropertyUnitType( );
     
	//! Assign from 'Type'
	const eMassPropertyUnitType& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eMassPropertyUnitType& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare MassPropertyUnitType
	friend plmxml_api::logical PLMXML60_API operator==( const eMassPropertyUnitType& e1, const eMassPropertyUnitType& e2 );
     
	//! Compare MassPropertyUnitType
	friend plmxml_api::logical PLMXML60_API operator!=( const eMassPropertyUnitType& e1, const eMassPropertyUnitType& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumMassPropertyUnitType;
extern PLMXML60_API eMassPropertyUnitType eMassPropertyUnitTypeUnset;
extern PLMXML60_API eMassPropertyUnitType eMassPropertyUnitTypePoundsFeet;
extern PLMXML60_API eMassPropertyUnitType eMassPropertyUnitTypePoundsInches;
extern PLMXML60_API eMassPropertyUnitType eMassPropertyUnitTypeGramsMillimetres;
extern PLMXML60_API eMassPropertyUnitType eMassPropertyUnitTypeGramsCentimetres;
extern PLMXML60_API eMassPropertyUnitType eMassPropertyUnitTypeKilogramsMetres;

////////////////////////////////////////////////////////////////////////////////////
//! eValidationLengthEnum class
/*!
Allowed Values:
\verbatim
  eValidationLengthEnumAssociated
	"associated"
  eValidationLengthEnumPolyline
	"polyline"
  eValidationLengthEnumTessellated
	"tessellated"
  eValidationLengthEnumAttached
	"attached"
  
\endverbatim
*/
class PLMXML60_API eValidationLengthEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eValidationLengthEnum( const char* Type );
     
	//! Constructor
	eValidationLengthEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	eValidationLengthEnum( );
     
	//! Destructor 
	virtual ~eValidationLengthEnum( );
     
	//! Assign from 'Type'
	const eValidationLengthEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eValidationLengthEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare ValidationLengthEnum
	friend plmxml_api::logical PLMXML60_API operator==( const eValidationLengthEnum& e1, const eValidationLengthEnum& e2 );
     
	//! Compare ValidationLengthEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const eValidationLengthEnum& e1, const eValidationLengthEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumValidationLengthEnum;
extern PLMXML60_API eValidationLengthEnum eValidationLengthEnumUnset;
extern PLMXML60_API eValidationLengthEnum eValidationLengthEnumAssociated;
extern PLMXML60_API eValidationLengthEnum eValidationLengthEnumPolyline;
extern PLMXML60_API eValidationLengthEnum eValidationLengthEnumTessellated;
extern PLMXML60_API eValidationLengthEnum eValidationLengthEnumAttached;

////////////////////////////////////////////////////////////////////////////////////
//! eLoadOptionLinkedComponentsType class
/*!
Allowed Values:
\verbatim
  eLoadOptionLinkedComponentsTypeAll
	"all"
  eLoadOptionLinkedComponentsTypeImmediate
	"immediate"
  eLoadOptionLinkedComponentsTypeNone
	"none"
  eLoadOptionLinkedComponentsTypeLinks
	"links"
  
\endverbatim
*/
class PLMXML60_API eLoadOptionLinkedComponentsType : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eLoadOptionLinkedComponentsType( const char* Type );
     
	//! Constructor
	eLoadOptionLinkedComponentsType( const plmxml_api::String& Type );
     
	//! Default Constructor
	eLoadOptionLinkedComponentsType( );
     
	//! Destructor 
	virtual ~eLoadOptionLinkedComponentsType( );
     
	//! Assign from 'Type'
	const eLoadOptionLinkedComponentsType& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eLoadOptionLinkedComponentsType& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare LoadOptionLinkedComponentsType
	friend plmxml_api::logical PLMXML60_API operator==( const eLoadOptionLinkedComponentsType& e1, const eLoadOptionLinkedComponentsType& e2 );
     
	//! Compare LoadOptionLinkedComponentsType
	friend plmxml_api::logical PLMXML60_API operator!=( const eLoadOptionLinkedComponentsType& e1, const eLoadOptionLinkedComponentsType& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumLoadOptionLinkedComponentsType;
extern PLMXML60_API eLoadOptionLinkedComponentsType eLoadOptionLinkedComponentsTypeUnset;
extern PLMXML60_API eLoadOptionLinkedComponentsType eLoadOptionLinkedComponentsTypeAll;
extern PLMXML60_API eLoadOptionLinkedComponentsType eLoadOptionLinkedComponentsTypeImmediate;
extern PLMXML60_API eLoadOptionLinkedComponentsType eLoadOptionLinkedComponentsTypeNone;
extern PLMXML60_API eLoadOptionLinkedComponentsType eLoadOptionLinkedComponentsTypeLinks;

////////////////////////////////////////////////////////////////////////////////////
//! eSortOrderEnum class
/*!
Allowed Values:
\verbatim
  eSortOrderEnumDefault
	"default"
  eSortOrderEnumAlphabetic
	"alphabetic"
  eSortOrderEnumAlphanumeric
	"alphanumeric"
  
\endverbatim
*/
class PLMXML60_API eSortOrderEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eSortOrderEnum( const char* Type );
     
	//! Constructor
	eSortOrderEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	eSortOrderEnum( );
     
	//! Destructor 
	virtual ~eSortOrderEnum( );
     
	//! Assign from 'Type'
	const eSortOrderEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eSortOrderEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare SortOrderEnum
	friend plmxml_api::logical PLMXML60_API operator==( const eSortOrderEnum& e1, const eSortOrderEnum& e2 );
     
	//! Compare SortOrderEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const eSortOrderEnum& e1, const eSortOrderEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumSortOrderEnum;
extern PLMXML60_API eSortOrderEnum eSortOrderEnumUnset;
extern PLMXML60_API eSortOrderEnum eSortOrderEnumDefault;
extern PLMXML60_API eSortOrderEnum eSortOrderEnumAlphabetic;
extern PLMXML60_API eSortOrderEnum eSortOrderEnumAlphanumeric;

////////////////////////////////////////////////////////////////////////////////////
//! eProductViewUsageType class
/*!
Allowed Values:
\verbatim
  eProductViewUsageTypeVariant
	"variant"
  eProductViewUsageTypePose
	"pose"
  eProductViewUsageTypeVisual
	"visual"
  eProductViewUsageTypeModelView
	"modelView"
  eProductViewUsageTypeArrangement
	"arrangement"
  
\endverbatim
*/
class PLMXML60_API eProductViewUsageType : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eProductViewUsageType( const char* Type );
     
	//! Constructor
	eProductViewUsageType( const plmxml_api::String& Type );
     
	//! Default Constructor
	eProductViewUsageType( );
     
	//! Destructor 
	virtual ~eProductViewUsageType( );
     
	//! Assign from 'Type'
	const eProductViewUsageType& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eProductViewUsageType& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare ProductViewUsageType
	friend plmxml_api::logical PLMXML60_API operator==( const eProductViewUsageType& e1, const eProductViewUsageType& e2 );
     
	//! Compare ProductViewUsageType
	friend plmxml_api::logical PLMXML60_API operator!=( const eProductViewUsageType& e1, const eProductViewUsageType& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumProductViewUsageType;
extern PLMXML60_API eProductViewUsageType eProductViewUsageTypeUnset;
extern PLMXML60_API eProductViewUsageType eProductViewUsageTypeVariant;
extern PLMXML60_API eProductViewUsageType eProductViewUsageTypePose;
extern PLMXML60_API eProductViewUsageType eProductViewUsageTypeVisual;
extern PLMXML60_API eProductViewUsageType eProductViewUsageTypeModelView;
extern PLMXML60_API eProductViewUsageType eProductViewUsageTypeArrangement;

////////////////////////////////////////////////////////////////////////////////////
//! eTextureDataFormatType class
/*!
Allowed Values:
\verbatim
  eTextureDataFormatTypeA
	"A"
  eTextureDataFormatTypeL
	"L"
  eTextureDataFormatTypeRGB
	"RGB"
  eTextureDataFormatTypeRGBA
	"RGBA"
  eTextureDataFormatTypeLA
	"LA"
  
\endverbatim
*/
class PLMXML60_API eTextureDataFormatType : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eTextureDataFormatType( const char* Type );
     
	//! Constructor
	eTextureDataFormatType( const plmxml_api::String& Type );
     
	//! Default Constructor
	eTextureDataFormatType( );
     
	//! Destructor 
	virtual ~eTextureDataFormatType( );
     
	//! Assign from 'Type'
	const eTextureDataFormatType& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eTextureDataFormatType& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare TextureDataFormatType
	friend plmxml_api::logical PLMXML60_API operator==( const eTextureDataFormatType& e1, const eTextureDataFormatType& e2 );
     
	//! Compare TextureDataFormatType
	friend plmxml_api::logical PLMXML60_API operator!=( const eTextureDataFormatType& e1, const eTextureDataFormatType& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumTextureDataFormatType;
extern PLMXML60_API eTextureDataFormatType eTextureDataFormatTypeUnset;
extern PLMXML60_API eTextureDataFormatType eTextureDataFormatTypeA;
extern PLMXML60_API eTextureDataFormatType eTextureDataFormatTypeL;
extern PLMXML60_API eTextureDataFormatType eTextureDataFormatTypeRGB;
extern PLMXML60_API eTextureDataFormatType eTextureDataFormatTypeRGBA;
extern PLMXML60_API eTextureDataFormatType eTextureDataFormatTypeLA;

////////////////////////////////////////////////////////////////////////////////////
//! eCoordinateSystemStyleEnum class
/*!
Allowed Values:
\verbatim
  eCoordinateSystemStyleEnumCylindrical
	"cylindrical"
  eCoordinateSystemStyleEnumCartesian
	"cartesian"
  eCoordinateSystemStyleEnumSpherical
	"spherical"
  
\endverbatim
*/
class PLMXML60_API eCoordinateSystemStyleEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eCoordinateSystemStyleEnum( const char* Type );
     
	//! Constructor
	eCoordinateSystemStyleEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	eCoordinateSystemStyleEnum( );
     
	//! Destructor 
	virtual ~eCoordinateSystemStyleEnum( );
     
	//! Assign from 'Type'
	const eCoordinateSystemStyleEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eCoordinateSystemStyleEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare CoordinateSystemStyleEnum
	friend plmxml_api::logical PLMXML60_API operator==( const eCoordinateSystemStyleEnum& e1, const eCoordinateSystemStyleEnum& e2 );
     
	//! Compare CoordinateSystemStyleEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const eCoordinateSystemStyleEnum& e1, const eCoordinateSystemStyleEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumCoordinateSystemStyleEnum;
extern PLMXML60_API eCoordinateSystemStyleEnum eCoordinateSystemStyleEnumUnset;
extern PLMXML60_API eCoordinateSystemStyleEnum eCoordinateSystemStyleEnumCylindrical;
extern PLMXML60_API eCoordinateSystemStyleEnum eCoordinateSystemStyleEnumCartesian;
extern PLMXML60_API eCoordinateSystemStyleEnum eCoordinateSystemStyleEnumSpherical;

////////////////////////////////////////////////////////////////////////////////////
//! ePropertyOverrideEnum class
/*!
Allowed Values:
\verbatim
  ePropertyOverrideEnumDefault
	"default"
  ePropertyOverrideEnumFinal
	"final"
  ePropertyOverrideEnumInhibit
	"inhibit"
  
\endverbatim
*/
class PLMXML60_API ePropertyOverrideEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	ePropertyOverrideEnum( const char* Type );
     
	//! Constructor
	ePropertyOverrideEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	ePropertyOverrideEnum( );
     
	//! Destructor 
	virtual ~ePropertyOverrideEnum( );
     
	//! Assign from 'Type'
	const ePropertyOverrideEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const ePropertyOverrideEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare PropertyOverrideEnum
	friend plmxml_api::logical PLMXML60_API operator==( const ePropertyOverrideEnum& e1, const ePropertyOverrideEnum& e2 );
     
	//! Compare PropertyOverrideEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const ePropertyOverrideEnum& e1, const ePropertyOverrideEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumPropertyOverrideEnum;
extern PLMXML60_API ePropertyOverrideEnum ePropertyOverrideEnumUnset;
extern PLMXML60_API ePropertyOverrideEnum ePropertyOverrideEnumDefault;
extern PLMXML60_API ePropertyOverrideEnum ePropertyOverrideEnumFinal;
extern PLMXML60_API ePropertyOverrideEnum ePropertyOverrideEnumInhibit;

////////////////////////////////////////////////////////////////////////////////////
//! eRepresentationFormatType class
/*!
Allowed Values:
\verbatim
  eRepresentationFormatTypeVRML
	"VRML"
  eRepresentationFormatTypeUGPrt
	"UGPrt"
  eRepresentationFormatTypeSWPrt
	"SWPrt"
  eRepresentationFormatTypeProE
	"ProE"
  eRepresentationFormatTypeVSTX
	"VSTX"
  eRepresentationFormatTypeEXT
	"eXT"
  eRepresentationFormatTypeIdeasIDI
	"IdeasIDI"
  eRepresentationFormatTypePLMXML
	"PLMXML"
  eRepresentationFormatTypeJPEG
	"JPEG"
  eRepresentationFormatTypeVSSX
	"VSSX"
  eRepresentationFormatTypeDWG
	"DWG"
  eRepresentationFormatTypeXGL
	"XGL"
  eRepresentationFormatTypeCat4Prt
	"Cat4Prt"
  eRepresentationFormatTypeCat5Prt
	"Cat5Prt"
  eRepresentationFormatTypeDWF
	"DWF"
  eRepresentationFormatTypeSTL
	"STL"
  eRepresentationFormatTypeSEAsm
	"SEAsm"
  eRepresentationFormatTypeVDX
	"VDX"
  eRepresentationFormatTypeVSX
	"VSX"
  eRepresentationFormatTypeJXT
	"jXT"
  eRepresentationFormatTypeTX
	"TX"
  eRepresentationFormatTypeIdeasPrt
	"IdeasPrt"
  eRepresentationFormatTypeCGR
	"CGR"
  eRepresentationFormatTypeUGBkm
	"UGBkm"
  eRepresentationFormatTypeUnregistered
	"Unregistered"
  eRepresentationFormatTypeCGM
	"CGM"
  eRepresentationFormatTypeXT
	"XT"
  eRepresentationFormatTypeIdeasAsm
	"IdeasAsm"
  eRepresentationFormatTypeSTEP
	"STEP"
  eRepresentationFormatTypeJT
	"JT"
  eRepresentationFormatTypeIGES
	"IGES"
  eRepresentationFormatTypeSAT
	"SAT"
  eRepresentationFormatTypeVTX
	"VTX"
  eRepresentationFormatTypeCat5Asm
	"Cat5Asm"
  eRepresentationFormatTypeDXF
	"DXF"
  eRepresentationFormatTypeSEPrt
	"SEPrt"
  eRepresentationFormatTypeIDI
	"IDI"
  eRepresentationFormatTypeSWAsm
	"SWAsm"
  eRepresentationFormatTypeVSDX
	"VSDX"
  eRepresentationFormatTypeXPK
	"XPK"
  
\endverbatim
*/
class PLMXML60_API eRepresentationFormatType : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eRepresentationFormatType( const char* Type );
     
	//! Constructor
	eRepresentationFormatType( const plmxml_api::String& Type );
     
	//! Default Constructor
	eRepresentationFormatType( );
     
	//! Destructor 
	virtual ~eRepresentationFormatType( );
     
	//! Assign from 'Type'
	const eRepresentationFormatType& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eRepresentationFormatType& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare RepresentationFormatType
	friend plmxml_api::logical PLMXML60_API operator==( const eRepresentationFormatType& e1, const eRepresentationFormatType& e2 );
     
	//! Compare RepresentationFormatType
	friend plmxml_api::logical PLMXML60_API operator!=( const eRepresentationFormatType& e1, const eRepresentationFormatType& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumRepresentationFormatType;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeUnset;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeVRML;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeUGPrt;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeSWPrt;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeProE;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeVSTX;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeEXT;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeIdeasIDI;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypePLMXML;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeJPEG;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeVSSX;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeDWG;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeXGL;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeCat4Prt;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeCat5Prt;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeDWF;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeSTL;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeSEAsm;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeVDX;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeVSX;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeJXT;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeTX;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeIdeasPrt;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeCGR;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeUGBkm;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeUnregistered;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeCGM;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeXT;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeIdeasAsm;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeSTEP;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeJT;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeIGES;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeSAT;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeVTX;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeCat5Asm;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeDXF;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeSEPrt;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeIDI;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeSWAsm;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeVSDX;
extern PLMXML60_API eRepresentationFormatType eRepresentationFormatTypeXPK;

////////////////////////////////////////////////////////////////////////////////////
//! eSurfacingEnum class
/*!
Allowed Values:
\verbatim
  eSurfacingEnumBuildup
	"buildup"
  eSurfacingEnumButtering
	"buttering"
  eSurfacingEnumCladding
	"cladding"
  eSurfacingEnumHardfacing
	"hardfacing"
  
\endverbatim
*/
class PLMXML60_API eSurfacingEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eSurfacingEnum( const char* Type );
     
	//! Constructor
	eSurfacingEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	eSurfacingEnum( );
     
	//! Destructor 
	virtual ~eSurfacingEnum( );
     
	//! Assign from 'Type'
	const eSurfacingEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eSurfacingEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare SurfacingEnum
	friend plmxml_api::logical PLMXML60_API operator==( const eSurfacingEnum& e1, const eSurfacingEnum& e2 );
     
	//! Compare SurfacingEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const eSurfacingEnum& e1, const eSurfacingEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumSurfacingEnum;
extern PLMXML60_API eSurfacingEnum eSurfacingEnumUnset;
extern PLMXML60_API eSurfacingEnum eSurfacingEnumBuildup;
extern PLMXML60_API eSurfacingEnum eSurfacingEnumButtering;
extern PLMXML60_API eSurfacingEnum eSurfacingEnumCladding;
extern PLMXML60_API eSurfacingEnum eSurfacingEnumHardfacing;

////////////////////////////////////////////////////////////////////////////////////
//! ePolyTriangleEnum class
/*!
Allowed Values:
\verbatim
  ePolyTriangleEnumTriangle
	"triangle"
  ePolyTriangleEnumFan
	"fan"
  ePolyTriangleEnumStrip
	"strip"
  
\endverbatim
*/
class PLMXML60_API ePolyTriangleEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	ePolyTriangleEnum( const char* Type );
     
	//! Constructor
	ePolyTriangleEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	ePolyTriangleEnum( );
     
	//! Destructor 
	virtual ~ePolyTriangleEnum( );
     
	//! Assign from 'Type'
	const ePolyTriangleEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const ePolyTriangleEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare PolyTriangleEnum
	friend plmxml_api::logical PLMXML60_API operator==( const ePolyTriangleEnum& e1, const ePolyTriangleEnum& e2 );
     
	//! Compare PolyTriangleEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const ePolyTriangleEnum& e1, const ePolyTriangleEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumPolyTriangleEnum;
extern PLMXML60_API ePolyTriangleEnum ePolyTriangleEnumUnset;
extern PLMXML60_API ePolyTriangleEnum ePolyTriangleEnumTriangle;
extern PLMXML60_API ePolyTriangleEnum ePolyTriangleEnumFan;
extern PLMXML60_API ePolyTriangleEnum ePolyTriangleEnumStrip;

////////////////////////////////////////////////////////////////////////////////////
//! eMeasureEnum class
/*!
Allowed Values:
\verbatim
  eMeasureEnumTemperature
	"temperature"
  eMeasureEnumConvectionCoefficient
	"convectionCoefficient"
  eMeasureEnumForcePerUnitLength
	"forcePerUnitLength"
  eMeasureEnumPressure
	"pressure"
  eMeasureEnumThermalEnergyPerArea
	"thermalEnergyPerArea"
  eMeasureEnumHeatFlux
	"heatFlux"
  eMeasureEnumStress
	"stress"
  eMeasureEnumMomentOfInertiaArea
	"momentOfInertiaArea"
  eMeasureEnumMassFlowRate
	"massFlowRate"
  eMeasureEnumHeatGeneration
	"heatGeneration"
  eMeasureEnumThermalExpansionCoefficient
	"thermalExpansionCoefficient"
  eMeasureEnumViscousDamping
	"viscousDamping"
  eMeasureEnumFatigueStrengthCoefficient
	"fatigueStrengthCoefficient"
  eMeasureEnumMassFlux
	"massFlux"
  eMeasureEnumThermalConductance
	"thermalConductance"
  eMeasureEnumElectricalResistance
	"electricalResistance"
  eMeasureEnumMassPerUnitArea
	"massPerUnitArea"
  eMeasureEnumMassDensity
	"massDensity"
  eMeasureEnumMassLength
	"massLength"
  eMeasureEnumAngularJerk
	"angularJerk"
  eMeasureEnumThermalPIDIntegralTermConstant
	"thermalPIDIntegralTermConstant"
  eMeasureEnumDynamicViscosity
	"dynamicViscosity"
  eMeasureEnumVolume
	"volume"
  eMeasureEnumArea
	"area"
  eMeasureEnumThermalResistance
	"thermalResistance"
  eMeasureEnumPressurePerUnitVelocity
	"pressurePerUnitVelocity"
  eMeasureEnumHeadLossCoefficient
	"headLossCoefficient"
  eMeasureEnumFrequency
	"frequency"
  eMeasureEnumLengthPerUnitPressure
	"lengthPerUnitPressure"
  eMeasureEnumDissipationRateOfEnergyPerUnitMass
	"dissipationRateOfEnergyPerUnitMass"
  eMeasureEnumPerVolume
	"perVolume"
  eMeasureEnumVoltagePerAngularVelocity
	"voltagePerAngularVelocity"
  eMeasureEnumLength
	"length"
  eMeasureEnumTsaiWuCoefficient
	"tsaiWuCoefficient"
  eMeasureEnumPerArea
	"perArea"
  eMeasureEnumMoment
	"moment"
  eMeasureEnumStrainEnergyDensity
	"strainEnergyDensity"
  eMeasureEnumEnergy
	"energy"
  eMeasureEnumTemperatureChangeRate
	"temperatureChangeRate"
  eMeasureEnumAcceleration
	"acceleration"
  eMeasureEnumThermalPIDGain
	"thermalPIDGain"
  eMeasureEnumAngularMomentumPerUnitAngle
	"angularMomentumPerUnitAngle"
  eMeasureEnumConductancePerUnitLength
	"conductancePerUnitLength"
  eMeasureEnumMomentum
	"momentum"
  eMeasureEnumLatentHeatPerMass
	"latentHeatPerMass"
  eMeasureEnumMagneticFluxDensity
	"magneticFluxDensity"
  eMeasureEnumVolumeFlowRate
	"volumeFlowRate"
  eMeasureEnumEnergyPerUnitMass
	"energyPerUnitMass"
  eMeasureEnumMassMomentOfInertia
	"massMomentOfInertia"
  eMeasureEnumElectricCurrent
	"electricCurrent"
  eMeasureEnumVoltagePerTemperature
	"voltagePerTemperature"
  eMeasureEnumTemperatureGradient
	"temperatureGradient"
  eMeasureEnumThermalEnergy
	"thermalEnergy"
  eMeasureEnumVelocity
	"velocity"
  eMeasureEnumElectricalConductance
	"electricalConductance"
  eMeasureEnumFatigueLife
	"fatigueLife"
  eMeasureEnumAngularAcceleration
	"angularAcceleration"
  eMeasureEnumPressurePerUnitLength
	"pressurePerUnitLength"
  eMeasureEnumMass
	"mass"
  eMeasureEnumVoltage
	"voltage"
  eMeasureEnumMassPerUnitLength
	"massPerUnitLength"
  eMeasureEnumAngularVelocity
	"angularVelocity"
  eMeasureEnumTemperatureDifference
	"temperatureDifference"
  eMeasureEnumThermalConductivity
	"thermalConductivity"
  eMeasureEnumPower
	"power"
  eMeasureEnumTime
	"time"
  eMeasureEnumWarpingConstant
	"warpingConstant"
  eMeasureEnumStrainEnergy
	"strainEnergy"
  eMeasureEnumInductance
	"inductance"
  eMeasureEnumForce
	"force"
  eMeasureEnumHeatFlowRate
	"heatFlowRate"
  eMeasureEnumJerk
	"jerk"
  eMeasureEnumStressCompliance
	"stressCompliance"
  eMeasureEnumSpecificHeat
	"specificHeat"
  eMeasureEnumStrain
	"strain"
  eMeasureEnumCoefficientPerUnitTime
	"coefficientPerUnitTime"
  eMeasureEnumMagneticFieldStrength
	"magneticFieldStrength"
  eMeasureEnumMomentPerAngle
	"momentPerAngle"
  eMeasureEnumElectricalResistivity
	"electricalResistivity"
  eMeasureEnumThermalCapacitance
	"thermalCapacitance"
  eMeasureEnumAngle
	"angle"
  eMeasureEnumCoefficientPerUnitLength
	"coefficientPerUnitLength"
  eMeasureEnumDiffusivity
	"diffusivity"
  eMeasureEnumThermalPIDDerivativeTermConstant
	"thermalPIDDerivativeTermConstant"
  
\endverbatim
*/
class PLMXML60_API eMeasureEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eMeasureEnum( const char* Type );
     
	//! Constructor
	eMeasureEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	eMeasureEnum( );
     
	//! Destructor 
	virtual ~eMeasureEnum( );
     
	//! Assign from 'Type'
	const eMeasureEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eMeasureEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare MeasureEnum
	friend plmxml_api::logical PLMXML60_API operator==( const eMeasureEnum& e1, const eMeasureEnum& e2 );
     
	//! Compare MeasureEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const eMeasureEnum& e1, const eMeasureEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumMeasureEnum;
extern PLMXML60_API eMeasureEnum eMeasureEnumUnset;
extern PLMXML60_API eMeasureEnum eMeasureEnumTemperature;
extern PLMXML60_API eMeasureEnum eMeasureEnumConvectionCoefficient;
extern PLMXML60_API eMeasureEnum eMeasureEnumForcePerUnitLength;
extern PLMXML60_API eMeasureEnum eMeasureEnumPressure;
extern PLMXML60_API eMeasureEnum eMeasureEnumThermalEnergyPerArea;
extern PLMXML60_API eMeasureEnum eMeasureEnumHeatFlux;
extern PLMXML60_API eMeasureEnum eMeasureEnumStress;
extern PLMXML60_API eMeasureEnum eMeasureEnumMomentOfInertiaArea;
extern PLMXML60_API eMeasureEnum eMeasureEnumMassFlowRate;
extern PLMXML60_API eMeasureEnum eMeasureEnumHeatGeneration;
extern PLMXML60_API eMeasureEnum eMeasureEnumThermalExpansionCoefficient;
extern PLMXML60_API eMeasureEnum eMeasureEnumViscousDamping;
extern PLMXML60_API eMeasureEnum eMeasureEnumFatigueStrengthCoefficient;
extern PLMXML60_API eMeasureEnum eMeasureEnumMassFlux;
extern PLMXML60_API eMeasureEnum eMeasureEnumThermalConductance;
extern PLMXML60_API eMeasureEnum eMeasureEnumElectricalResistance;
extern PLMXML60_API eMeasureEnum eMeasureEnumMassPerUnitArea;
extern PLMXML60_API eMeasureEnum eMeasureEnumMassDensity;
extern PLMXML60_API eMeasureEnum eMeasureEnumMassLength;
extern PLMXML60_API eMeasureEnum eMeasureEnumAngularJerk;
extern PLMXML60_API eMeasureEnum eMeasureEnumThermalPIDIntegralTermConstant;
extern PLMXML60_API eMeasureEnum eMeasureEnumDynamicViscosity;
extern PLMXML60_API eMeasureEnum eMeasureEnumVolume;
extern PLMXML60_API eMeasureEnum eMeasureEnumArea;
extern PLMXML60_API eMeasureEnum eMeasureEnumThermalResistance;
extern PLMXML60_API eMeasureEnum eMeasureEnumPressurePerUnitVelocity;
extern PLMXML60_API eMeasureEnum eMeasureEnumHeadLossCoefficient;
extern PLMXML60_API eMeasureEnum eMeasureEnumFrequency;
extern PLMXML60_API eMeasureEnum eMeasureEnumLengthPerUnitPressure;
extern PLMXML60_API eMeasureEnum eMeasureEnumDissipationRateOfEnergyPerUnitMass;
extern PLMXML60_API eMeasureEnum eMeasureEnumPerVolume;
extern PLMXML60_API eMeasureEnum eMeasureEnumVoltagePerAngularVelocity;
extern PLMXML60_API eMeasureEnum eMeasureEnumLength;
extern PLMXML60_API eMeasureEnum eMeasureEnumTsaiWuCoefficient;
extern PLMXML60_API eMeasureEnum eMeasureEnumPerArea;
extern PLMXML60_API eMeasureEnum eMeasureEnumMoment;
extern PLMXML60_API eMeasureEnum eMeasureEnumStrainEnergyDensity;
extern PLMXML60_API eMeasureEnum eMeasureEnumEnergy;
extern PLMXML60_API eMeasureEnum eMeasureEnumTemperatureChangeRate;
extern PLMXML60_API eMeasureEnum eMeasureEnumAcceleration;
extern PLMXML60_API eMeasureEnum eMeasureEnumThermalPIDGain;
extern PLMXML60_API eMeasureEnum eMeasureEnumAngularMomentumPerUnitAngle;
extern PLMXML60_API eMeasureEnum eMeasureEnumConductancePerUnitLength;
extern PLMXML60_API eMeasureEnum eMeasureEnumMomentum;
extern PLMXML60_API eMeasureEnum eMeasureEnumLatentHeatPerMass;
extern PLMXML60_API eMeasureEnum eMeasureEnumMagneticFluxDensity;
extern PLMXML60_API eMeasureEnum eMeasureEnumVolumeFlowRate;
extern PLMXML60_API eMeasureEnum eMeasureEnumEnergyPerUnitMass;
extern PLMXML60_API eMeasureEnum eMeasureEnumMassMomentOfInertia;
extern PLMXML60_API eMeasureEnum eMeasureEnumElectricCurrent;
extern PLMXML60_API eMeasureEnum eMeasureEnumVoltagePerTemperature;
extern PLMXML60_API eMeasureEnum eMeasureEnumTemperatureGradient;
extern PLMXML60_API eMeasureEnum eMeasureEnumThermalEnergy;
extern PLMXML60_API eMeasureEnum eMeasureEnumVelocity;
extern PLMXML60_API eMeasureEnum eMeasureEnumElectricalConductance;
extern PLMXML60_API eMeasureEnum eMeasureEnumFatigueLife;
extern PLMXML60_API eMeasureEnum eMeasureEnumAngularAcceleration;
extern PLMXML60_API eMeasureEnum eMeasureEnumPressurePerUnitLength;
extern PLMXML60_API eMeasureEnum eMeasureEnumMass;
extern PLMXML60_API eMeasureEnum eMeasureEnumVoltage;
extern PLMXML60_API eMeasureEnum eMeasureEnumMassPerUnitLength;
extern PLMXML60_API eMeasureEnum eMeasureEnumAngularVelocity;
extern PLMXML60_API eMeasureEnum eMeasureEnumTemperatureDifference;
extern PLMXML60_API eMeasureEnum eMeasureEnumThermalConductivity;
extern PLMXML60_API eMeasureEnum eMeasureEnumPower;
extern PLMXML60_API eMeasureEnum eMeasureEnumTime;
extern PLMXML60_API eMeasureEnum eMeasureEnumWarpingConstant;
extern PLMXML60_API eMeasureEnum eMeasureEnumStrainEnergy;
extern PLMXML60_API eMeasureEnum eMeasureEnumInductance;
extern PLMXML60_API eMeasureEnum eMeasureEnumForce;
extern PLMXML60_API eMeasureEnum eMeasureEnumHeatFlowRate;
extern PLMXML60_API eMeasureEnum eMeasureEnumJerk;
extern PLMXML60_API eMeasureEnum eMeasureEnumStressCompliance;
extern PLMXML60_API eMeasureEnum eMeasureEnumSpecificHeat;
extern PLMXML60_API eMeasureEnum eMeasureEnumStrain;
extern PLMXML60_API eMeasureEnum eMeasureEnumCoefficientPerUnitTime;
extern PLMXML60_API eMeasureEnum eMeasureEnumMagneticFieldStrength;
extern PLMXML60_API eMeasureEnum eMeasureEnumMomentPerAngle;
extern PLMXML60_API eMeasureEnum eMeasureEnumElectricalResistivity;
extern PLMXML60_API eMeasureEnum eMeasureEnumThermalCapacitance;
extern PLMXML60_API eMeasureEnum eMeasureEnumAngle;
extern PLMXML60_API eMeasureEnum eMeasureEnumCoefficientPerUnitLength;
extern PLMXML60_API eMeasureEnum eMeasureEnumDiffusivity;
extern PLMXML60_API eMeasureEnum eMeasureEnumThermalPIDDerivativeTermConstant;

////////////////////////////////////////////////////////////////////////////////////
//! eOrganisationRoleEnum class
/*!
Allowed Values:
\verbatim
  eOrganisationRoleEnumSupplier
	"supplier"
  eOrganisationRoleEnumDistributor
	"distributor"
  eOrganisationRoleEnumManufacturer
	"manufacturer"
  
\endverbatim
*/
class PLMXML60_API eOrganisationRoleEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eOrganisationRoleEnum( const char* Type );
     
	//! Constructor
	eOrganisationRoleEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	eOrganisationRoleEnum( );
     
	//! Destructor 
	virtual ~eOrganisationRoleEnum( );
     
	//! Assign from 'Type'
	const eOrganisationRoleEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eOrganisationRoleEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare OrganisationRoleEnum
	friend plmxml_api::logical PLMXML60_API operator==( const eOrganisationRoleEnum& e1, const eOrganisationRoleEnum& e2 );
     
	//! Compare OrganisationRoleEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const eOrganisationRoleEnum& e1, const eOrganisationRoleEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumOrganisationRoleEnum;
extern PLMXML60_API eOrganisationRoleEnum eOrganisationRoleEnumUnset;
extern PLMXML60_API eOrganisationRoleEnum eOrganisationRoleEnumSupplier;
extern PLMXML60_API eOrganisationRoleEnum eOrganisationRoleEnumDistributor;
extern PLMXML60_API eOrganisationRoleEnum eOrganisationRoleEnumManufacturer;

////////////////////////////////////////////////////////////////////////////////////
//! eTextureSampleType class
/*!
Allowed Values:
\verbatim
  eTextureSampleTypeNearest
	"nearest"
  eTextureSampleTypeLinear
	"linear"
  
\endverbatim
*/
class PLMXML60_API eTextureSampleType : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eTextureSampleType( const char* Type );
     
	//! Constructor
	eTextureSampleType( const plmxml_api::String& Type );
     
	//! Default Constructor
	eTextureSampleType( );
     
	//! Destructor 
	virtual ~eTextureSampleType( );
     
	//! Assign from 'Type'
	const eTextureSampleType& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eTextureSampleType& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare TextureSampleType
	friend plmxml_api::logical PLMXML60_API operator==( const eTextureSampleType& e1, const eTextureSampleType& e2 );
     
	//! Compare TextureSampleType
	friend plmxml_api::logical PLMXML60_API operator!=( const eTextureSampleType& e1, const eTextureSampleType& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumTextureSampleType;
extern PLMXML60_API eTextureSampleType eTextureSampleTypeUnset;
extern PLMXML60_API eTextureSampleType eTextureSampleTypeNearest;
extern PLMXML60_API eTextureSampleType eTextureSampleTypeLinear;

////////////////////////////////////////////////////////////////////////////////////
//! eGeometryPurposeEnum class
/*!
Allowed Values:
\verbatim
  eGeometryPurposeEnumText
	"text"
  eGeometryPurposeEnumFrame
	"frame"
  eGeometryPurposeEnumLeader
	"leader"
  eGeometryPurposeEnumOutline
	"outline"
  
\endverbatim
*/
class PLMXML60_API eGeometryPurposeEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eGeometryPurposeEnum( const char* Type );
     
	//! Constructor
	eGeometryPurposeEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	eGeometryPurposeEnum( );
     
	//! Destructor 
	virtual ~eGeometryPurposeEnum( );
     
	//! Assign from 'Type'
	const eGeometryPurposeEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eGeometryPurposeEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare GeometryPurposeEnum
	friend plmxml_api::logical PLMXML60_API operator==( const eGeometryPurposeEnum& e1, const eGeometryPurposeEnum& e2 );
     
	//! Compare GeometryPurposeEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const eGeometryPurposeEnum& e1, const eGeometryPurposeEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumGeometryPurposeEnum;
extern PLMXML60_API eGeometryPurposeEnum eGeometryPurposeEnumUnset;
extern PLMXML60_API eGeometryPurposeEnum eGeometryPurposeEnumText;
extern PLMXML60_API eGeometryPurposeEnum eGeometryPurposeEnumFrame;
extern PLMXML60_API eGeometryPurposeEnum eGeometryPurposeEnumLeader;
extern PLMXML60_API eGeometryPurposeEnum eGeometryPurposeEnumOutline;

////////////////////////////////////////////////////////////////////////////////////
//! eBoundingType class
/*!
Allowed Values:
\verbatim
  eBoundingTypeBox
	"box"
  eBoundingTypeCompound
	"compound"
  eBoundingTypeSphere
	"sphere"
  
\endverbatim
*/
class PLMXML60_API eBoundingType : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eBoundingType( const char* Type );
     
	//! Constructor
	eBoundingType( const plmxml_api::String& Type );
     
	//! Default Constructor
	eBoundingType( );
     
	//! Destructor 
	virtual ~eBoundingType( );
     
	//! Assign from 'Type'
	const eBoundingType& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eBoundingType& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare BoundingType
	friend plmxml_api::logical PLMXML60_API operator==( const eBoundingType& e1, const eBoundingType& e2 );
     
	//! Compare BoundingType
	friend plmxml_api::logical PLMXML60_API operator!=( const eBoundingType& e1, const eBoundingType& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumBoundingType;
extern PLMXML60_API eBoundingType eBoundingTypeUnset;
extern PLMXML60_API eBoundingType eBoundingTypeBox;
extern PLMXML60_API eBoundingType eBoundingTypeCompound;
extern PLMXML60_API eBoundingType eBoundingTypeSphere;

////////////////////////////////////////////////////////////////////////////////////
//! eValidationOriginEnum class
/*!
Allowed Values:
\verbatim
  eValidationOriginEnumAssociated
	"associated"
  eValidationOriginEnumAttached
	"attached"
  
\endverbatim
*/
class PLMXML60_API eValidationOriginEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eValidationOriginEnum( const char* Type );
     
	//! Constructor
	eValidationOriginEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	eValidationOriginEnum( );
     
	//! Destructor 
	virtual ~eValidationOriginEnum( );
     
	//! Assign from 'Type'
	const eValidationOriginEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eValidationOriginEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare ValidationOriginEnum
	friend plmxml_api::logical PLMXML60_API operator==( const eValidationOriginEnum& e1, const eValidationOriginEnum& e2 );
     
	//! Compare ValidationOriginEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const eValidationOriginEnum& e1, const eValidationOriginEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumValidationOriginEnum;
extern PLMXML60_API eValidationOriginEnum eValidationOriginEnumUnset;
extern PLMXML60_API eValidationOriginEnum eValidationOriginEnumAssociated;
extern PLMXML60_API eValidationOriginEnum eValidationOriginEnumAttached;

////////////////////////////////////////////////////////////////////////////////////
//! eLocatorRefFormatType class
/*!
Allowed Values:
\verbatim
  eLocatorRefFormatTypeUnregistered
	"Unregistered"
  eLocatorRefFormatTypePLMXMLPointer
	"PLMXMLPointer"
  
\endverbatim
*/
class PLMXML60_API eLocatorRefFormatType : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eLocatorRefFormatType( const char* Type );
     
	//! Constructor
	eLocatorRefFormatType( const plmxml_api::String& Type );
     
	//! Default Constructor
	eLocatorRefFormatType( );
     
	//! Destructor 
	virtual ~eLocatorRefFormatType( );
     
	//! Assign from 'Type'
	const eLocatorRefFormatType& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eLocatorRefFormatType& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare LocatorRefFormatType
	friend plmxml_api::logical PLMXML60_API operator==( const eLocatorRefFormatType& e1, const eLocatorRefFormatType& e2 );
     
	//! Compare LocatorRefFormatType
	friend plmxml_api::logical PLMXML60_API operator!=( const eLocatorRefFormatType& e1, const eLocatorRefFormatType& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumLocatorRefFormatType;
extern PLMXML60_API eLocatorRefFormatType eLocatorRefFormatTypeUnset;
extern PLMXML60_API eLocatorRefFormatType eLocatorRefFormatTypeUnregistered;
extern PLMXML60_API eLocatorRefFormatType eLocatorRefFormatTypePLMXMLPointer;

////////////////////////////////////////////////////////////////////////////////////
//! eRepresentationTypeEnum class
/*!
Allowed Values:
\verbatim
  eRepresentationTypeEnumDefault
	"default"
  eRepresentationTypeEnumSimplified
	"simplified"
  eRepresentationTypeEnumUser
	"user"
  eRepresentationTypeEnumFlat
	"flat"
  
\endverbatim
*/
class PLMXML60_API eRepresentationTypeEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eRepresentationTypeEnum( const char* Type );
     
	//! Constructor
	eRepresentationTypeEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	eRepresentationTypeEnum( );
     
	//! Destructor 
	virtual ~eRepresentationTypeEnum( );
     
	//! Assign from 'Type'
	const eRepresentationTypeEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eRepresentationTypeEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare RepresentationTypeEnum
	friend plmxml_api::logical PLMXML60_API operator==( const eRepresentationTypeEnum& e1, const eRepresentationTypeEnum& e2 );
     
	//! Compare RepresentationTypeEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const eRepresentationTypeEnum& e1, const eRepresentationTypeEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumRepresentationTypeEnum;
extern PLMXML60_API eRepresentationTypeEnum eRepresentationTypeEnumUnset;
extern PLMXML60_API eRepresentationTypeEnum eRepresentationTypeEnumDefault;
extern PLMXML60_API eRepresentationTypeEnum eRepresentationTypeEnumSimplified;
extern PLMXML60_API eRepresentationTypeEnum eRepresentationTypeEnumUser;
extern PLMXML60_API eRepresentationTypeEnum eRepresentationTypeEnumFlat;

////////////////////////////////////////////////////////////////////////////////////
//! eOccurrenceControlEnum class
/*!
Allowed Values:
\verbatim
  eOccurrenceControlEnumExplicit
	"explicit"
  eOccurrenceControlEnumMixed
	"mixed"
  eOccurrenceControlEnumImplicit
	"implicit"
  
\endverbatim
*/
class PLMXML60_API eOccurrenceControlEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eOccurrenceControlEnum( const char* Type );
     
	//! Constructor
	eOccurrenceControlEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	eOccurrenceControlEnum( );
     
	//! Destructor 
	virtual ~eOccurrenceControlEnum( );
     
	//! Assign from 'Type'
	const eOccurrenceControlEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eOccurrenceControlEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare OccurrenceControlEnum
	friend plmxml_api::logical PLMXML60_API operator==( const eOccurrenceControlEnum& e1, const eOccurrenceControlEnum& e2 );
     
	//! Compare OccurrenceControlEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const eOccurrenceControlEnum& e1, const eOccurrenceControlEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumOccurrenceControlEnum;
extern PLMXML60_API eOccurrenceControlEnum eOccurrenceControlEnumUnset;
extern PLMXML60_API eOccurrenceControlEnum eOccurrenceControlEnumExplicit;
extern PLMXML60_API eOccurrenceControlEnum eOccurrenceControlEnumMixed;
extern PLMXML60_API eOccurrenceControlEnum eOccurrenceControlEnumImplicit;

////////////////////////////////////////////////////////////////////////////////////
//! eArcWeldJointEnum class
/*!
Allowed Values:
\verbatim
  eArcWeldJointEnumCorner
	"corner"
  eArcWeldJointEnumLap
	"lap"
  eArcWeldJointEnumEdge
	"edge"
  eArcWeldJointEnumButt
	"butt"
  eArcWeldJointEnumTee
	"tee"
  
\endverbatim
*/
class PLMXML60_API eArcWeldJointEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eArcWeldJointEnum( const char* Type );
     
	//! Constructor
	eArcWeldJointEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	eArcWeldJointEnum( );
     
	//! Destructor 
	virtual ~eArcWeldJointEnum( );
     
	//! Assign from 'Type'
	const eArcWeldJointEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eArcWeldJointEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare ArcWeldJointEnum
	friend plmxml_api::logical PLMXML60_API operator==( const eArcWeldJointEnum& e1, const eArcWeldJointEnum& e2 );
     
	//! Compare ArcWeldJointEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const eArcWeldJointEnum& e1, const eArcWeldJointEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumArcWeldJointEnum;
extern PLMXML60_API eArcWeldJointEnum eArcWeldJointEnumUnset;
extern PLMXML60_API eArcWeldJointEnum eArcWeldJointEnumCorner;
extern PLMXML60_API eArcWeldJointEnum eArcWeldJointEnumLap;
extern PLMXML60_API eArcWeldJointEnum eArcWeldJointEnumEdge;
extern PLMXML60_API eArcWeldJointEnum eArcWeldJointEnumButt;
extern PLMXML60_API eArcWeldJointEnum eArcWeldJointEnumTee;

////////////////////////////////////////////////////////////////////////////////////
//! eMappingGeometryEnum class
/*!
Allowed Values:
\verbatim
  eMappingGeometryEnumCylinder
	"cylinder"
  eMappingGeometryEnumPlane
	"plane"
  eMappingGeometryEnumTriPlanar
	"triPlanar"
  eMappingGeometryEnumSphere
	"sphere"
  
\endverbatim
*/
class PLMXML60_API eMappingGeometryEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eMappingGeometryEnum( const char* Type );
     
	//! Constructor
	eMappingGeometryEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	eMappingGeometryEnum( );
     
	//! Destructor 
	virtual ~eMappingGeometryEnum( );
     
	//! Assign from 'Type'
	const eMappingGeometryEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eMappingGeometryEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare MappingGeometryEnum
	friend plmxml_api::logical PLMXML60_API operator==( const eMappingGeometryEnum& e1, const eMappingGeometryEnum& e2 );
     
	//! Compare MappingGeometryEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const eMappingGeometryEnum& e1, const eMappingGeometryEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumMappingGeometryEnum;
extern PLMXML60_API eMappingGeometryEnum eMappingGeometryEnumUnset;
extern PLMXML60_API eMappingGeometryEnum eMappingGeometryEnumCylinder;
extern PLMXML60_API eMappingGeometryEnum eMappingGeometryEnumPlane;
extern PLMXML60_API eMappingGeometryEnum eMappingGeometryEnumTriPlanar;
extern PLMXML60_API eMappingGeometryEnum eMappingGeometryEnumSphere;

////////////////////////////////////////////////////////////////////////////////////
//! eSetFilterOperationEnum class
/*!
Allowed Values:
\verbatim
  eSetFilterOperationEnumIntersect
	"intersect"
  eSetFilterOperationEnumUnite
	"unite"
  eSetFilterOperationEnumExclude
	"exclude"
  
\endverbatim
*/
class PLMXML60_API eSetFilterOperationEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eSetFilterOperationEnum( const char* Type );
     
	//! Constructor
	eSetFilterOperationEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	eSetFilterOperationEnum( );
     
	//! Destructor 
	virtual ~eSetFilterOperationEnum( );
     
	//! Assign from 'Type'
	const eSetFilterOperationEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eSetFilterOperationEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare SetFilterOperationEnum
	friend plmxml_api::logical PLMXML60_API operator==( const eSetFilterOperationEnum& e1, const eSetFilterOperationEnum& e2 );
     
	//! Compare SetFilterOperationEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const eSetFilterOperationEnum& e1, const eSetFilterOperationEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumSetFilterOperationEnum;
extern PLMXML60_API eSetFilterOperationEnum eSetFilterOperationEnumUnset;
extern PLMXML60_API eSetFilterOperationEnum eSetFilterOperationEnumIntersect;
extern PLMXML60_API eSetFilterOperationEnum eSetFilterOperationEnumUnite;
extern PLMXML60_API eSetFilterOperationEnum eSetFilterOperationEnumExclude;

////////////////////////////////////////////////////////////////////////////////////
//! ePointStyleEnum class
/*!
Allowed Values:
\verbatim
  ePointStyleEnumFilledRightTriangleInCircle
	"filledRightTriangleInCircle"
  ePointStyleEnumLargeFilledSquare
	"largeFilledSquare"
  ePointStyleEnumArcEndPoint
	"arcEndPoint"
  ePointStyleEnumFilledDownTriangleInCircle
	"filledDownTriangleInCircle"
  ePointStyleEnumCircle
	"circle"
  ePointStyleEnumHash
	"hash"
  ePointStyleEnumAnchor
	"anchor"
  ePointStyleEnumRoundedCross
	"roundedCross"
  ePointStyleEnumSmallWheel
	"smallWheel"
  ePointStyleEnumSquareInSquare
	"squareInSquare"
  ePointStyleEnumFilledCircle
	"filledCircle"
  ePointStyleEnumInvertedTriangle
	"invertedTriangle"
  ePointStyleEnumPoint
	"point"
  ePointStyleEnumSquare
	"square"
  ePointStyleEnumAsterisk
	"asterisk"
  ePointStyleEnumFilledLeftTriangleInSquare
	"filledLeftTriangleInSquare"
  ePointStyleEnumFilledRightTriangle
	"filledRightTriangle"
  ePointStyleEnumFilledLeftTriangleInCircle
	"filledLeftTriangleInCircle"
  ePointStyleEnumFilledUpTriangleInCircle
	"filledUpTriangleInCircle"
  ePointStyleEnumHollowCircle
	"hollowCircle"
  ePointStyleEnumPlusInCircle
	"plusInCircle"
  ePointStyleEnumLargeWheel
	"largeWheel"
  ePointStyleEnumBigAsterisk
	"bigAsterisk"
  ePointStyleEnumFilledSquare
	"filledSquare"
  ePointStyleEnumFilledUpTriangle
	"filledUpTriangle"
  ePointStyleEnumFilledUpTriangleInSquare
	"filledUpTriangleInSquare"
  ePointStyleEnumPlus
	"plus"
  ePointStyleEnumCircleInSquare
	"circleInSquare"
  ePointStyleEnumTriangle
	"triangle"
  ePointStyleEnumFilledDiamond
	"filledDiamond"
  ePointStyleEnumFilledDownTriangle
	"filledDownTriangle"
  ePointStyleEnumCentreOfRotation
	"centreOfRotation"
  ePointStyleEnumUpDownTriangles
	"upDownTriangles"
  ePointStyleEnumGridPoint
	"gridPoint"
  ePointStyleEnumCross
	"cross"
  ePointStyleEnumLeftRightTriangles
	"leftRightTriangles"
  ePointStyleEnumLineInCircle
	"lineInCircle"
  ePointStyleEnumFilledDownTriangleInSquare
	"filledDownTriangleInSquare"
  ePointStyleEnumDiamond
	"diamond"
  ePointStyleEnumCircleInCircle
	"circleInCircle"
  ePointStyleEnumFilledRightTriangleInSquare
	"filledRightTriangleInSquare"
  ePointStyleEnumFilledLeftTriangle
	"filledLeftTriangle"
  ePointStyleEnumCentreLine
	"centreLine"
  ePointStyleEnumDot
	"dot"
  
\endverbatim
*/
class PLMXML60_API ePointStyleEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	ePointStyleEnum( const char* Type );
     
	//! Constructor
	ePointStyleEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	ePointStyleEnum( );
     
	//! Destructor 
	virtual ~ePointStyleEnum( );
     
	//! Assign from 'Type'
	const ePointStyleEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const ePointStyleEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare PointStyleEnum
	friend plmxml_api::logical PLMXML60_API operator==( const ePointStyleEnum& e1, const ePointStyleEnum& e2 );
     
	//! Compare PointStyleEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const ePointStyleEnum& e1, const ePointStyleEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumPointStyleEnum;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumUnset;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumFilledRightTriangleInCircle;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumLargeFilledSquare;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumArcEndPoint;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumFilledDownTriangleInCircle;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumCircle;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumHash;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumAnchor;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumRoundedCross;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumSmallWheel;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumSquareInSquare;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumFilledCircle;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumInvertedTriangle;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumPoint;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumSquare;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumAsterisk;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumFilledLeftTriangleInSquare;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumFilledRightTriangle;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumFilledLeftTriangleInCircle;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumFilledUpTriangleInCircle;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumHollowCircle;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumPlusInCircle;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumLargeWheel;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumBigAsterisk;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumFilledSquare;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumFilledUpTriangle;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumFilledUpTriangleInSquare;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumPlus;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumCircleInSquare;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumTriangle;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumFilledDiamond;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumFilledDownTriangle;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumCentreOfRotation;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumUpDownTriangles;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumGridPoint;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumCross;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumLeftRightTriangles;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumLineInCircle;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumFilledDownTriangleInSquare;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumDiamond;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumCircleInCircle;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumFilledRightTriangleInSquare;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumFilledLeftTriangle;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumCentreLine;
extern PLMXML60_API ePointStyleEnum ePointStyleEnumDot;

////////////////////////////////////////////////////////////////////////////////////
//! eDesignElementEnum class
/*!
Allowed Values:
\verbatim
  eDesignElementEnumShape
	"shape"
  eDesignElementEnumReuse
	"reuse"
  eDesignElementEnumSubordinate
	"subordinate"
  eDesignElementEnumPromissory
	"promissory"
  
\endverbatim
*/
class PLMXML60_API eDesignElementEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eDesignElementEnum( const char* Type );
     
	//! Constructor
	eDesignElementEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	eDesignElementEnum( );
     
	//! Destructor 
	virtual ~eDesignElementEnum( );
     
	//! Assign from 'Type'
	const eDesignElementEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eDesignElementEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare DesignElementEnum
	friend plmxml_api::logical PLMXML60_API operator==( const eDesignElementEnum& e1, const eDesignElementEnum& e2 );
     
	//! Compare DesignElementEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const eDesignElementEnum& e1, const eDesignElementEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumDesignElementEnum;
extern PLMXML60_API eDesignElementEnum eDesignElementEnumUnset;
extern PLMXML60_API eDesignElementEnum eDesignElementEnumShape;
extern PLMXML60_API eDesignElementEnum eDesignElementEnumReuse;
extern PLMXML60_API eDesignElementEnum eDesignElementEnumSubordinate;
extern PLMXML60_API eDesignElementEnum eDesignElementEnumPromissory;

////////////////////////////////////////////////////////////////////////////////////
//! ePropertyDeterminationEnum class
/*!
Allowed Values:
\verbatim
  ePropertyDeterminationEnumUnknown
	"unknown"
  ePropertyDeterminationEnumAsserted
	"asserted"
  
\endverbatim
*/
class PLMXML60_API ePropertyDeterminationEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	ePropertyDeterminationEnum( const char* Type );
     
	//! Constructor
	ePropertyDeterminationEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	ePropertyDeterminationEnum( );
     
	//! Destructor 
	virtual ~ePropertyDeterminationEnum( );
     
	//! Assign from 'Type'
	const ePropertyDeterminationEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const ePropertyDeterminationEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare PropertyDeterminationEnum
	friend plmxml_api::logical PLMXML60_API operator==( const ePropertyDeterminationEnum& e1, const ePropertyDeterminationEnum& e2 );
     
	//! Compare PropertyDeterminationEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const ePropertyDeterminationEnum& e1, const ePropertyDeterminationEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumPropertyDeterminationEnum;
extern PLMXML60_API ePropertyDeterminationEnum ePropertyDeterminationEnumUnset;
extern PLMXML60_API ePropertyDeterminationEnum ePropertyDeterminationEnumUnknown;
extern PLMXML60_API ePropertyDeterminationEnum ePropertyDeterminationEnumAsserted;

////////////////////////////////////////////////////////////////////////////////////
//! eLoadOptionModeType class
/*!
Allowed Values:
\verbatim
  eLoadOptionModeTypePartial
	"partial"
  eLoadOptionModeTypeFull
	"full"
  eLoadOptionModeTypeMinimal
	"minimal"
  
\endverbatim
*/
class PLMXML60_API eLoadOptionModeType : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eLoadOptionModeType( const char* Type );
     
	//! Constructor
	eLoadOptionModeType( const plmxml_api::String& Type );
     
	//! Default Constructor
	eLoadOptionModeType( );
     
	//! Destructor 
	virtual ~eLoadOptionModeType( );
     
	//! Assign from 'Type'
	const eLoadOptionModeType& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eLoadOptionModeType& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare LoadOptionModeType
	friend plmxml_api::logical PLMXML60_API operator==( const eLoadOptionModeType& e1, const eLoadOptionModeType& e2 );
     
	//! Compare LoadOptionModeType
	friend plmxml_api::logical PLMXML60_API operator!=( const eLoadOptionModeType& e1, const eLoadOptionModeType& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumLoadOptionModeType;
extern PLMXML60_API eLoadOptionModeType eLoadOptionModeTypeUnset;
extern PLMXML60_API eLoadOptionModeType eLoadOptionModeTypePartial;
extern PLMXML60_API eLoadOptionModeType eLoadOptionModeTypeFull;
extern PLMXML60_API eLoadOptionModeType eLoadOptionModeTypeMinimal;

////////////////////////////////////////////////////////////////////////////////////
//! eViewOrientationEnum class
/*!
Allowed Values:
\verbatim
  eViewOrientationEnumLeft
	"left"
  eViewOrientationEnumBottom
	"bottom"
  eViewOrientationEnumBack
	"back"
  eViewOrientationEnumIsometric
	"isometric"
  eViewOrientationEnumFront
	"front"
  eViewOrientationEnumTop
	"top"
  eViewOrientationEnumRight
	"right"
  eViewOrientationEnumTrimetric
	"trimetric"
  eViewOrientationEnumDimetric
	"dimetric"
  
\endverbatim
*/
class PLMXML60_API eViewOrientationEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eViewOrientationEnum( const char* Type );
     
	//! Constructor
	eViewOrientationEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	eViewOrientationEnum( );
     
	//! Destructor 
	virtual ~eViewOrientationEnum( );
     
	//! Assign from 'Type'
	const eViewOrientationEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eViewOrientationEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare ViewOrientationEnum
	friend plmxml_api::logical PLMXML60_API operator==( const eViewOrientationEnum& e1, const eViewOrientationEnum& e2 );
     
	//! Compare ViewOrientationEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const eViewOrientationEnum& e1, const eViewOrientationEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumViewOrientationEnum;
extern PLMXML60_API eViewOrientationEnum eViewOrientationEnumUnset;
extern PLMXML60_API eViewOrientationEnum eViewOrientationEnumLeft;
extern PLMXML60_API eViewOrientationEnum eViewOrientationEnumBottom;
extern PLMXML60_API eViewOrientationEnum eViewOrientationEnumBack;
extern PLMXML60_API eViewOrientationEnum eViewOrientationEnumIsometric;
extern PLMXML60_API eViewOrientationEnum eViewOrientationEnumFront;
extern PLMXML60_API eViewOrientationEnum eViewOrientationEnumTop;
extern PLMXML60_API eViewOrientationEnum eViewOrientationEnumRight;
extern PLMXML60_API eViewOrientationEnum eViewOrientationEnumTrimetric;
extern PLMXML60_API eViewOrientationEnum eViewOrientationEnumDimetric;

////////////////////////////////////////////////////////////////////////////////////
//! eDrawingStyleType class
/*!
Allowed Values:
\verbatim
  eDrawingStyleTypeHiddenMarked
	"hiddenMarked"
  eDrawingStyleTypeHidden
	"hidden"
  eDrawingStyleTypeShadedWithEdges
	"shadedWithEdges"
  eDrawingStyleTypeShaded
	"shaded"
  eDrawingStyleTypeWireframe
	"wireframe"
  
\endverbatim
*/
class PLMXML60_API eDrawingStyleType : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eDrawingStyleType( const char* Type );
     
	//! Constructor
	eDrawingStyleType( const plmxml_api::String& Type );
     
	//! Default Constructor
	eDrawingStyleType( );
     
	//! Destructor 
	virtual ~eDrawingStyleType( );
     
	//! Assign from 'Type'
	const eDrawingStyleType& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eDrawingStyleType& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare DrawingStyleType
	friend plmxml_api::logical PLMXML60_API operator==( const eDrawingStyleType& e1, const eDrawingStyleType& e2 );
     
	//! Compare DrawingStyleType
	friend plmxml_api::logical PLMXML60_API operator!=( const eDrawingStyleType& e1, const eDrawingStyleType& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumDrawingStyleType;
extern PLMXML60_API eDrawingStyleType eDrawingStyleTypeUnset;
extern PLMXML60_API eDrawingStyleType eDrawingStyleTypeHiddenMarked;
extern PLMXML60_API eDrawingStyleType eDrawingStyleTypeHidden;
extern PLMXML60_API eDrawingStyleType eDrawingStyleTypeShadedWithEdges;
extern PLMXML60_API eDrawingStyleType eDrawingStyleTypeShaded;
extern PLMXML60_API eDrawingStyleType eDrawingStyleTypeWireframe;

////////////////////////////////////////////////////////////////////////////////////
//! eUserValueDataType class
/*!
Allowed Values:
\verbatim
  eUserValueDataTypeList
	"list"
  eUserValueDataTypeNone
	"none"
  eUserValueDataTypeString
	"string"
  eUserValueDataTypeDateTime
	"dateTime"
  eUserValueDataTypeBooleans
	"booleans"
  eUserValueDataTypeReference
	"reference"
  eUserValueDataTypeEnum
	"enum"
  eUserValueDataTypeReal
	"real"
  eUserValueDataTypeInt
	"int"
  eUserValueDataTypeBoolean
	"boolean"
  eUserValueDataTypeReals
	"reals"
  eUserValueDataTypeInts
	"ints"
  
\endverbatim
*/
class PLMXML60_API eUserValueDataType : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eUserValueDataType( const char* Type );
     
	//! Constructor
	eUserValueDataType( const plmxml_api::String& Type );
     
	//! Default Constructor
	eUserValueDataType( );
     
	//! Destructor 
	virtual ~eUserValueDataType( );
     
	//! Assign from 'Type'
	const eUserValueDataType& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eUserValueDataType& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare UserValueDataType
	friend plmxml_api::logical PLMXML60_API operator==( const eUserValueDataType& e1, const eUserValueDataType& e2 );
     
	//! Compare UserValueDataType
	friend plmxml_api::logical PLMXML60_API operator!=( const eUserValueDataType& e1, const eUserValueDataType& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumUserValueDataType;
extern PLMXML60_API eUserValueDataType eUserValueDataTypeUnset;
extern PLMXML60_API eUserValueDataType eUserValueDataTypeList;
extern PLMXML60_API eUserValueDataType eUserValueDataTypeNone;
extern PLMXML60_API eUserValueDataType eUserValueDataTypeString;
extern PLMXML60_API eUserValueDataType eUserValueDataTypeDateTime;
extern PLMXML60_API eUserValueDataType eUserValueDataTypeBooleans;
extern PLMXML60_API eUserValueDataType eUserValueDataTypeReference;
extern PLMXML60_API eUserValueDataType eUserValueDataTypeEnum;
extern PLMXML60_API eUserValueDataType eUserValueDataTypeReal;
extern PLMXML60_API eUserValueDataType eUserValueDataTypeInt;
extern PLMXML60_API eUserValueDataType eUserValueDataTypeBoolean;
extern PLMXML60_API eUserValueDataType eUserValueDataTypeReals;
extern PLMXML60_API eUserValueDataType eUserValueDataTypeInts;

////////////////////////////////////////////////////////////////////////////////////
//! eTriStateBooleanEnum class
/*!
Allowed Values:
\verbatim
  eTriStateBooleanEnumTrue
	"true"
  eTriStateBooleanEnumFalse
	"false"
  eTriStateBooleanEnumUnknown
	"unknown"
  
\endverbatim
*/
class PLMXML60_API eTriStateBooleanEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eTriStateBooleanEnum( const char* Type );
     
	//! Constructor
	eTriStateBooleanEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	eTriStateBooleanEnum( );
     
	//! Destructor 
	virtual ~eTriStateBooleanEnum( );
     
	//! Assign from 'Type'
	const eTriStateBooleanEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eTriStateBooleanEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare TriStateBooleanEnum
	friend plmxml_api::logical PLMXML60_API operator==( const eTriStateBooleanEnum& e1, const eTriStateBooleanEnum& e2 );
     
	//! Compare TriStateBooleanEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const eTriStateBooleanEnum& e1, const eTriStateBooleanEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumTriStateBooleanEnum;
extern PLMXML60_API eTriStateBooleanEnum eTriStateBooleanEnumUnset;
extern PLMXML60_API eTriStateBooleanEnum eTriStateBooleanEnumTrue;
extern PLMXML60_API eTriStateBooleanEnum eTriStateBooleanEnumFalse;
extern PLMXML60_API eTriStateBooleanEnum eTriStateBooleanEnumUnknown;

////////////////////////////////////////////////////////////////////////////////////
//! eOptionTypesType class
/*!
Allowed Values:
\verbatim
  eOptionTypesTypeReal
	"real"
  eOptionTypesTypeInt
	"int"
  eOptionTypesTypeString
	"string"
  eOptionTypesTypeEnum
	"enum"
  eOptionTypesTypeLogical
	"logical"
  
\endverbatim
*/
class PLMXML60_API eOptionTypesType : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eOptionTypesType( const char* Type );
     
	//! Constructor
	eOptionTypesType( const plmxml_api::String& Type );
     
	//! Default Constructor
	eOptionTypesType( );
     
	//! Destructor 
	virtual ~eOptionTypesType( );
     
	//! Assign from 'Type'
	const eOptionTypesType& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eOptionTypesType& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare OptionTypesType
	friend plmxml_api::logical PLMXML60_API operator==( const eOptionTypesType& e1, const eOptionTypesType& e2 );
     
	//! Compare OptionTypesType
	friend plmxml_api::logical PLMXML60_API operator!=( const eOptionTypesType& e1, const eOptionTypesType& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumOptionTypesType;
extern PLMXML60_API eOptionTypesType eOptionTypesTypeUnset;
extern PLMXML60_API eOptionTypesType eOptionTypesTypeReal;
extern PLMXML60_API eOptionTypesType eOptionTypesTypeInt;
extern PLMXML60_API eOptionTypesType eOptionTypesTypeString;
extern PLMXML60_API eOptionTypesType eOptionTypesTypeEnum;
extern PLMXML60_API eOptionTypesType eOptionTypesTypeLogical;

////////////////////////////////////////////////////////////////////////////////////
//! ePartType class
/*!
Allowed Values:
\verbatim
  ePartTypeSheet
	"sheet"
  ePartTypeSolid
	"solid"
  ePartTypeMinimal
	"minimal"
  ePartTypeGeneral
	"general"
  ePartTypeWire
	"wire"
  ePartTypeAssembly
	"assembly"
  
\endverbatim
*/
class PLMXML60_API ePartType : public plmxml_api::EnumBase
{

public:

	//! Constructor
	ePartType( const char* Type );
     
	//! Constructor
	ePartType( const plmxml_api::String& Type );
     
	//! Default Constructor
	ePartType( );
     
	//! Destructor 
	virtual ~ePartType( );
     
	//! Assign from 'Type'
	const ePartType& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const ePartType& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare PartType
	friend plmxml_api::logical PLMXML60_API operator==( const ePartType& e1, const ePartType& e2 );
     
	//! Compare PartType
	friend plmxml_api::logical PLMXML60_API operator!=( const ePartType& e1, const ePartType& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumPartType;
extern PLMXML60_API ePartType ePartTypeUnset;
extern PLMXML60_API ePartType ePartTypeSheet;
extern PLMXML60_API ePartType ePartTypeSolid;
extern PLMXML60_API ePartType ePartTypeMinimal;
extern PLMXML60_API ePartType ePartTypeGeneral;
extern PLMXML60_API ePartType ePartTypeWire;
extern PLMXML60_API ePartType ePartTypeAssembly;

////////////////////////////////////////////////////////////////////////////////////
//! eLoadOptionSearchPathsLocationType class
/*!
Allowed Values:
\verbatim
  eLoadOptionSearchPathsLocationTypeSpecified
	"specified"
  eLoadOptionSearchPathsLocationTypeLocal
	"local"
  
\endverbatim
*/
class PLMXML60_API eLoadOptionSearchPathsLocationType : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eLoadOptionSearchPathsLocationType( const char* Type );
     
	//! Constructor
	eLoadOptionSearchPathsLocationType( const plmxml_api::String& Type );
     
	//! Default Constructor
	eLoadOptionSearchPathsLocationType( );
     
	//! Destructor 
	virtual ~eLoadOptionSearchPathsLocationType( );
     
	//! Assign from 'Type'
	const eLoadOptionSearchPathsLocationType& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eLoadOptionSearchPathsLocationType& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare LoadOptionSearchPathsLocationType
	friend plmxml_api::logical PLMXML60_API operator==( const eLoadOptionSearchPathsLocationType& e1, const eLoadOptionSearchPathsLocationType& e2 );
     
	//! Compare LoadOptionSearchPathsLocationType
	friend plmxml_api::logical PLMXML60_API operator!=( const eLoadOptionSearchPathsLocationType& e1, const eLoadOptionSearchPathsLocationType& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumLoadOptionSearchPathsLocationType;
extern PLMXML60_API eLoadOptionSearchPathsLocationType eLoadOptionSearchPathsLocationTypeUnset;
extern PLMXML60_API eLoadOptionSearchPathsLocationType eLoadOptionSearchPathsLocationTypeSpecified;
extern PLMXML60_API eLoadOptionSearchPathsLocationType eLoadOptionSearchPathsLocationTypeLocal;

////////////////////////////////////////////////////////////////////////////////////
//! eSplineCurveFormType class
/*!
Allowed Values:
\verbatim
  eSplineCurveFormTypeGeneral
	"general"
  eSplineCurveFormTypePlanar
	"planar"
  eSplineCurveFormTypeUnknown
	"unknown"
  
\endverbatim
*/
class PLMXML60_API eSplineCurveFormType : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eSplineCurveFormType( const char* Type );
     
	//! Constructor
	eSplineCurveFormType( const plmxml_api::String& Type );
     
	//! Default Constructor
	eSplineCurveFormType( );
     
	//! Destructor 
	virtual ~eSplineCurveFormType( );
     
	//! Assign from 'Type'
	const eSplineCurveFormType& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eSplineCurveFormType& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare SplineCurveFormType
	friend plmxml_api::logical PLMXML60_API operator==( const eSplineCurveFormType& e1, const eSplineCurveFormType& e2 );
     
	//! Compare SplineCurveFormType
	friend plmxml_api::logical PLMXML60_API operator!=( const eSplineCurveFormType& e1, const eSplineCurveFormType& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumSplineCurveFormType;
extern PLMXML60_API eSplineCurveFormType eSplineCurveFormTypeUnset;
extern PLMXML60_API eSplineCurveFormType eSplineCurveFormTypeGeneral;
extern PLMXML60_API eSplineCurveFormType eSplineCurveFormTypePlanar;
extern PLMXML60_API eSplineCurveFormType eSplineCurveFormTypeUnknown;

////////////////////////////////////////////////////////////////////////////////////
//! eContourEnum class
/*!
Allowed Values:
\verbatim
  eContourEnumFlush
	"flush"
  eContourEnumNone
	"none"
  eContourEnumConcave
	"concave"
  eContourEnumConvex
	"convex"
  
\endverbatim
*/
class PLMXML60_API eContourEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eContourEnum( const char* Type );
     
	//! Constructor
	eContourEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	eContourEnum( );
     
	//! Destructor 
	virtual ~eContourEnum( );
     
	//! Assign from 'Type'
	const eContourEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eContourEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare ContourEnum
	friend plmxml_api::logical PLMXML60_API operator==( const eContourEnum& e1, const eContourEnum& e2 );
     
	//! Compare ContourEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const eContourEnum& e1, const eContourEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumContourEnum;
extern PLMXML60_API eContourEnum eContourEnumUnset;
extern PLMXML60_API eContourEnum eContourEnumFlush;
extern PLMXML60_API eContourEnum eContourEnumNone;
extern PLMXML60_API eContourEnum eContourEnumConcave;
extern PLMXML60_API eContourEnum eContourEnumConvex;

////////////////////////////////////////////////////////////////////////////////////
//! eEffectivityEndConditionType class
/*!
Allowed Values:
\verbatim
  eEffectivityEndConditionTypeOpenEnded
	"openEnded"
  eEffectivityEndConditionTypeStockOut
	"stockOut"
  
\endverbatim
*/
class PLMXML60_API eEffectivityEndConditionType : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eEffectivityEndConditionType( const char* Type );
     
	//! Constructor
	eEffectivityEndConditionType( const plmxml_api::String& Type );
     
	//! Default Constructor
	eEffectivityEndConditionType( );
     
	//! Destructor 
	virtual ~eEffectivityEndConditionType( );
     
	//! Assign from 'Type'
	const eEffectivityEndConditionType& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eEffectivityEndConditionType& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare EffectivityEndConditionType
	friend plmxml_api::logical PLMXML60_API operator==( const eEffectivityEndConditionType& e1, const eEffectivityEndConditionType& e2 );
     
	//! Compare EffectivityEndConditionType
	friend plmxml_api::logical PLMXML60_API operator!=( const eEffectivityEndConditionType& e1, const eEffectivityEndConditionType& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumEffectivityEndConditionType;
extern PLMXML60_API eEffectivityEndConditionType eEffectivityEndConditionTypeUnset;
extern PLMXML60_API eEffectivityEndConditionType eEffectivityEndConditionTypeOpenEnded;
extern PLMXML60_API eEffectivityEndConditionType eEffectivityEndConditionTypeStockOut;

////////////////////////////////////////////////////////////////////////////////////
//! eGDERelationshipType class
/*!
Allowed Values:
\verbatim
  eGDERelationshipTypeProcessVariableValue
	"processVariableValue"
  eGDERelationshipTypeRoute
	"route"
  eGDERelationshipTypeProcessVariable
	"processVariable"
  eGDERelationshipTypeRealisation
	"realisation"
  eGDERelationshipTypeConnection
	"connection"
  eGDERelationshipTypeAttached
	"attached"
  eGDERelationshipTypeMass
	"mass"
  eGDERelationshipTypeMisc
	"misc"
  eGDERelationshipTypeSignalTransmitter
	"signalTransmitter"
  eGDERelationshipTypeSoftware
	"software"
  eGDERelationshipTypeProcessorGateway
	"processorGateway"
  eGDERelationshipTypeSignalValue
	"signalValue"
  eGDERelationshipTypeSharedAssociated
	"sharedAssociated"
  eGDERelationshipTypeSignalSource
	"signalSource"
  eGDERelationshipTypeImplementation
	"implementation"
  eGDERelationshipTypeSignalTarget
	"signalTarget"
  eGDERelationshipTypeRelated
	"related"
  eGDERelationshipTypeRedundancy
	"redundancy"
  eGDERelationshipTypeComponent
	"component"
  eGDERelationshipTypeImplements
	"implements"
  eGDERelationshipTypeAssociated
	"associated"
  eGDERelationshipTypeLinked
	"linked"
  
\endverbatim
*/
class PLMXML60_API eGDERelationshipType : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eGDERelationshipType( const char* Type );
     
	//! Constructor
	eGDERelationshipType( const plmxml_api::String& Type );
     
	//! Default Constructor
	eGDERelationshipType( );
     
	//! Destructor 
	virtual ~eGDERelationshipType( );
     
	//! Assign from 'Type'
	const eGDERelationshipType& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eGDERelationshipType& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare GDERelationshipType
	friend plmxml_api::logical PLMXML60_API operator==( const eGDERelationshipType& e1, const eGDERelationshipType& e2 );
     
	//! Compare GDERelationshipType
	friend plmxml_api::logical PLMXML60_API operator!=( const eGDERelationshipType& e1, const eGDERelationshipType& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumGDERelationshipType;
extern PLMXML60_API eGDERelationshipType eGDERelationshipTypeUnset;
extern PLMXML60_API eGDERelationshipType eGDERelationshipTypeProcessVariableValue;
extern PLMXML60_API eGDERelationshipType eGDERelationshipTypeRoute;
extern PLMXML60_API eGDERelationshipType eGDERelationshipTypeProcessVariable;
extern PLMXML60_API eGDERelationshipType eGDERelationshipTypeRealisation;
extern PLMXML60_API eGDERelationshipType eGDERelationshipTypeConnection;
extern PLMXML60_API eGDERelationshipType eGDERelationshipTypeAttached;
extern PLMXML60_API eGDERelationshipType eGDERelationshipTypeMass;
extern PLMXML60_API eGDERelationshipType eGDERelationshipTypeMisc;
extern PLMXML60_API eGDERelationshipType eGDERelationshipTypeSignalTransmitter;
extern PLMXML60_API eGDERelationshipType eGDERelationshipTypeSoftware;
extern PLMXML60_API eGDERelationshipType eGDERelationshipTypeProcessorGateway;
extern PLMXML60_API eGDERelationshipType eGDERelationshipTypeSignalValue;
extern PLMXML60_API eGDERelationshipType eGDERelationshipTypeSharedAssociated;
extern PLMXML60_API eGDERelationshipType eGDERelationshipTypeSignalSource;
extern PLMXML60_API eGDERelationshipType eGDERelationshipTypeImplementation;
extern PLMXML60_API eGDERelationshipType eGDERelationshipTypeSignalTarget;
extern PLMXML60_API eGDERelationshipType eGDERelationshipTypeRelated;
extern PLMXML60_API eGDERelationshipType eGDERelationshipTypeRedundancy;
extern PLMXML60_API eGDERelationshipType eGDERelationshipTypeComponent;
extern PLMXML60_API eGDERelationshipType eGDERelationshipTypeImplements;
extern PLMXML60_API eGDERelationshipType eGDERelationshipTypeAssociated;
extern PLMXML60_API eGDERelationshipType eGDERelationshipTypeLinked;

////////////////////////////////////////////////////////////////////////////////////
//! ePreferredPartUnitsType class
/*!
Allowed Values:
\verbatim
  ePreferredPartUnitsTypeMetres
	"metres"
  ePreferredPartUnitsTypeMillimetres
	"millimetres"
  ePreferredPartUnitsTypeInches
	"inches"
  
\endverbatim
*/
class PLMXML60_API ePreferredPartUnitsType : public plmxml_api::EnumBase
{

public:

	//! Constructor
	ePreferredPartUnitsType( const char* Type );
     
	//! Constructor
	ePreferredPartUnitsType( const plmxml_api::String& Type );
     
	//! Default Constructor
	ePreferredPartUnitsType( );
     
	//! Destructor 
	virtual ~ePreferredPartUnitsType( );
     
	//! Assign from 'Type'
	const ePreferredPartUnitsType& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const ePreferredPartUnitsType& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare PreferredPartUnitsType
	friend plmxml_api::logical PLMXML60_API operator==( const ePreferredPartUnitsType& e1, const ePreferredPartUnitsType& e2 );
     
	//! Compare PreferredPartUnitsType
	friend plmxml_api::logical PLMXML60_API operator!=( const ePreferredPartUnitsType& e1, const ePreferredPartUnitsType& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumPreferredPartUnitsType;
extern PLMXML60_API ePreferredPartUnitsType ePreferredPartUnitsTypeUnset;
extern PLMXML60_API ePreferredPartUnitsType ePreferredPartUnitsTypeMetres;
extern PLMXML60_API ePreferredPartUnitsType ePreferredPartUnitsTypeMillimetres;
extern PLMXML60_API ePreferredPartUnitsType ePreferredPartUnitsTypeInches;

////////////////////////////////////////////////////////////////////////////////////
//! eShadingStyleType class
/*!
Allowed Values:
\verbatim
  eShadingStyleTypeSmooth
	"smooth"
  eShadingStyleTypeFlat
	"flat"
  
\endverbatim
*/
class PLMXML60_API eShadingStyleType : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eShadingStyleType( const char* Type );
     
	//! Constructor
	eShadingStyleType( const plmxml_api::String& Type );
     
	//! Default Constructor
	eShadingStyleType( );
     
	//! Destructor 
	virtual ~eShadingStyleType( );
     
	//! Assign from 'Type'
	const eShadingStyleType& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eShadingStyleType& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare ShadingStyleType
	friend plmxml_api::logical PLMXML60_API operator==( const eShadingStyleType& e1, const eShadingStyleType& e2 );
     
	//! Compare ShadingStyleType
	friend plmxml_api::logical PLMXML60_API operator!=( const eShadingStyleType& e1, const eShadingStyleType& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumShadingStyleType;
extern PLMXML60_API eShadingStyleType eShadingStyleTypeUnset;
extern PLMXML60_API eShadingStyleType eShadingStyleTypeSmooth;
extern PLMXML60_API eShadingStyleType eShadingStyleTypeFlat;

////////////////////////////////////////////////////////////////////////////////////
//! eLoadOptionPartFamilyComponentsType class
/*!
Allowed Values:
\verbatim
  eLoadOptionPartFamilyComponentsTypeIgnore
	"ignore"
  eLoadOptionPartFamilyComponentsTypeGenerate
	"generate"
  
\endverbatim
*/
class PLMXML60_API eLoadOptionPartFamilyComponentsType : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eLoadOptionPartFamilyComponentsType( const char* Type );
     
	//! Constructor
	eLoadOptionPartFamilyComponentsType( const plmxml_api::String& Type );
     
	//! Default Constructor
	eLoadOptionPartFamilyComponentsType( );
     
	//! Destructor 
	virtual ~eLoadOptionPartFamilyComponentsType( );
     
	//! Assign from 'Type'
	const eLoadOptionPartFamilyComponentsType& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eLoadOptionPartFamilyComponentsType& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare LoadOptionPartFamilyComponentsType
	friend plmxml_api::logical PLMXML60_API operator==( const eLoadOptionPartFamilyComponentsType& e1, const eLoadOptionPartFamilyComponentsType& e2 );
     
	//! Compare LoadOptionPartFamilyComponentsType
	friend plmxml_api::logical PLMXML60_API operator!=( const eLoadOptionPartFamilyComponentsType& e1, const eLoadOptionPartFamilyComponentsType& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumLoadOptionPartFamilyComponentsType;
extern PLMXML60_API eLoadOptionPartFamilyComponentsType eLoadOptionPartFamilyComponentsTypeUnset;
extern PLMXML60_API eLoadOptionPartFamilyComponentsType eLoadOptionPartFamilyComponentsTypeIgnore;
extern PLMXML60_API eLoadOptionPartFamilyComponentsType eLoadOptionPartFamilyComponentsTypeGenerate;

////////////////////////////////////////////////////////////////////////////////////
//! eValidationCountEnum class
/*!
Allowed Values:
\verbatim
  eValidationCountEnumDatumTarget
	"datumTarget"
  eValidationCountEnumSegment
	"segment"
  eValidationCountEnumLocator
	"locator"
  eValidationCountEnumAnnotation
	"annotation"
  eValidationCountEnumCoordinateNote
	"coordinateNote"
  eValidationCountEnumSurfaceFinish
	"surfaceFinish"
  eValidationCountEnumCalloutDimension
	"calloutDimension"
  eValidationCountEnumDimension
	"dimension"
  eValidationCountEnumPartSpec
	"partSpec"
  eValidationCountEnumUserDefinedSymbol
	"userDefinedSymbol"
  eValidationCountEnumSpotWeld
	"spotWeld"
  eValidationCountEnumCircleCentre
	"circleCentre"
  eValidationCountEnumMaterialSpec
	"materialSpec"
  eValidationCountEnumCenterline
	"centerline"
  eValidationCountEnumFeatureControlFrame
	"featureControlFrame"
  eValidationCountEnumLineWeld
	"lineWeld"
  eValidationCountEnumBalloon
	"balloon"
  eValidationCountEnumFacet
	"facet"
  eValidationCountEnumOrganisation
	"organisation"
  eValidationCountEnumFitDesignation
	"fitDesignation"
  eValidationCountEnumCrosshatch
	"crosshatch"
  eValidationCountEnumProcessSpec
	"processSpec"
  eValidationCountEnumBundleDressingNote
	"bundleDressingNote"
  eValidationCountEnumFastener
	"fastener"
  eValidationCountEnumModelView
	"modelView"
  eValidationCountEnumParameterDimension
	"parameterDimension"
  eValidationCountEnumEMarking
	"eMarking"
  eValidationCountEnumMeasurementPoint
	"measurementPoint"
  eValidationCountEnumDatumFeatureSymbol
	"datumFeatureSymbol"
  eValidationCountEnumAttributeNote
	"attributeNote"
  eValidationCountEnumCuttingPlaneSymbol
	"cuttingPlaneSymbol"
  eValidationCountEnumTable
	"table"
  eValidationCountEnumNote
	"note"
  eValidationCountEnumRegion
	"region"
  eValidationCountEnumChamfer
	"chamfer"
  
\endverbatim
*/
class PLMXML60_API eValidationCountEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eValidationCountEnum( const char* Type );
     
	//! Constructor
	eValidationCountEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	eValidationCountEnum( );
     
	//! Destructor 
	virtual ~eValidationCountEnum( );
     
	//! Assign from 'Type'
	const eValidationCountEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eValidationCountEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare ValidationCountEnum
	friend plmxml_api::logical PLMXML60_API operator==( const eValidationCountEnum& e1, const eValidationCountEnum& e2 );
     
	//! Compare ValidationCountEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const eValidationCountEnum& e1, const eValidationCountEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumValidationCountEnum;
extern PLMXML60_API eValidationCountEnum eValidationCountEnumUnset;
extern PLMXML60_API eValidationCountEnum eValidationCountEnumDatumTarget;
extern PLMXML60_API eValidationCountEnum eValidationCountEnumSegment;
extern PLMXML60_API eValidationCountEnum eValidationCountEnumLocator;
extern PLMXML60_API eValidationCountEnum eValidationCountEnumAnnotation;
extern PLMXML60_API eValidationCountEnum eValidationCountEnumCoordinateNote;
extern PLMXML60_API eValidationCountEnum eValidationCountEnumSurfaceFinish;
extern PLMXML60_API eValidationCountEnum eValidationCountEnumCalloutDimension;
extern PLMXML60_API eValidationCountEnum eValidationCountEnumDimension;
extern PLMXML60_API eValidationCountEnum eValidationCountEnumPartSpec;
extern PLMXML60_API eValidationCountEnum eValidationCountEnumUserDefinedSymbol;
extern PLMXML60_API eValidationCountEnum eValidationCountEnumSpotWeld;
extern PLMXML60_API eValidationCountEnum eValidationCountEnumCircleCentre;
extern PLMXML60_API eValidationCountEnum eValidationCountEnumMaterialSpec;
extern PLMXML60_API eValidationCountEnum eValidationCountEnumCenterline;
extern PLMXML60_API eValidationCountEnum eValidationCountEnumFeatureControlFrame;
extern PLMXML60_API eValidationCountEnum eValidationCountEnumLineWeld;
extern PLMXML60_API eValidationCountEnum eValidationCountEnumBalloon;
extern PLMXML60_API eValidationCountEnum eValidationCountEnumFacet;
extern PLMXML60_API eValidationCountEnum eValidationCountEnumOrganisation;
extern PLMXML60_API eValidationCountEnum eValidationCountEnumFitDesignation;
extern PLMXML60_API eValidationCountEnum eValidationCountEnumCrosshatch;
extern PLMXML60_API eValidationCountEnum eValidationCountEnumProcessSpec;
extern PLMXML60_API eValidationCountEnum eValidationCountEnumBundleDressingNote;
extern PLMXML60_API eValidationCountEnum eValidationCountEnumFastener;
extern PLMXML60_API eValidationCountEnum eValidationCountEnumModelView;
extern PLMXML60_API eValidationCountEnum eValidationCountEnumParameterDimension;
extern PLMXML60_API eValidationCountEnum eValidationCountEnumEMarking;
extern PLMXML60_API eValidationCountEnum eValidationCountEnumMeasurementPoint;
extern PLMXML60_API eValidationCountEnum eValidationCountEnumDatumFeatureSymbol;
extern PLMXML60_API eValidationCountEnum eValidationCountEnumAttributeNote;
extern PLMXML60_API eValidationCountEnum eValidationCountEnumCuttingPlaneSymbol;
extern PLMXML60_API eValidationCountEnum eValidationCountEnumTable;
extern PLMXML60_API eValidationCountEnum eValidationCountEnumNote;
extern PLMXML60_API eValidationCountEnum eValidationCountEnumRegion;
extern PLMXML60_API eValidationCountEnum eValidationCountEnumChamfer;

////////////////////////////////////////////////////////////////////////////////////
//! eTransformationType class
/*!
Allowed Values:
\verbatim
  eTransformationTypeGeneral3
	"general3"
  eTransformationTypeScale
	"scale"
  eTransformationTypeGeneral
	"general"
  eTransformationTypeRotate
	"rotate"
  eTransformationTypeTranslate
	"translate"
  
\endverbatim
*/
class PLMXML60_API eTransformationType : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eTransformationType( const char* Type );
     
	//! Constructor
	eTransformationType( const plmxml_api::String& Type );
     
	//! Default Constructor
	eTransformationType( );
     
	//! Destructor 
	virtual ~eTransformationType( );
     
	//! Assign from 'Type'
	const eTransformationType& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eTransformationType& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare TransformationType
	friend plmxml_api::logical PLMXML60_API operator==( const eTransformationType& e1, const eTransformationType& e2 );
     
	//! Compare TransformationType
	friend plmxml_api::logical PLMXML60_API operator!=( const eTransformationType& e1, const eTransformationType& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumTransformationType;
extern PLMXML60_API eTransformationType eTransformationTypeUnset;
extern PLMXML60_API eTransformationType eTransformationTypeGeneral3;
extern PLMXML60_API eTransformationType eTransformationTypeScale;
extern PLMXML60_API eTransformationType eTransformationTypeGeneral;
extern PLMXML60_API eTransformationType eTransformationTypeRotate;
extern PLMXML60_API eTransformationType eTransformationTypeTranslate;

////////////////////////////////////////////////////////////////////////////////////
//! eGeometricConstraintActionEnum class
/*!
Allowed Values:
\verbatim
  eGeometricConstraintActionEnumForeground
	"foreground"
  eGeometricConstraintActionEnumForegroundBackground
	"foregroundBackground"
  eGeometricConstraintActionEnumBackground
	"background"
  
\endverbatim
*/
class PLMXML60_API eGeometricConstraintActionEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eGeometricConstraintActionEnum( const char* Type );
     
	//! Constructor
	eGeometricConstraintActionEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	eGeometricConstraintActionEnum( );
     
	//! Destructor 
	virtual ~eGeometricConstraintActionEnum( );
     
	//! Assign from 'Type'
	const eGeometricConstraintActionEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eGeometricConstraintActionEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare GeometricConstraintActionEnum
	friend plmxml_api::logical PLMXML60_API operator==( const eGeometricConstraintActionEnum& e1, const eGeometricConstraintActionEnum& e2 );
     
	//! Compare GeometricConstraintActionEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const eGeometricConstraintActionEnum& e1, const eGeometricConstraintActionEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumGeometricConstraintActionEnum;
extern PLMXML60_API eGeometricConstraintActionEnum eGeometricConstraintActionEnumUnset;
extern PLMXML60_API eGeometricConstraintActionEnum eGeometricConstraintActionEnumForeground;
extern PLMXML60_API eGeometricConstraintActionEnum eGeometricConstraintActionEnumForegroundBackground;
extern PLMXML60_API eGeometricConstraintActionEnum eGeometricConstraintActionEnumBackground;

////////////////////////////////////////////////////////////////////////////////////
//! eOptionScopeType class
/*!
Allowed Values:
\verbatim
  eOptionScopeTypePublic
	"public"
  eOptionScopeTypeLegacy
	"legacy"
  eOptionScopeTypePrivate
	"private"
  
\endverbatim
*/
class PLMXML60_API eOptionScopeType : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eOptionScopeType( const char* Type );
     
	//! Constructor
	eOptionScopeType( const plmxml_api::String& Type );
     
	//! Default Constructor
	eOptionScopeType( );
     
	//! Destructor 
	virtual ~eOptionScopeType( );
     
	//! Assign from 'Type'
	const eOptionScopeType& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eOptionScopeType& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare OptionScopeType
	friend plmxml_api::logical PLMXML60_API operator==( const eOptionScopeType& e1, const eOptionScopeType& e2 );
     
	//! Compare OptionScopeType
	friend plmxml_api::logical PLMXML60_API operator!=( const eOptionScopeType& e1, const eOptionScopeType& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumOptionScopeType;
extern PLMXML60_API eOptionScopeType eOptionScopeTypeUnset;
extern PLMXML60_API eOptionScopeType eOptionScopeTypePublic;
extern PLMXML60_API eOptionScopeType eOptionScopeTypeLegacy;
extern PLMXML60_API eOptionScopeType eOptionScopeTypePrivate;

////////////////////////////////////////////////////////////////////////////////////
//! eLineStyleEnum class
/*!
Allowed Values:
\verbatim
  eLineStyleEnumLongDashed
	"longDashed"
  eLineStyleEnumPhantom
	"phantom"
  eLineStyleEnumSolid
	"solid"
  eLineStyleEnumCentreline
	"centreline"
  eLineStyleEnumDotDash
	"dotDash"
  eLineStyleEnumDashed
	"dashed"
  eLineStyleEnumDotted
	"dotted"
  
\endverbatim
*/
class PLMXML60_API eLineStyleEnum : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eLineStyleEnum( const char* Type );
     
	//! Constructor
	eLineStyleEnum( const plmxml_api::String& Type );
     
	//! Default Constructor
	eLineStyleEnum( );
     
	//! Destructor 
	virtual ~eLineStyleEnum( );
     
	//! Assign from 'Type'
	const eLineStyleEnum& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eLineStyleEnum& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare LineStyleEnum
	friend plmxml_api::logical PLMXML60_API operator==( const eLineStyleEnum& e1, const eLineStyleEnum& e2 );
     
	//! Compare LineStyleEnum
	friend plmxml_api::logical PLMXML60_API operator!=( const eLineStyleEnum& e1, const eLineStyleEnum& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumLineStyleEnum;
extern PLMXML60_API eLineStyleEnum eLineStyleEnumUnset;
extern PLMXML60_API eLineStyleEnum eLineStyleEnumLongDashed;
extern PLMXML60_API eLineStyleEnum eLineStyleEnumPhantom;
extern PLMXML60_API eLineStyleEnum eLineStyleEnumSolid;
extern PLMXML60_API eLineStyleEnum eLineStyleEnumCentreline;
extern PLMXML60_API eLineStyleEnum eLineStyleEnumDotDash;
extern PLMXML60_API eLineStyleEnum eLineStyleEnumDashed;
extern PLMXML60_API eLineStyleEnum eLineStyleEnumDotted;

////////////////////////////////////////////////////////////////////////////////////
//! eLoadOptionErrorActionType class
/*!
Allowed Values:
\verbatim
  eLoadOptionErrorActionTypeAbort
	"abort"
  eLoadOptionErrorActionTypeContinue
	"continue"
  
\endverbatim
*/
class PLMXML60_API eLoadOptionErrorActionType : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eLoadOptionErrorActionType( const char* Type );
     
	//! Constructor
	eLoadOptionErrorActionType( const plmxml_api::String& Type );
     
	//! Default Constructor
	eLoadOptionErrorActionType( );
     
	//! Destructor 
	virtual ~eLoadOptionErrorActionType( );
     
	//! Assign from 'Type'
	const eLoadOptionErrorActionType& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eLoadOptionErrorActionType& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare LoadOptionErrorActionType
	friend plmxml_api::logical PLMXML60_API operator==( const eLoadOptionErrorActionType& e1, const eLoadOptionErrorActionType& e2 );
     
	//! Compare LoadOptionErrorActionType
	friend plmxml_api::logical PLMXML60_API operator!=( const eLoadOptionErrorActionType& e1, const eLoadOptionErrorActionType& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumLoadOptionErrorActionType;
extern PLMXML60_API eLoadOptionErrorActionType eLoadOptionErrorActionTypeUnset;
extern PLMXML60_API eLoadOptionErrorActionType eLoadOptionErrorActionTypeAbort;
extern PLMXML60_API eLoadOptionErrorActionType eLoadOptionErrorActionTypeContinue;

////////////////////////////////////////////////////////////////////////////////////
//! eLoadOptionComponentSetType class
/*!
Allowed Values:
\verbatim
  eLoadOptionComponentSetTypeAll
	"all"
  eLoadOptionComponentSetTypeLast
	"last"
  eLoadOptionComponentSetTypeTop
	"top"
  
\endverbatim
*/
class PLMXML60_API eLoadOptionComponentSetType : public plmxml_api::EnumBase
{

public:

	//! Constructor
	eLoadOptionComponentSetType( const char* Type );
     
	//! Constructor
	eLoadOptionComponentSetType( const plmxml_api::String& Type );
     
	//! Default Constructor
	eLoadOptionComponentSetType( );
     
	//! Destructor 
	virtual ~eLoadOptionComponentSetType( );
     
	//! Assign from 'Type'
	const eLoadOptionComponentSetType& operator=( const plmxml_api::String& Type );
     
	//! Assign from 'Type'
	const eLoadOptionComponentSetType& operator=( const char* Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const plmxml_api::String& Type );

	//! Set this object equal to 'Type'. Returns FALSE if 'Type' does not match any allowable values.
	virtual plmxml_api::logical Set( const char* Type );

	//! Compare LoadOptionComponentSetType
	friend plmxml_api::logical PLMXML60_API operator==( const eLoadOptionComponentSetType& e1, const eLoadOptionComponentSetType& e2 );
     
	//! Compare LoadOptionComponentSetType
	friend plmxml_api::logical PLMXML60_API operator!=( const eLoadOptionComponentSetType& e1, const eLoadOptionComponentSetType& e2 );
};
extern PLMXML60_API plmxml_api::plmxmlFieldType plmxmlFieldEnumLoadOptionComponentSetType;
extern PLMXML60_API eLoadOptionComponentSetType eLoadOptionComponentSetTypeUnset;
extern PLMXML60_API eLoadOptionComponentSetType eLoadOptionComponentSetTypeAll;
extern PLMXML60_API eLoadOptionComponentSetType eLoadOptionComponentSetTypeLast;
extern PLMXML60_API eLoadOptionComponentSetType eLoadOptionComponentSetTypeTop;

////////////////////////////////////////////////////////////////////////////////////
//! IdObject class
/*!
\verbatim

\endverbatim
*/
class PLMXML60_API IdObject : public plmxml_api::Object
{
public:
     
    //! Default constructor
    IdObject( );
     
    //! Constructs a IdObject with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    IdObject( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~IdObject();

private:

	//! Assignment operator
	IdObject& operator=( const IdObject& iSrc );

	//! Copy constructor
	IdObject( const IdObject& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderIdObject" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassIdObject;


////////////////////////////////////////////////////////////////////////////////////
//! ApplicationRef class
/*!
\verbatim

      The ApplicationRef element is meant to relate the parent element (Product, 
      Representation, etc) back to the owning entity in the sending  application.

      Attributes:

      application:  the context in which the contents of the label and version attributes 
                    make sense. Whether this field includes an application version number 
                    is up to the application, as long as it starts with something 
                    identifiable to the sending application.

      label:        the string which identifies the application entity - the value of
                    this field is only meaningful to the sending/authoring application.
                    The receiving application can compare the contents of the attribute
                    to test if two entities are the 'same' entity. But the actual value
                    is meaningless to the receiving application.

      version:      the optional string attribute which identifies the version of the
                    application entity. This attribute can only be used to test if the
                    versions of an entity are the same (i.e. the test is only meaningful
                    if the label attribute values are the same). No version ordering can
                    be deduced from the value. Similar to the label attribute, the 
                    version attribute contents are meaningless to the receiving 
                    application.
      
\endverbatim
*/
class PLMXML60_API ApplicationRef : public plmxml_api::Object
{
public:
     
    //! Default constructor
    ApplicationRef( );
     
    //! Constructs a ApplicationRef with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ApplicationRef( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ApplicationRef();

private:

	//! Assignment operator
	ApplicationRef& operator=( const ApplicationRef& iSrc );

	//! Copy constructor
	ApplicationRef( const ApplicationRef& original );
     
public:

	//! Get Application of this ApplicationRef
	plmxml_api::String GetApplication() const;

	//! Set Application of this ApplicationRef
	plmxml_api::Result SetApplication( const plmxml_api::String &s );
	
	//! Check if Application is set
	plmxml_api::logical HasApplication( ) const;
	
	//! Unset Application
	plmxml_api::Result UnsetApplication( );

	//! Get Label of this ApplicationRef
	plmxml_api::String GetLabel() const;

	//! Set Label of this ApplicationRef
	plmxml_api::Result SetLabel( const plmxml_api::String &s );
	
	//! Check if Label is set
	plmxml_api::logical HasLabel( ) const;
	
	//! Unset Label
	plmxml_api::Result UnsetLabel( );

	//! Get Version of this ApplicationRef
	plmxml_api::String GetVersion() const;

	//! Set Version of this ApplicationRef
	plmxml_api::Result SetVersion( const plmxml_api::String &s );
	
	//! Check if Version is set
	plmxml_api::logical HasVersion( ) const;
	
	//! Unset Version
	plmxml_api::Result UnsetVersion( );
 
// <PLMXML_UserCode type="functionHeaderApplicationRef" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassApplicationRef;


////////////////////////////////////////////////////////////////////////////////////
//! DescriptionObject class
/*!
\verbatim

      The DescriptionBase type is an abstract base type for PLM XML types which
      have optional description and ApplicationRef.

      Attributes:

      name:             descriptive or display name
      nameRef:          References a multiple language version of name. If
                        multiple language support is required, nameRef should be
                        used in addition to name.
      descriptionTextRef: References a multiple language version of description.
                        If multiple language support is required,
                        descriptionTextRef should be used in addition to
                        description.

      Sub-elements:

      Description:     Readable textual description of the element.
      ApplicationRef:  A means of uniquely identifying the element in terms
                       understood by the sending system. More than one is
                       allowed (at most one per Application).
      
\endverbatim
*/
class PLMXML60_API DescriptionObject : public IdObject
{
public:
     
    //! Default constructor
    DescriptionObject( );
     
    //! Constructs a DescriptionObject with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    DescriptionObject( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~DescriptionObject();

private:

	//! Assignment operator
	DescriptionObject& operator=( const DescriptionObject& iSrc );

	//! Copy constructor
	DescriptionObject( const DescriptionObject& original );
     
public:

	//! Get Name of this DescriptionObject
	plmxml_api::String GetName() const;

	//! Set Name of this DescriptionObject
	plmxml_api::Result SetName( const plmxml_api::String &s );
	
	//! Check if Name is set
	plmxml_api::logical HasName( ) const;
	
	//! Unset Name
	plmxml_api::Result UnsetName( );

	//! Get Name URI as plmxml_api::String
	plmxml_api::String GetNameURI() const;

	//! Set Name URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetNameURI( const plmxml_api::String& );
	
	//! Get the handle of Name URI. Does not resolve the URI.
	plmxml_api::Result GetNameURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Name URI. URI string is unchanged.
	plmxml_api::Result SetNameURI( const plmxml_api::Handle& );
	
	//! Resolve Name URI and return an object (handle) it points to.
	plmxml_api::Result ResolveNameURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Name URI. Clears URI string and handle.
	plmxml_api::Result DeleteNameURI();
	
	//! Check if Name URI is set
	plmxml_api::logical HasNameURI( ) const;
	

	//! Get DescriptionText URI as plmxml_api::String
	plmxml_api::String GetDescriptionTextURI() const;

	//! Set DescriptionText URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetDescriptionTextURI( const plmxml_api::String& );
	
	//! Get the handle of DescriptionText URI. Does not resolve the URI.
	plmxml_api::Result GetDescriptionTextURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of DescriptionText URI. URI string is unchanged.
	plmxml_api::Result SetDescriptionTextURI( const plmxml_api::Handle& );
	
	//! Resolve DescriptionText URI and return an object (handle) it points to.
	plmxml_api::Result ResolveDescriptionTextURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset DescriptionText URI. Clears URI string and handle.
	plmxml_api::Result DeleteDescriptionTextURI();
	
	//! Check if DescriptionText URI is set
	plmxml_api::logical HasDescriptionTextURI( ) const;
	

	//! Get Description of this DescriptionObject
	plmxml_api::String GetDescription() const;

	//! Set Description of this DescriptionObject
	plmxml_api::Result SetDescription( const plmxml_api::String &s );
	
	//! Check if Description is set
	plmxml_api::logical HasDescription( ) const;
	
	//! Unset Description
	plmxml_api::Result UnsetDescription( );

	//! Add ApplicationRef child element to this DescriptionObject. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	ApplicationRef *AddApplicationRef();
     
	//! Add 'arg' as ApplicationRef child element to this DescriptionObject.
	plmxml_api::Result AddApplicationRef( ApplicationRef *arg );

	//! Detach and delete all ApplicationRef child elements.
	void DeleteApplicationRefs();
     
	//! Get number of ApplicationRef child elements.
	int NumberOfApplicationRefs() const;
     
	//! Get i'th ApplicationRef child element.
	ApplicationRef *GetApplicationRef( int i ) const;
     
	//! Get all ApplicationRef child element as an array
	void GetApplicationRefs( plmxml_api::Array<ApplicationRef*> &array ) const;
	     
	//! Detach and delete i'th ApplicationRef child element
	void DeleteApplicationRef( int i );
     
	//! Detach and delete 'arg' if it's one of the ApplicationRef child elements
	void DeleteApplicationRef( ApplicationRef *arg );
 
// <PLMXML_UserCode type="functionHeaderDescriptionObject" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassDescriptionObject;


//! Forward class declarations
class Attribute;

////////////////////////////////////////////////////////////////////////////////////
//! AttribOwner class
/*!
\verbatim

      Base class for elements which have PLMXML Attributes, i.e. elements
      derived from plm:AttributeBase.
      
      Attributes:
        
      attributeRefs: reference to Attributes
               
      Elements:
      
      Attribute:     any element derived from AttributeBase.
      
\endverbatim
*/
class PLMXML60_API AttribOwner : public DescriptionObject
{
public:
     
    //! Default constructor
    AttribOwner( );
     
    //! Constructs a AttribOwner with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    AttribOwner( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~AttribOwner();

private:

	//! Assignment operator
	AttribOwner& operator=( const AttribOwner& iSrc );

	//! Copy constructor
	AttribOwner( const AttribOwner& original );
     
public:

	//! Get number of references in Attribute array
	int NumberOfAttributeRefs() const;
     
	//! Add reference to 'arg' to Attribute array
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical AddAttributeRef( plmxml60::IdObject *arg );
     
	//! Add reference to an object pointed to by 'u' to Attribute array
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical AddAttributeId( const plmxml_api::String &u );
     
	//! Set i'th reference in Attribute array to 'arg'
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical SetAttributeRef( int i, plmxml60::IdObject *arg );
     
	//! Set i'th reference in Attribute array to an object pointed to by 'u'
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical SetAttributeId( int i, const plmxml_api::String &u );
     
	//! Resolve i'th reference in Attribute array and return an object it points to.
	plmxml60::IdObject *ResolveAttributeRef( int i, plmxml_api::Configuration* config = NULL );
     
	//! Resolve all references in Attribute array and return objects they point to.
	void ResolveAttributeRefs( plmxml_api::Array<plmxml60::IdObject *> & array, plmxml_api::Configuration* config = NULL );
     
	//! Get i'th reference in Attribute array as plmxml_api::String
	plmxml_api::String GetAttributeId( int i ) const;
     
	//! Get all references in Attribute array as an array of plmxml_api::String
	void GetAttributeIds( plmxml_api::Array<plmxml_api::String> &array ) const;
     
	//! Remove i'th reference from the Attribute array.
	void RemoveAttributeRef( int i );
     
	//! Remove reference to an object pointed to by 'u' from the Attribute array.
	void RemoveAttributeRef( const plmxml_api::String &u );
     
	//! Remove reference to 'arg' from the Attribute array.
	void RemoveAttributeRef( plmxml60::IdObject *arg );
     
	//! Remove all references Attribute array.
	void RemoveAttributeRefs();
	
	//! Check if Attribute is set
	plmxml_api::logical HasAttributeRefs( ) const;

	//! Add Attribute child element to this AttribOwner. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Attribute *AddAttribute();
     
	//! Add 'arg' as Attribute child element to this AttribOwner.
	plmxml_api::Result AddAttribute( Attribute *arg );

	//! Detach and delete all Attribute child elements.
	void DeleteAttributes();
     
	//! Get number of Attribute child elements.
	int NumberOfAttributes() const;
     
	//! Get i'th Attribute child element.
	Attribute *GetAttribute( int i ) const;
     
	//! Get all Attribute child element as an array
	void GetAttributes( plmxml_api::Array<Attribute*> &array ) const;
	     
	//! Detach and delete i'th Attribute child element
	void DeleteAttribute( int i );
     
	//! Detach and delete 'arg' if it's one of the Attribute child elements
	void DeleteAttribute( Attribute *arg );
 
// <PLMXML_UserCode type="functionHeaderAttribOwner" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassAttribOwner;


////////////////////////////////////////////////////////////////////////////////////
//! Position class
/*!
\verbatim

\endverbatim
*/
class PLMXML60_API Position : public IdObject
{
public:
     
    //! Default constructor
    Position( );
     
    //! Constructs a Position with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Position( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Position();

private:

	//! Assignment operator
	Position& operator=( const Position& iSrc );

	//! Copy constructor
	Position( const Position& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderPosition" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassPosition;


////////////////////////////////////////////////////////////////////////////////////
//! Normal class
/*!
\verbatim

\endverbatim
*/
class PLMXML60_API Normal : public IdObject
{
public:
     
    //! Default constructor
    Normal( );
     
    //! Constructs a Normal with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Normal( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Normal();

private:

	//! Assignment operator
	Normal& operator=( const Normal& iSrc );

	//! Copy constructor
	Normal( const Normal& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderNormal" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassNormal;


////////////////////////////////////////////////////////////////////////////////////
//! Transform class
/*!
\verbatim

\endverbatim
*/
class PLMXML60_API Transform : public IdObject
{
public:
     
    //! Default constructor
    Transform( );
     
    //! Constructs a Transform with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Transform( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Transform();

private:

	//! Assignment operator
	Transform& operator=( const Transform& iSrc );

	//! Copy constructor
	Transform( const Transform& original );
     
public:

	//! Set Type
	plmxml_api::Result SetType( const eTransformationType& arg );

	//! Get Type
	eTransformationType GetType() const;
 
// <PLMXML_UserCode type="functionHeaderTransform" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassTransform;


////////////////////////////////////////////////////////////////////////////////////
//! Zone class
/*!
\verbatim

      This is an abstract base type for elements representing a subset of
      3D space.
      
      Attributes:
      
      transformRef:  Optional transform, to apply to data in derived types.
                     For example, the data in a Bound can define an axis-
                     aligned box. By using a Transform, this can then 
                     represent a non-axis-aligned box.
      
      Elements:
      
      Transform:     Optional transform. Do not use both transformRef and
                     Transform sub-element.
      
\endverbatim
*/
class PLMXML60_API Zone : public AttribOwner
{
public:
     
    //! Default constructor
    Zone( );
     
    //! Constructs a Zone with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Zone( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Zone();

private:

	//! Assignment operator
	Zone& operator=( const Zone& iSrc );

	//! Copy constructor
	Zone( const Zone& original );
     
public:

	//! Set reference to Transform using 'arg's plmxml_api::Id.
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical SetTransformRef( plmxml60::IdObject *arg );

	//! Clear reference to Transform
	void RemoveTransformRef( );

	//! Find a plmxml60::IdObject referenced by Transform
	plmxml60::IdObject *ResolveTransformRef( plmxml_api::Configuration* config = NULL );

	//! Get Transform reference
	plmxml_api::String GetTransformId() const;

	//! Set Transform reference.
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical SetTransformId( const plmxml_api::String& u );
	
	//! Check if Transform is set
	plmxml_api::logical HasTransformRef( ) const;

	//! Add Transform child element to this Zone. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	Transform *AddTransform();
     
	//! Set Transform child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetTransform( Transform *arg );
     
	//! Get Transform child element of this Zone.
	Transform *GetTransform() const;
     
	//! Detach and delete Transform child element tree from this Zone.
	void DeleteTransform();
 
// <PLMXML_UserCode type="functionHeaderZone" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassZone;


////////////////////////////////////////////////////////////////////////////////////
//! Bound class
/*!
\verbatim

      A simple or compound bound or zone. Simple bounds are boxes or spheres.
      Compound bounds are the union of sub-bounds represented by Bound
      sub-elements. Any transform on a compound bound is applied after the
      union.

      Attributes:

      type:             box, sphere or compound.
      values:           If type is box, values is a list of 6 doubles giving the
                        coordinates of the centre, the x half width, the y half
                        width and the z half width.
                        If type is sphere, values is a list of 4 doubles giving
                        the centre and the radius.
                        If type is compound, values is ignored.

      Sub-elements:    

      Bound:            If type is compound, the Bound sub-elements represent
                        the sub-bounds, which may be simple or compound.
      
\endverbatim
*/
class PLMXML60_API Bound : public Zone
{
public:
     
    //! Default constructor
    Bound( );
     
    //! Constructs a Bound with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Bound( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Bound();

private:

	//! Assignment operator
	Bound& operator=( const Bound& iSrc );

	//! Copy constructor
	Bound( const Bound& original );
     
public:

	//! Set Type
	plmxml_api::Result SetType( const eBoundingType& arg );

	//! Get Type
	eBoundingType GetType() const;

	//! Set Values
	plmxml_api::Result SetValues( const plmxml_api::Array<double>& arg );

	//! Get Values
	plmxml_api::Result GetValues( plmxml_api::Array<double>& arg ) const;

	//! Check if Values is set
	plmxml_api::logical HasValues() const;

	//! Unset Values
	plmxml_api::Result UnsetValues();

	//! Add Bound child element to this Bound. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Bound *AddBound();
     
	//! Add 'arg' as Bound child element to this Bound.
	plmxml_api::Result AddBound( Bound *arg );

	//! Detach and delete all Bound child elements.
	void DeleteBounds();
     
	//! Get number of Bound child elements.
	int NumberOfBounds() const;
     
	//! Get i'th Bound child element.
	Bound *GetBound( int i ) const;
     
	//! Get all Bound child element as an array
	void GetBounds( plmxml_api::Array<Bound*> &array ) const;
	     
	//! Detach and delete i'th Bound child element
	void DeleteBound( int i );
     
	//! Detach and delete 'arg' if it's one of the Bound child elements
	void DeleteBound( Bound *arg );
 
// <PLMXML_UserCode type="functionHeaderBound" >
    //! Set bound from BoxBound
	void SetBound( const plmxml_api::BoxBound& b );

    //! Get bound as BoxBound
	plmxml_api::logical GetBound( plmxml_api::BoxBound &b ) const;

    //! Set bound from SphereBound
	void SetBound( const plmxml_api::SphereBound& b );

    //! Get bound as SphereBound
	plmxml_api::logical GetBound( plmxml_api::SphereBound &b ) const;

    //! Set bounding box Low Corner
	void SetLowCorner(double *lowCorner);

    //! Set bounding box High Corner
	void SetHighCorner(double *highCorner);

    //! Set bounding sphere Radius
	void SetRadius(double radius);

    //! Set bounding sphere Centre
	void SetCentre(double *centre);
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassBound;


//! Forward class declarations
class Plane;

////////////////////////////////////////////////////////////////////////////////////
//! PlanarZone class
/*!
\verbatim

      This is a Zone defined by the intersection of a number of halfspaces. Each
      Halfspace is defined as the area of space behind a Plane (i.e. away from the
      Plane normal). 
      
      If there is only one Plane, the Zone is a halfspace.
      
      Elements:
      
      Plane:         Plane defining a halfspace
      
\endverbatim
*/
class PLMXML60_API PlanarZone : public Zone
{
public:
     
    //! Default constructor
    PlanarZone( );
     
    //! Constructs a PlanarZone with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    PlanarZone( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~PlanarZone();

private:

	//! Assignment operator
	PlanarZone& operator=( const PlanarZone& iSrc );

	//! Copy constructor
	PlanarZone( const PlanarZone& original );
     
public:

	//! Add Plane child element to this PlanarZone. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Plane *AddPlane();
     
	//! Add 'arg' as Plane child element to this PlanarZone.
	plmxml_api::Result AddPlane( Plane *arg );

	//! Detach and delete all Plane child elements.
	void DeletePlanes();
     
	//! Get number of Plane child elements.
	int NumberOfPlanes() const;
     
	//! Get i'th Plane child element.
	Plane *GetPlane( int i ) const;
     
	//! Get all Plane child element as an array
	void GetPlanes( plmxml_api::Array<Plane*> &array ) const;
	     
	//! Detach and delete i'th Plane child element
	void DeletePlane( int i );
     
	//! Detach and delete 'arg' if it's one of the Plane child elements
	void DeletePlane( Plane *arg );
 
// <PLMXML_UserCode type="functionHeaderPlanarZone" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassPlanarZone;


////////////////////////////////////////////////////////////////////////////////////
//! IntegerField class
/*!
\verbatim

\endverbatim
*/
class PLMXML60_API IntegerField : public plmxml_api::Object
{
public:
     
    //! Default constructor
    IntegerField( );
     
    //! Constructs a IntegerField with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    IntegerField( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~IntegerField();

private:

	//! Assignment operator
	IntegerField& operator=( const IntegerField& iSrc );

	//! Copy constructor
	IntegerField( const IntegerField& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderIntegerField" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassIntegerField;


////////////////////////////////////////////////////////////////////////////////////
//! IntegerFieldList class
/*!
\verbatim

\endverbatim
*/
class PLMXML60_API IntegerFieldList : public plmxml_api::Object
{
public:
     
    //! Default constructor
    IntegerFieldList( );
     
    //! Constructs a IntegerFieldList with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    IntegerFieldList( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~IntegerFieldList();

private:

	//! Assignment operator
	IntegerFieldList& operator=( const IntegerFieldList& iSrc );

	//! Copy constructor
	IntegerFieldList( const IntegerFieldList& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderIntegerFieldList" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassIntegerFieldList;


////////////////////////////////////////////////////////////////////////////////////
//! RealField class
/*!
\verbatim

\endverbatim
*/
class PLMXML60_API RealField : public plmxml_api::Object
{
public:
     
    //! Default constructor
    RealField( );
     
    //! Constructs a RealField with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    RealField( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~RealField();

private:

	//! Assignment operator
	RealField& operator=( const RealField& iSrc );

	//! Copy constructor
	RealField( const RealField& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderRealField" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassRealField;


////////////////////////////////////////////////////////////////////////////////////
//! RealFieldList class
/*!
\verbatim

\endverbatim
*/
class PLMXML60_API RealFieldList : public plmxml_api::Object
{
public:
     
    //! Default constructor
    RealFieldList( );
     
    //! Constructs a RealFieldList with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    RealFieldList( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~RealFieldList();

private:

	//! Assignment operator
	RealFieldList& operator=( const RealFieldList& iSrc );

	//! Copy constructor
	RealFieldList( const RealFieldList& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderRealFieldList" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassRealFieldList;


////////////////////////////////////////////////////////////////////////////////////
//! StringField class
/*!
\verbatim

\endverbatim
*/
class PLMXML60_API StringField : public plmxml_api::Object
{
public:
     
    //! Default constructor
    StringField( );
     
    //! Constructs a StringField with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    StringField( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~StringField();

private:

	//! Assignment operator
	StringField& operator=( const StringField& iSrc );

	//! Copy constructor
	StringField( const StringField& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderStringField" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassStringField;


////////////////////////////////////////////////////////////////////////////////////
//! LogicalField class
/*!
\verbatim

\endverbatim
*/
class PLMXML60_API LogicalField : public plmxml_api::Object
{
public:
     
    //! Default constructor
    LogicalField( );
     
    //! Constructs a LogicalField with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    LogicalField( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~LogicalField();

private:

	//! Assignment operator
	LogicalField& operator=( const LogicalField& iSrc );

	//! Copy constructor
	LogicalField( const LogicalField& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderLogicalField" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassLogicalField;


////////////////////////////////////////////////////////////////////////////////////
//! VectorField class
/*!
\verbatim

\endverbatim
*/
class PLMXML60_API VectorField : public plmxml_api::Object
{
public:
     
    //! Default constructor
    VectorField( );
     
    //! Constructs a VectorField with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    VectorField( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~VectorField();

private:

	//! Assignment operator
	VectorField& operator=( const VectorField& iSrc );

	//! Copy constructor
	VectorField( const VectorField& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderVectorField" >
     // TODO: Add extra function headers within this block
    //! Constructor with Vector.
    VectorField( const plmxml_api::Vector& vec );

    //! Constructs a VectorField from the Vector with the specified parent.
    /*!
        If the parent of this object cannot be set a plmxml_api::Exception
        is thrown.
    */
    VectorField( const plmxml_api::Vector& vec, plmxml_api::Object* pParent );
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassVectorField;


////////////////////////////////////////////////////////////////////////////////////
//! Attribute class
/*!
\verbatim

      The Attribute element is an abstract element. Useful attributes
      (ones that include fields) must be derived from the Attribute element
      defined within this schema. The derived attributes will define their 
      data elements to represent data fields.
    
      The derived attributes also need to be set as 'equivalent' to the 
      Attribute element. This enables the new derived attribute to be
      inserted into documents wherever the Attribute element is allowed.
      
\endverbatim
*/
class PLMXML60_API Attribute : public DescriptionObject
{
public:
     
    //! Default constructor
    Attribute( );
     
    //! Constructs a Attribute with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Attribute( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Attribute();

private:

	//! Assignment operator
	Attribute& operator=( const Attribute& iSrc );

	//! Copy constructor
	Attribute( const Attribute& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderAttribute" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassAttribute;


////////////////////////////////////////////////////////////////////////////////////
//! Entity3D class
/*!
\verbatim

      Base class for elements which may contain 3D bounds.
      
      Elements:
      
      BoxBound:      legacy, use Bound in preference
      SphereBound:   legacy, use Bound in preference 
      Bound:         3D bound
      
\endverbatim
*/
class PLMXML60_API Entity3D : public AttribOwner
{
public:
     
    //! Default constructor
    Entity3D( );
     
    //! Constructs a Entity3D with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Entity3D( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Entity3D();

private:

	//! Assignment operator
	Entity3D& operator=( const Entity3D& iSrc );

	//! Copy constructor
	Entity3D( const Entity3D& original );
     
public:

	//! Add Bound child element to this Entity3D. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Bound *AddBound();
     
	//! Add 'arg' as Bound child element to this Entity3D.
	plmxml_api::Result AddBound( Bound *arg );

	//! Detach and delete all Bound child elements.
	void DeleteBounds();
     
	//! Get number of Bound child elements.
	int NumberOfBounds() const;
     
	//! Get i'th Bound child element.
	Bound *GetBound( int i ) const;
     
	//! Get all Bound child element as an array
	void GetBounds( plmxml_api::Array<Bound*> &array ) const;
	     
	//! Detach and delete i'th Bound child element
	void DeleteBound( int i );
     
	//! Detach and delete 'arg' if it's one of the Bound child elements
	void DeleteBound( Bound *arg );
 
// <PLMXML_UserCode type="functionHeaderEntity3D" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassEntity3D;


////////////////////////////////////////////////////////////////////////////////////
//! Managed class
/*!
\verbatim

      This is an abstract base class for elements which require information such as 
      access control, status and checkout information
      
      Attributes:
      
      accessRefs:      reference to one or more elements derived from AccessControlBase
      statusRef:       reference to element derived from StatusBase
      checkoutRefs:    reference to one or more elements derived from CheckoutStatusBase
      effectivityRefs  reference to Effectivity elements
      
      subType:         No specified semantics. This can be used where simple customised
                       sub-types have been defined and a PLMXML schema extension is not
                       appropriate.
                       
      releaseStatusRefs: Reference to one or more ReleaseStatus elements, which give
                       release dates and effectivities.
      
\endverbatim
*/
class PLMXML60_API Managed : public Entity3D
{
public:
     
    //! Default constructor
    Managed( );
     
    //! Constructs a Managed with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Managed( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Managed();

private:

	//! Assignment operator
	Managed& operator=( const Managed& iSrc );

	//! Copy constructor
	Managed( const Managed& original );
     
public:

	//! Get number of URIs in Effectivity
	int NumberOfEffectivityURIs() const;

	//! Get i'th URI in Effectivity
	plmxml_api::String GetEffectivityURI( int i ) const;

	//! Add a URI to Effectivity array. Call ResolveEffectivityURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddEffectivityURI( const plmxml_api::String& u );

	//! Set i'th URI in Effectivity array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetEffectivityURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Effectivity URI. Does not resolve the URI.
	plmxml_api::Result GetEffectivityURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Effectivity array.
	plmxml_api::Result AddEffectivityURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Effectivity array to point to 'handle'.
	plmxml_api::Result SetEffectivityURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Effectivity points to.
	plmxml_api::Result ResolveEffectivityURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Effectivity array.
	plmxml_api::Result DeleteEffectivityURI( int i );

	//! Remove all URIs from Effectivity array.
	plmxml_api::Result DeleteEffectivityURIs( );
	
	//! Check if Effectivity is set
	plmxml_api::logical HasEffectivityURIs( ) const;

	//! Get Status URI as plmxml_api::String
	plmxml_api::String GetStatusURI() const;

	//! Set Status URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetStatusURI( const plmxml_api::String& );
	
	//! Get the handle of Status URI. Does not resolve the URI.
	plmxml_api::Result GetStatusURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Status URI. URI string is unchanged.
	plmxml_api::Result SetStatusURI( const plmxml_api::Handle& );
	
	//! Resolve Status URI and return an object (handle) it points to.
	plmxml_api::Result ResolveStatusURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Status URI. Clears URI string and handle.
	plmxml_api::Result DeleteStatusURI();
	
	//! Check if Status URI is set
	plmxml_api::logical HasStatusURI( ) const;
	

	//! Get number of URIs in ReleaseStatus
	int NumberOfReleaseStatusURIs() const;

	//! Get i'th URI in ReleaseStatus
	plmxml_api::String GetReleaseStatusURI( int i ) const;

	//! Add a URI to ReleaseStatus array. Call ResolveReleaseStatusURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddReleaseStatusURI( const plmxml_api::String& u );

	//! Set i'th URI in ReleaseStatus array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetReleaseStatusURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of ReleaseStatus URI. Does not resolve the URI.
	plmxml_api::Result GetReleaseStatusURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to ReleaseStatus array.
	plmxml_api::Result AddReleaseStatusURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in ReleaseStatus array to point to 'handle'.
	plmxml_api::Result SetReleaseStatusURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in ReleaseStatus points to.
	plmxml_api::Result ResolveReleaseStatusURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from ReleaseStatus array.
	plmxml_api::Result DeleteReleaseStatusURI( int i );

	//! Remove all URIs from ReleaseStatus array.
	plmxml_api::Result DeleteReleaseStatusURIs( );
	
	//! Check if ReleaseStatus is set
	plmxml_api::logical HasReleaseStatusURIs( ) const;

	//! Get SubType of this Managed
	plmxml_api::String GetSubType() const;

	//! Set SubType of this Managed
	plmxml_api::Result SetSubType( const plmxml_api::String &s );
	
	//! Check if SubType is set
	plmxml_api::logical HasSubType( ) const;
	
	//! Unset SubType
	plmxml_api::Result UnsetSubType( );

	//! Get number of URIs in Access
	int NumberOfAccessURIs() const;

	//! Get i'th URI in Access
	plmxml_api::String GetAccessURI( int i ) const;

	//! Add a URI to Access array. Call ResolveAccessURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddAccessURI( const plmxml_api::String& u );

	//! Set i'th URI in Access array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetAccessURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Access URI. Does not resolve the URI.
	plmxml_api::Result GetAccessURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Access array.
	plmxml_api::Result AddAccessURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Access array to point to 'handle'.
	plmxml_api::Result SetAccessURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Access points to.
	plmxml_api::Result ResolveAccessURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Access array.
	plmxml_api::Result DeleteAccessURI( int i );

	//! Remove all URIs from Access array.
	plmxml_api::Result DeleteAccessURIs( );
	
	//! Check if Access is set
	plmxml_api::logical HasAccessURIs( ) const;

	//! Get number of URIs in Checkout
	int NumberOfCheckoutURIs() const;

	//! Get i'th URI in Checkout
	plmxml_api::String GetCheckoutURI( int i ) const;

	//! Add a URI to Checkout array. Call ResolveCheckoutURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddCheckoutURI( const plmxml_api::String& u );

	//! Set i'th URI in Checkout array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetCheckoutURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Checkout URI. Does not resolve the URI.
	plmxml_api::Result GetCheckoutURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Checkout array.
	plmxml_api::Result AddCheckoutURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Checkout array to point to 'handle'.
	plmxml_api::Result SetCheckoutURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Checkout points to.
	plmxml_api::Result ResolveCheckoutURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Checkout array.
	plmxml_api::Result DeleteCheckoutURI( int i );

	//! Remove all URIs from Checkout array.
	plmxml_api::Result DeleteCheckoutURIs( );
	
	//! Check if Checkout is set
	plmxml_api::logical HasCheckoutURIs( ) const;
 
// <PLMXML_UserCode type="functionHeaderManaged" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassManaged;


////////////////////////////////////////////////////////////////////////////////////
//! AccessControl class
/*!
\verbatim

      AccessControl - abstract base class for Access Control types.
      
\endverbatim
*/
class PLMXML60_API AccessControl : public AttribOwner
{
public:
     
    //! Default constructor
    AccessControl( );
     
    //! Constructs a AccessControl with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    AccessControl( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~AccessControl();

private:

	//! Assignment operator
	AccessControl& operator=( const AccessControl& iSrc );

	//! Copy constructor
	AccessControl( const AccessControl& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderAccessControl" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassAccessControl;


////////////////////////////////////////////////////////////////////////////////////
//! Status class
/*!
\verbatim

      Status - abstract base class for status information types.
      
\endverbatim
*/
class PLMXML60_API Status : public AttribOwner
{
public:
     
    //! Default constructor
    Status( );
     
    //! Constructs a Status with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Status( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Status();

private:

	//! Assignment operator
	Status& operator=( const Status& iSrc );

	//! Copy constructor
	Status( const Status& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderStatus" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassStatus;


////////////////////////////////////////////////////////////////////////////////////
//! CheckoutStatus class
/*!
\verbatim

      CheckoutStatus - abstract base class for Checkout types.
      
\endverbatim
*/
class PLMXML60_API CheckoutStatus : public AttribOwner
{
public:
     
    //! Default constructor
    CheckoutStatus( );
     
    //! Constructs a CheckoutStatus with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    CheckoutStatus( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~CheckoutStatus();

private:

	//! Assignment operator
	CheckoutStatus& operator=( const CheckoutStatus& iSrc );

	//! Copy constructor
	CheckoutStatus( const CheckoutStatus& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderCheckoutStatus" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassCheckoutStatus;


////////////////////////////////////////////////////////////////////////////////////
//! InternalRep class
/*!
\verbatim

\endverbatim
*/
class PLMXML60_API InternalRep : public AttribOwner
{
public:
     
    //! Default constructor
    InternalRep( );
     
    //! Constructs a InternalRep with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    InternalRep( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~InternalRep();

private:

	//! Assignment operator
	InternalRep& operator=( const InternalRep& iSrc );

	//! Copy constructor
	InternalRep( const InternalRep& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderInternalRep" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassInternalRep;


////////////////////////////////////////////////////////////////////////////////////
//! EntityObject class
/*!
\verbatim

      Base class for elements which reference an external entity such as a
      face in an XT file.

      Attributes:

      entityRef:     A list of references to external entities.
      
\endverbatim
*/
class PLMXML60_API EntityObject : public AttribOwner
{
public:
     
    //! Default constructor
    EntityObject( );
     
    //! Constructs a EntityObject with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    EntityObject( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~EntityObject();

private:

	//! Assignment operator
	EntityObject& operator=( const EntityObject& iSrc );

	//! Copy constructor
	EntityObject( const EntityObject& original );
     
public:

	//! Get number of URIs in Entity
	int NumberOfEntityURIs() const;

	//! Get i'th URI in Entity
	plmxml_api::String GetEntityURI( int i ) const;

	//! Add a URI to Entity array. Call ResolveEntityURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddEntityURI( const plmxml_api::String& u );

	//! Set i'th URI in Entity array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetEntityURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Entity URI. Does not resolve the URI.
	plmxml_api::Result GetEntityURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Entity array.
	plmxml_api::Result AddEntityURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Entity array to point to 'handle'.
	plmxml_api::Result SetEntityURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Entity points to.
	plmxml_api::Result ResolveEntityURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Entity array.
	plmxml_api::Result DeleteEntityURI( int i );

	//! Remove all URIs from Entity array.
	plmxml_api::Result DeleteEntityURIs( );
	
	//! Check if Entity is set
	plmxml_api::logical HasEntityURIs( ) const;
 
// <PLMXML_UserCode type="functionHeaderEntityObject" >
	//! Get Entity URI as plmxml_api::String
	plmxml_api::String GetEntityURI( ) const;

	//! Set Entity URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetEntityURI( const plmxml_api::String& );

	//! Get the handle of Entity URI. Does not resolve the URI.
	plmxml_api::Result GetEntityURI( plmxml_api::Handle& ) const;

	//! Set the handle of Entity URI. URI string is unchanged.
	plmxml_api::Result SetEntityURI( const plmxml_api::Handle& );

	//! Resolve Entity URI and return an object (handle) it points to.
	plmxml_api::Result ResolveEntityURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Reset Entity URI. Clears URI string and handle.
	plmxml_api::Result DeleteEntityURI( );

	//! Check if Entity URI is set
	plmxml_api::logical HasEntityURI( ) const;
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassEntityObject;


//! Forward class declarations
class PropertyGroup;
class DeterminedPropertyGroup;

////////////////////////////////////////////////////////////////////////////////////
//! Geometry class
/*!
\verbatim

      Base class for elements representing geometric objects.

      Attributes:

      propertyRefs:     reference to Properties of the element
      colour:           Simple colour of the geometry. For complex colour, use
                        the Colour property.
      filled:           Whether closed geometry is filled.
      fillColour:       The fill colour, if the geometry is filled. Otherwise
                        transparent.

      Elements:

      PropertyGroup:    a collection of Properties of the element.
      DeterminedPropertyGroup: The Properties determined by a specific method.
      
\endverbatim
*/
class PLMXML60_API Geometry : public EntityObject
{
public:
     
    //! Default constructor
    Geometry( );
     
    //! Constructs a Geometry with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Geometry( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Geometry();

private:

	//! Assignment operator
	Geometry& operator=( const Geometry& iSrc );

	//! Copy constructor
	Geometry( const Geometry& original );
     
public:

	//! Set Colour array
	plmxml_api::Result SetColour( const double *arg );

	//! Get Colour array
	plmxml_api::Result GetColour( double *arg ) const;

	//! Check if Colour array is set
	plmxml_api::logical HasColour() const;

	//! Unset Colour array
	plmxml_api::Result UnsetColour();

	//! Get number of URIs in Property
	int NumberOfPropertyURIs() const;

	//! Get i'th URI in Property
	plmxml_api::String GetPropertyURI( int i ) const;

	//! Add a URI to Property array. Call ResolvePropertyURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddPropertyURI( const plmxml_api::String& u );

	//! Set i'th URI in Property array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetPropertyURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Property URI. Does not resolve the URI.
	plmxml_api::Result GetPropertyURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Property array.
	plmxml_api::Result AddPropertyURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Property array to point to 'handle'.
	plmxml_api::Result SetPropertyURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Property points to.
	plmxml_api::Result ResolvePropertyURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Property array.
	plmxml_api::Result DeletePropertyURI( int i );

	//! Remove all URIs from Property array.
	plmxml_api::Result DeletePropertyURIs( );
	
	//! Check if Property is set
	plmxml_api::logical HasPropertyURIs( ) const;

	//! Set Filled
	plmxml_api::Result SetFilled( plmxml_api::logical arg );

	//! Get Filled
	plmxml_api::logical GetFilled() const;

	//! Check if Filled is set
	plmxml_api::logical HasFilled() const;

	//! Unset Filled
	plmxml_api::Result UnsetFilled();

	//! Set FillColour array
	plmxml_api::Result SetFillColour( const double *arg );

	//! Get FillColour array
	plmxml_api::Result GetFillColour( double *arg ) const;

	//! Check if FillColour array is set
	plmxml_api::logical HasFillColour() const;

	//! Unset FillColour array
	plmxml_api::Result UnsetFillColour();

	//! Add PropertyGroup child element to this Geometry. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	PropertyGroup *AddPropertyGroup();
     
	//! Set PropertyGroup child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetPropertyGroup( PropertyGroup *arg );
     
	//! Get PropertyGroup child element of this Geometry.
	PropertyGroup *GetPropertyGroup() const;
     
	//! Detach and delete PropertyGroup child element tree from this Geometry.
	void DeletePropertyGroup();

	//! Add DeterminedPropertyGroup child element to this Geometry. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	DeterminedPropertyGroup *AddDeterminedPropertyGroup();
     
	//! Set DeterminedPropertyGroup child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetDeterminedPropertyGroup( DeterminedPropertyGroup *arg );
     
	//! Get DeterminedPropertyGroup child element of this Geometry.
	DeterminedPropertyGroup *GetDeterminedPropertyGroup() const;
     
	//! Detach and delete DeterminedPropertyGroup child element tree from this Geometry.
	void DeleteDeterminedPropertyGroup();
 
// <PLMXML_UserCode type="functionHeaderGeometry" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassGeometry;


////////////////////////////////////////////////////////////////////////////////////
//! Point class
/*!
\verbatim

      Base class for elements representing 3D points.
      
      Attributes:
      
      position:      coordinates of point
      
\endverbatim
*/
class PLMXML60_API Point : public Geometry
{
public:
     
    //! Default constructor
    Point( );
     
    //! Constructs a Point with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Point( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Point();

private:

	//! Assignment operator
	Point& operator=( const Point& iSrc );

	//! Copy constructor
	Point( const Point& original );
     
public:

	//! Set Position using plmxml_api::Vector components
	plmxml_api::Result SetPosition( const plmxml_api::Vector& arg );

	//! Get Position as plmxml_api::Vector
	plmxml_api::Result GetPosition( plmxml_api::Vector& arg ) const;

	//! Check if Position is set
	plmxml_api::logical HasPosition() const;

	//! Unset Position
	plmxml_api::Result UnsetPosition();
 
// <PLMXML_UserCode type="functionHeaderPoint" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassPoint;


////////////////////////////////////////////////////////////////////////////////////
//! ReferencePoint class
/*!
\verbatim

\endverbatim
*/
class PLMXML60_API ReferencePoint : public EntityObject
{
public:
     
    //! Default constructor
    ReferencePoint( );
     
    //! Constructs a ReferencePoint with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ReferencePoint( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ReferencePoint();

private:

	//! Assignment operator
	ReferencePoint& operator=( const ReferencePoint& iSrc );

	//! Copy constructor
	ReferencePoint( const ReferencePoint& original );
     
public:

	//! Set Position using plmxml_api::Vector components
	plmxml_api::Result SetPosition( const plmxml_api::Vector& arg );

	//! Get Position as plmxml_api::Vector
	plmxml_api::Result GetPosition( plmxml_api::Vector& arg ) const;

	//! Check if Position is set
	plmxml_api::logical HasPosition() const;

	//! Unset Position
	plmxml_api::Result UnsetPosition();
 
// <PLMXML_UserCode type="functionHeaderReferencePoint" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassReferencePoint;


////////////////////////////////////////////////////////////////////////////////////
//! SamplePoints class
/*!
\verbatim

\endverbatim
*/
class PLMXML60_API SamplePoints : public plmxml_api::Object
{
public:
     
    //! Default constructor
    SamplePoints( );
     
    //! Constructs a SamplePoints with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    SamplePoints( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~SamplePoints();

private:

	//! Assignment operator
	SamplePoints& operator=( const SamplePoints& iSrc );

	//! Copy constructor
	SamplePoints( const SamplePoints& original );
     
public:

	//! Set Tolerance
	plmxml_api::Result SetTolerance( double arg );

     //! Get Tolerance
	double GetTolerance() const;

	//! Check if Tolerance is set
	plmxml_api::logical HasTolerance() const;

	//! Unset Tolerance
	plmxml_api::Result UnsetTolerance();
 
// <PLMXML_UserCode type="functionHeaderSamplePoints" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassSamplePoints;


////////////////////////////////////////////////////////////////////////////////////
//! Curve class
/*!
\verbatim

      Base class for elements representing parametrised curves in 3-space.
      
      Attributes:
      
      startT:        start parameter
      endT:          end parameter
      
      Elements:
      
      StartPoint:    optional coordinates of start point
      EndPoint:      optional coordinates of end point
      SamplePoints:  optional coordinates of a sequence of points along curve
      
\endverbatim
*/
class PLMXML60_API Curve : public Geometry
{
public:
     
    //! Default constructor
    Curve( );
     
    //! Constructs a Curve with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Curve( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Curve();

private:

	//! Assignment operator
	Curve& operator=( const Curve& iSrc );

	//! Copy constructor
	Curve( const Curve& original );
     
public:

	//! Set StartT
	plmxml_api::Result SetStartT( double arg );

     //! Get StartT
	double GetStartT() const;

	//! Check if StartT is set
	plmxml_api::logical HasStartT() const;

	//! Unset StartT
	plmxml_api::Result UnsetStartT();

	//! Set EndT
	plmxml_api::Result SetEndT( double arg );

     //! Get EndT
	double GetEndT() const;

	//! Check if EndT is set
	plmxml_api::logical HasEndT() const;

	//! Unset EndT
	plmxml_api::Result UnsetEndT();

	//! Add StartPoint child element to this Curve. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	ReferencePoint *AddStartPoint();
     
	//! Set StartPoint child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetStartPoint( ReferencePoint *arg );
     
	//! Get StartPoint child element of this Curve.
	ReferencePoint *GetStartPoint() const;
     
	//! Detach and delete StartPoint child element tree from this Curve.
	void DeleteStartPoint();

	//! Add EndPoint child element to this Curve. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	ReferencePoint *AddEndPoint();
     
	//! Set EndPoint child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetEndPoint( ReferencePoint *arg );
     
	//! Get EndPoint child element of this Curve.
	ReferencePoint *GetEndPoint() const;
     
	//! Detach and delete EndPoint child element tree from this Curve.
	void DeleteEndPoint();

	//! Add SamplePoints child element to this Curve. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	SamplePoints *AddSamplePoints();
     
	//! Set SamplePoints child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetSamplePoints( SamplePoints *arg );
     
	//! Get SamplePoints child element of this Curve.
	SamplePoints *GetSamplePoints() const;
     
	//! Detach and delete SamplePoints child element tree from this Curve.
	void DeleteSamplePoints();
 
// <PLMXML_UserCode type="functionHeaderCurve" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassCurve;


////////////////////////////////////////////////////////////////////////////////////
//! PlaneCurve class
/*!
\verbatim

      Base class for 3D curves which lie in a plane.
      
      Attributes:
      
      origin:        centre of plane
      zAxis:         normal to plane
      xAxis:         x-direction in plane
      
\endverbatim
*/
class PLMXML60_API PlaneCurve : public Curve
{
public:
     
    //! Default constructor
    PlaneCurve( );
     
    //! Constructs a PlaneCurve with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    PlaneCurve( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~PlaneCurve();

private:

	//! Assignment operator
	PlaneCurve& operator=( const PlaneCurve& iSrc );

	//! Copy constructor
	PlaneCurve( const PlaneCurve& original );
     
public:

	//! Set Origin using plmxml_api::Vector components
	plmxml_api::Result SetOrigin( const plmxml_api::Vector& arg );

	//! Get Origin as plmxml_api::Vector
	plmxml_api::Result GetOrigin( plmxml_api::Vector& arg ) const;

	//! Check if Origin is set
	plmxml_api::logical HasOrigin() const;

	//! Unset Origin
	plmxml_api::Result UnsetOrigin();

	//! Set XAxis using plmxml_api::Vector components
	plmxml_api::Result SetXAxis( const plmxml_api::Vector& arg );

	//! Get XAxis as plmxml_api::Vector
	plmxml_api::Result GetXAxis( plmxml_api::Vector& arg ) const;

	//! Check if XAxis is set
	plmxml_api::logical HasXAxis() const;

	//! Unset XAxis
	plmxml_api::Result UnsetXAxis();

	//! Set ZAxis using plmxml_api::Vector components
	plmxml_api::Result SetZAxis( const plmxml_api::Vector& arg );

	//! Get ZAxis as plmxml_api::Vector
	plmxml_api::Result GetZAxis( plmxml_api::Vector& arg ) const;

	//! Check if ZAxis is set
	plmxml_api::logical HasZAxis() const;

	//! Unset ZAxis
	plmxml_api::Result UnsetZAxis();
 
// <PLMXML_UserCode type="functionHeaderPlaneCurve" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassPlaneCurve;


////////////////////////////////////////////////////////////////////////////////////
//! Surface class
/*!
\verbatim

      Base class for elements representing a u-v-parametrised surface in 3-space. 
      
      Attributes:
      
      startU:        lowest U value
      endU:          highest U value
      startV:        lowest V value
      endV:          highest V value
      
      Elements:
      
      SamplePoints:  optional coordinates of a set of points on the surface
      
\endverbatim
*/
class PLMXML60_API Surface : public Geometry
{
public:
     
    //! Default constructor
    Surface( );
     
    //! Constructs a Surface with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Surface( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Surface();

private:

	//! Assignment operator
	Surface& operator=( const Surface& iSrc );

	//! Copy constructor
	Surface( const Surface& original );
     
public:

	//! Set EndV
	plmxml_api::Result SetEndV( double arg );

     //! Get EndV
	double GetEndV() const;

	//! Check if EndV is set
	plmxml_api::logical HasEndV() const;

	//! Unset EndV
	plmxml_api::Result UnsetEndV();

	//! Set StartV
	plmxml_api::Result SetStartV( double arg );

     //! Get StartV
	double GetStartV() const;

	//! Check if StartV is set
	plmxml_api::logical HasStartV() const;

	//! Unset StartV
	plmxml_api::Result UnsetStartV();

	//! Set StartU
	plmxml_api::Result SetStartU( double arg );

     //! Get StartU
	double GetStartU() const;

	//! Check if StartU is set
	plmxml_api::logical HasStartU() const;

	//! Unset StartU
	plmxml_api::Result UnsetStartU();

	//! Set EndU
	plmxml_api::Result SetEndU( double arg );

     //! Get EndU
	double GetEndU() const;

	//! Check if EndU is set
	plmxml_api::logical HasEndU() const;

	//! Unset EndU
	plmxml_api::Result UnsetEndU();

	//! Add SamplePoints child element to this Surface. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	SamplePoints *AddSamplePoints();
     
	//! Set SamplePoints child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetSamplePoints( SamplePoints *arg );
     
	//! Get SamplePoints child element of this Surface.
	SamplePoints *GetSamplePoints() const;
     
	//! Detach and delete SamplePoints child element tree from this Surface.
	void DeleteSamplePoints();
 
// <PLMXML_UserCode type="functionHeaderSurface" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassSurface;


////////////////////////////////////////////////////////////////////////////////////
//! SurfacePosition class
/*!
\verbatim

      Base class for elements representing a surface which uses an
      X-Y-Z coordinate frame as part of its definition.
      
      Attributes:
      
      origin:        origin of coordinate frame
      zAxis:         Z Axis of coordinate frame
      xAxis:         X Axis of coordinate frame
      
\endverbatim
*/
class PLMXML60_API SurfacePosition : public Surface
{
public:
     
    //! Default constructor
    SurfacePosition( );
     
    //! Constructs a SurfacePosition with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    SurfacePosition( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~SurfacePosition();

private:

	//! Assignment operator
	SurfacePosition& operator=( const SurfacePosition& iSrc );

	//! Copy constructor
	SurfacePosition( const SurfacePosition& original );
     
public:

	//! Set Origin using plmxml_api::Vector components
	plmxml_api::Result SetOrigin( const plmxml_api::Vector& arg );

	//! Get Origin as plmxml_api::Vector
	plmxml_api::Result GetOrigin( plmxml_api::Vector& arg ) const;

	//! Check if Origin is set
	plmxml_api::logical HasOrigin() const;

	//! Unset Origin
	plmxml_api::Result UnsetOrigin();

	//! Set XAxis using plmxml_api::Vector components
	plmxml_api::Result SetXAxis( const plmxml_api::Vector& arg );

	//! Get XAxis as plmxml_api::Vector
	plmxml_api::Result GetXAxis( plmxml_api::Vector& arg ) const;

	//! Check if XAxis is set
	plmxml_api::logical HasXAxis() const;

	//! Unset XAxis
	plmxml_api::Result UnsetXAxis();

	//! Set ZAxis using plmxml_api::Vector components
	plmxml_api::Result SetZAxis( const plmxml_api::Vector& arg );

	//! Get ZAxis as plmxml_api::Vector
	plmxml_api::Result GetZAxis( plmxml_api::Vector& arg ) const;

	//! Check if ZAxis is set
	plmxml_api::logical HasZAxis() const;

	//! Unset ZAxis
	plmxml_api::Result UnsetZAxis();
 
// <PLMXML_UserCode type="functionHeaderSurfacePosition" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassSurfacePosition;


////////////////////////////////////////////////////////////////////////////////////
//! Material class
/*!
\verbatim

      Element representing a material type.
      
      Attributes:
      
      ambient:       ambient colour
      diffuse:       diffuse colour
      specular:      specular colour
      emissive:      emissive colour
      shininess:     shininess coefficient
      alpha:         alpha coefficient
      
\endverbatim
*/
class PLMXML60_API Material : public AttribOwner
{
public:
     
    //! Default constructor
    Material( );
     
    //! Constructs a Material with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Material( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Material();

private:

	//! Assignment operator
	Material& operator=( const Material& iSrc );

	//! Copy constructor
	Material( const Material& original );
     
public:

	//! Set Diffuse array
	plmxml_api::Result SetDiffuse( const double *arg );

	//! Get Diffuse array
	plmxml_api::Result GetDiffuse( double *arg ) const;

	//! Check if Diffuse array is set
	plmxml_api::logical HasDiffuse() const;

	//! Unset Diffuse array
	plmxml_api::Result UnsetDiffuse();

	//! Set Shininess
	plmxml_api::Result SetShininess( double arg );

     //! Get Shininess
	double GetShininess() const;

	//! Check if Shininess is set
	plmxml_api::logical HasShininess() const;

	//! Unset Shininess
	plmxml_api::Result UnsetShininess();

	//! Set Ambient array
	plmxml_api::Result SetAmbient( const double *arg );

	//! Get Ambient array
	plmxml_api::Result GetAmbient( double *arg ) const;

	//! Check if Ambient array is set
	plmxml_api::logical HasAmbient() const;

	//! Unset Ambient array
	plmxml_api::Result UnsetAmbient();

	//! Set Alpha
	plmxml_api::Result SetAlpha( double arg );

     //! Get Alpha
	double GetAlpha() const;

	//! Check if Alpha is set
	plmxml_api::logical HasAlpha() const;

	//! Unset Alpha
	plmxml_api::Result UnsetAlpha();

	//! Set Emissive array
	plmxml_api::Result SetEmissive( const double *arg );

	//! Get Emissive array
	plmxml_api::Result GetEmissive( double *arg ) const;

	//! Check if Emissive array is set
	plmxml_api::logical HasEmissive() const;

	//! Unset Emissive array
	plmxml_api::Result UnsetEmissive();

	//! Set Specular array
	plmxml_api::Result SetSpecular( const double *arg );

	//! Get Specular array
	plmxml_api::Result GetSpecular( double *arg ) const;

	//! Check if Specular array is set
	plmxml_api::logical HasSpecular() const;

	//! Unset Specular array
	plmxml_api::Result UnsetSpecular();
 
// <PLMXML_UserCode type="functionHeaderMaterial" >
    //! Return true if material matches rgb values...
	/*! 
	Returns true if ambient and diffuse fields match the given values,
	if specular is (1,1,1), emissive is (0,0,0), shininess is 80 and 
	alpha is 1.
	*/
	plmxml_api::logical EqualTo( double* rgb ) const;

	//! Sets the material given an rgb value...
	/*!
	Sets the ambient and diffuse fields to the given values, sets the
	specular field to (1,1,1), emissive to (0,0,0), shininess to 80 and
	alpha to 1.
	*/
	void Initialise( double rgb[3] );

	//! Copies the settings of the supplied material....
	void Initialise( const Material& material );
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassMaterial;


//! Forward class declarations
class EntityRef;

////////////////////////////////////////////////////////////////////////////////////
//! EntityMaterial class
/*!
\verbatim

      Element used to associate an entity with a material (colour).

      Attributes:

      materialRef:      IDREF to the material element.
      propertyRefs:     References a Colour as an alternative to materialRef
                        referencing a Material.

      Elements:

      EntityRef:        Element derived from EntityRef, used to specify which
                        entity is to be associated with the material.
      
\endverbatim
*/
class PLMXML60_API EntityMaterial : public AttribOwner
{
public:
     
    //! Default constructor
    EntityMaterial( );
     
    //! Constructs a EntityMaterial with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    EntityMaterial( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~EntityMaterial();

private:

	//! Assignment operator
	EntityMaterial& operator=( const EntityMaterial& iSrc );

	//! Copy constructor
	EntityMaterial( const EntityMaterial& original );
     
public:

	//! Set reference to Material using 'arg's plmxml_api::Id.
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical SetMaterialRef( plmxml60::IdObject *arg );

	//! Clear reference to Material
	void RemoveMaterialRef( );

	//! Find a plmxml60::IdObject referenced by Material
	plmxml60::IdObject *ResolveMaterialRef( plmxml_api::Configuration* config = NULL );

	//! Get Material reference
	plmxml_api::String GetMaterialId() const;

	//! Set Material reference.
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical SetMaterialId( const plmxml_api::String& u );
	
	//! Check if Material is set
	plmxml_api::logical HasMaterialRef( ) const;

	//! Get number of URIs in Property
	int NumberOfPropertyURIs() const;

	//! Get i'th URI in Property
	plmxml_api::String GetPropertyURI( int i ) const;

	//! Add a URI to Property array. Call ResolvePropertyURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddPropertyURI( const plmxml_api::String& u );

	//! Set i'th URI in Property array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetPropertyURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Property URI. Does not resolve the URI.
	plmxml_api::Result GetPropertyURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Property array.
	plmxml_api::Result AddPropertyURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Property array to point to 'handle'.
	plmxml_api::Result SetPropertyURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Property points to.
	plmxml_api::Result ResolvePropertyURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Property array.
	plmxml_api::Result DeletePropertyURI( int i );

	//! Remove all URIs from Property array.
	plmxml_api::Result DeletePropertyURIs( );
	
	//! Check if Property is set
	plmxml_api::logical HasPropertyURIs( ) const;

	//! Add EntityRef child element to this EntityMaterial. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	EntityRef *AddEntityRef();
     
	//! Add 'arg' as EntityRef child element to this EntityMaterial.
	plmxml_api::Result AddEntityRef( EntityRef *arg );

	//! Detach and delete all EntityRef child elements.
	void DeleteEntityRefs();
     
	//! Get number of EntityRef child elements.
	int NumberOfEntityRefs() const;
     
	//! Get i'th EntityRef child element.
	EntityRef *GetEntityRef( int i ) const;
     
	//! Get all EntityRef child element as an array
	void GetEntityRefs( plmxml_api::Array<EntityRef*> &array ) const;
	     
	//! Detach and delete i'th EntityRef child element
	void DeleteEntityRef( int i );
     
	//! Detach and delete 'arg' if it's one of the EntityRef child elements
	void DeleteEntityRef( EntityRef *arg );
 
// <PLMXML_UserCode type="functionHeaderEntityMaterial" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassEntityMaterial;


////////////////////////////////////////////////////////////////////////////////////
//! LightSource class
/*!
\verbatim

      Base class for elements representing Light Sources
      
      Attributes:
      
      ambient:       ambient light
      diffuse:       diffuse light
      specular:      specular light
      intensity:     intensity multiplier
      
\endverbatim
*/
class PLMXML60_API LightSource : public AttribOwner
{
public:
     
    //! Default constructor
    LightSource( );
     
    //! Constructs a LightSource with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    LightSource( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~LightSource();

private:

	//! Assignment operator
	LightSource& operator=( const LightSource& iSrc );

	//! Copy constructor
	LightSource( const LightSource& original );
     
public:

	//! Set Ambient array
	plmxml_api::Result SetAmbient( const double *arg );

	//! Get Ambient array
	plmxml_api::Result GetAmbient( double *arg ) const;

	//! Check if Ambient array is set
	plmxml_api::logical HasAmbient() const;

	//! Unset Ambient array
	plmxml_api::Result UnsetAmbient();

	//! Set Diffuse array
	plmxml_api::Result SetDiffuse( const double *arg );

	//! Get Diffuse array
	plmxml_api::Result GetDiffuse( double *arg ) const;

	//! Check if Diffuse array is set
	plmxml_api::logical HasDiffuse() const;

	//! Unset Diffuse array
	plmxml_api::Result UnsetDiffuse();

	//! Set Intensity
	plmxml_api::Result SetIntensity( double arg );

     //! Get Intensity
	double GetIntensity() const;

	//! Check if Intensity is set
	plmxml_api::logical HasIntensity() const;

	//! Unset Intensity
	plmxml_api::Result UnsetIntensity();

	//! Set Specular array
	plmxml_api::Result SetSpecular( const double *arg );

	//! Get Specular array
	plmxml_api::Result GetSpecular( double *arg ) const;

	//! Check if Specular array is set
	plmxml_api::logical HasSpecular() const;

	//! Unset Specular array
	plmxml_api::Result UnsetSpecular();
 
// <PLMXML_UserCode type="functionHeaderLightSource" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassLightSource;


////////////////////////////////////////////////////////////////////////////////////
//! DirectionalLight class
/*!
\verbatim

      Directional Light Source (from infinity)
      
      Attributes:
      
      direction:     direction TO the light source.
      
\endverbatim
*/
class PLMXML60_API DirectionalLight : public LightSource
{
public:
     
    //! Default constructor
    DirectionalLight( );
     
    //! Constructs a DirectionalLight with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    DirectionalLight( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~DirectionalLight();

private:

	//! Assignment operator
	DirectionalLight& operator=( const DirectionalLight& iSrc );

	//! Copy constructor
	DirectionalLight( const DirectionalLight& original );
     
public:

	//! Set Direction using plmxml_api::Vector components
	plmxml_api::Result SetDirection( const plmxml_api::Vector& arg );

	//! Get Direction as plmxml_api::Vector
	plmxml_api::Result GetDirection( plmxml_api::Vector& arg ) const;

	//! Check if Direction is set
	plmxml_api::logical HasDirection() const;

	//! Unset Direction
	plmxml_api::Result UnsetDirection();
 
// <PLMXML_UserCode type="functionHeaderDirectionalLight" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassDirectionalLight;


////////////////////////////////////////////////////////////////////////////////////
//! PositionalLight class
/*!
\verbatim

      Positional Light Source, i.e. point source.
      
      Attributes:
      
      position:      position of light
      direction:     direction in which the light is shining
      cutoffAngle:   semiAngle of cone of light. If absent, the source is not
                     a spotlight, but shines in all directions.
      intensityExponent:  the intensity exponent determines the intensity distribution
                     within the cone. Higher intensity exponent values result in a more
                     focused light source. 
      attenuation:   the attenuation of the light source within the scene. The three
                     attenuation values are the factors in a quadratic equation, giving
                     intensity as a function of distance from the source. The values
                     within the attribute are in order: quadratic, linear and constant.
      
\endverbatim
*/
class PLMXML60_API PositionalLight : public LightSource
{
public:
     
    //! Default constructor
    PositionalLight( );
     
    //! Constructs a PositionalLight with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    PositionalLight( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~PositionalLight();

private:

	//! Assignment operator
	PositionalLight& operator=( const PositionalLight& iSrc );

	//! Copy constructor
	PositionalLight( const PositionalLight& original );
     
public:

	//! Set CutoffAngle
	plmxml_api::Result SetCutoffAngle( double arg );

     //! Get CutoffAngle
	double GetCutoffAngle() const;

	//! Check if CutoffAngle is set
	plmxml_api::logical HasCutoffAngle() const;

	//! Unset CutoffAngle
	plmxml_api::Result UnsetCutoffAngle();

	//! Set Attenuation array
	plmxml_api::Result SetAttenuation( const double *arg );

	//! Get Attenuation array
	plmxml_api::Result GetAttenuation( double *arg ) const;

	//! Check if Attenuation array is set
	plmxml_api::logical HasAttenuation() const;

	//! Unset Attenuation array
	plmxml_api::Result UnsetAttenuation();

	//! Set Direction using plmxml_api::Vector components
	plmxml_api::Result SetDirection( const plmxml_api::Vector& arg );

	//! Get Direction as plmxml_api::Vector
	plmxml_api::Result GetDirection( plmxml_api::Vector& arg ) const;

	//! Check if Direction is set
	plmxml_api::logical HasDirection() const;

	//! Unset Direction
	plmxml_api::Result UnsetDirection();

	//! Set IntensityExponent
	plmxml_api::Result SetIntensityExponent( double arg );

     //! Get IntensityExponent
	double GetIntensityExponent() const;

	//! Check if IntensityExponent is set
	plmxml_api::logical HasIntensityExponent() const;

	//! Unset IntensityExponent
	plmxml_api::Result UnsetIntensityExponent();

	//! Set Position using plmxml_api::Vector components
	plmxml_api::Result SetPosition( const plmxml_api::Vector& arg );

	//! Get Position as plmxml_api::Vector
	plmxml_api::Result GetPosition( plmxml_api::Vector& arg ) const;

	//! Check if Position is set
	plmxml_api::logical HasPosition() const;

	//! Unset Position
	plmxml_api::Result UnsetPosition();
 
// <PLMXML_UserCode type="functionHeaderPositionalLight" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassPositionalLight;


////////////////////////////////////////////////////////////////////////////////////
//! DisplayControl class
/*!
\verbatim

      Controls display parameters of the referencing element.

      Attributes:

      drawingStyle:             The drawing style.
      shadingStyle:             The shading style if the drawing style is shaded.
      backgroundColour:         The background colour. The BackgroundColour
                                sub-elements under any ViewPort take precedence
                                over this backgroundColour attribute.
      lightSourceRefs:          A list of references to light sources.
      edgeColour:               The colour of edges if they are displayed
                                explicitly, for example when drawingStyle is
                                wireframe or shadedWithEdges.
      edgeColourFromBody:       Whether the colour of edges is determined from
                                the colour of bodies. If true, edgeColour is
                                ignored.
      
\endverbatim
*/
class PLMXML60_API DisplayControl : public AttribOwner
{
public:
     
    //! Default constructor
    DisplayControl( );
     
    //! Constructs a DisplayControl with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    DisplayControl( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~DisplayControl();

private:

	//! Assignment operator
	DisplayControl& operator=( const DisplayControl& iSrc );

	//! Copy constructor
	DisplayControl( const DisplayControl& original );
     
public:

	//! Set ShadingStyle
	plmxml_api::Result SetShadingStyle( const eShadingStyleType& arg );

	//! Get ShadingStyle
	eShadingStyleType GetShadingStyle() const;

	//! Set EdgeColourFromBody
	plmxml_api::Result SetEdgeColourFromBody( plmxml_api::logical arg );

	//! Get EdgeColourFromBody
	plmxml_api::logical GetEdgeColourFromBody() const;

	//! Check if EdgeColourFromBody is set
	plmxml_api::logical HasEdgeColourFromBody() const;

	//! Unset EdgeColourFromBody
	plmxml_api::Result UnsetEdgeColourFromBody();

	//! Set EdgeColour array
	plmxml_api::Result SetEdgeColour( const double *arg );

	//! Get EdgeColour array
	plmxml_api::Result GetEdgeColour( double *arg ) const;

	//! Check if EdgeColour array is set
	plmxml_api::logical HasEdgeColour() const;

	//! Unset EdgeColour array
	plmxml_api::Result UnsetEdgeColour();

	//! Set DrawingStyle
	plmxml_api::Result SetDrawingStyle( const eDrawingStyleType& arg );

	//! Get DrawingStyle
	eDrawingStyleType GetDrawingStyle() const;

	//! Get number of references in LightSource array
	int NumberOfLightSourceRefs() const;
     
	//! Add reference to 'arg' to LightSource array
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical AddLightSourceRef( plmxml60::IdObject *arg );
     
	//! Add reference to an object pointed to by 'u' to LightSource array
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical AddLightSourceId( const plmxml_api::String &u );
     
	//! Set i'th reference in LightSource array to 'arg'
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical SetLightSourceRef( int i, plmxml60::IdObject *arg );
     
	//! Set i'th reference in LightSource array to an object pointed to by 'u'
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical SetLightSourceId( int i, const plmxml_api::String &u );
     
	//! Resolve i'th reference in LightSource array and return an object it points to.
	plmxml60::IdObject *ResolveLightSourceRef( int i, plmxml_api::Configuration* config = NULL );
     
	//! Resolve all references in LightSource array and return objects they point to.
	void ResolveLightSourceRefs( plmxml_api::Array<plmxml60::IdObject *> & array, plmxml_api::Configuration* config = NULL );
     
	//! Get i'th reference in LightSource array as plmxml_api::String
	plmxml_api::String GetLightSourceId( int i ) const;
     
	//! Get all references in LightSource array as an array of plmxml_api::String
	void GetLightSourceIds( plmxml_api::Array<plmxml_api::String> &array ) const;
     
	//! Remove i'th reference from the LightSource array.
	void RemoveLightSourceRef( int i );
     
	//! Remove reference to an object pointed to by 'u' from the LightSource array.
	void RemoveLightSourceRef( const plmxml_api::String &u );
     
	//! Remove reference to 'arg' from the LightSource array.
	void RemoveLightSourceRef( plmxml60::IdObject *arg );
     
	//! Remove all references LightSource array.
	void RemoveLightSourceRefs();
	
	//! Check if LightSource is set
	plmxml_api::logical HasLightSourceRefs( ) const;

	//! Set BackgroundColour array
	plmxml_api::Result SetBackgroundColour( const double *arg );

	//! Get BackgroundColour array
	plmxml_api::Result GetBackgroundColour( double *arg ) const;

	//! Check if BackgroundColour array is set
	plmxml_api::logical HasBackgroundColour() const;

	//! Unset BackgroundColour array
	plmxml_api::Result UnsetBackgroundColour();
 
// <PLMXML_UserCode type="functionHeaderDisplayControl" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassDisplayControl;


//! Forward class declarations
class GDEReference;

////////////////////////////////////////////////////////////////////////////////////
//! Section class
/*!
\verbatim

      Section definition of a View, i.e. cutter geometry.

      Attributes:

      geometryRef:      A reference to an object defining section geometry,
                        which is expected to be a surface or a solid, for
                        example - construction geometry element derived from
                        SurfaceBase or (an Occurrence of) geometry stored
                        in a Representation stream.
      type:             Whether the section is generated from the graphical
                        representation of a model. The default is to generate it
                        from the model geometry.
      curveRefs:        References the curves that result from the cut.
      componentRefs:    References the model entities that are cut.
      display:          The display type of the section.
      render:           The render mode of the section. Currently only wireframe
                        and shaded are supported.
      capDisplay:       Whether the face resulting from the cut is displayed.
      capColour:        The colour of the face resulting from the cut.
      curvesDisplay:    Whether the curves resulting from the cut are displayed.
      curvesColour:     The colour of the curves resulting from the cut.
      geometryType:     When a section is generated from the graphical
                        representation of a model, geometryType describes the
                        set of geometry(s) performing the cut(s).
      crosshatchRef:    References a Crosshatch element that holds the
                        crosshatch parameters of the Section. The pattern
                        determined by crosshatchRef is overridden by that
                        determined by hatchByMaterial. If no material is
                        assigned, the pattern defaults to being determined via
                        crosshatchRef. If crosshatchRef is absent and
                        hatchByMaterial is false, the Section is not
                        crosshatched.
      hatchByMaterial:  Whether the crosshatch pattern of a body in a
                        lightweight section is determined by its material type.
                        The pattern determined by hatchByMaterial overrides that
                        determined by crosshatchRef. If hatchByMaterial is false
                        and crosshatchRef is absent, the Section is not
                        crosshatched.
      defaultMaterialPatternRef: References the CrosshatchPatternDefinition
                        applicable when the MaterialSpecification assigned to
                        the referenced components has no pattern.
      nameFromCps:      Whether the name of the Section derives from the
                        CuttingPlaneSymbol referenced via geometryRef.
      hatchColour:      The colour of the crosshatch resulting from the cut.
      removeCoincidentEntities: Whether entities coincident with the section
                        geometry are removed.
      capColourFromBody: Whether the colour of the face resulting from the cut
                        is determined from the body. If true, capColour is
                        ignored.
      curvesColourFromBody: Whether the colour of the curves resulting from the
                        cut is determined from the body. If true, curvesColour
                        is ignored.
      clipWireframeEntities: Whether wireframe entities lying within the section
                        geometry are removed from the view.
      assemblyCrosshatchMethod: How the consuming application should vary the
                        crosshatch angle between adjacent components of an
                        assembly to provide better visualization.
      assemblyCrosshatchAdjacency: The separation in metres below which
                        components of an assembly are considered adjacent.

      Sub-elements:

      Reference:        Similar to componentRefs. Allows references to model
                        entities in particular occurrences.
      
\endverbatim
*/
class PLMXML60_API Section : public AttribOwner
{
public:
     
    //! Default constructor
    Section( );
     
    //! Constructs a Section with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Section( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Section();

private:

	//! Assignment operator
	Section& operator=( const Section& iSrc );

	//! Copy constructor
	Section( const Section& original );
     
public:

	//! Set AssemblyCrosshatchMethod
	plmxml_api::Result SetAssemblyCrosshatchMethod( const eAssemblyCrosshatchEnum& arg );

	//! Get AssemblyCrosshatchMethod
	eAssemblyCrosshatchEnum GetAssemblyCrosshatchMethod() const;

	//! Set Type
	plmxml_api::Result SetType( const eSectionEnum& arg );

	//! Get Type
	eSectionEnum GetType() const;

	//! Set CapDisplay
	plmxml_api::Result SetCapDisplay( plmxml_api::logical arg );

	//! Get CapDisplay
	plmxml_api::logical GetCapDisplay() const;

	//! Check if CapDisplay is set
	plmxml_api::logical HasCapDisplay() const;

	//! Unset CapDisplay
	plmxml_api::Result UnsetCapDisplay();

	//! Set CurvesColour array
	plmxml_api::Result SetCurvesColour( const double *arg );

	//! Get CurvesColour array
	plmxml_api::Result GetCurvesColour( double *arg ) const;

	//! Check if CurvesColour array is set
	plmxml_api::logical HasCurvesColour() const;

	//! Unset CurvesColour array
	plmxml_api::Result UnsetCurvesColour();

	//! Set HatchColour array
	plmxml_api::Result SetHatchColour( const double *arg );

	//! Get HatchColour array
	plmxml_api::Result GetHatchColour( double *arg ) const;

	//! Check if HatchColour array is set
	plmxml_api::logical HasHatchColour() const;

	//! Unset HatchColour array
	plmxml_api::Result UnsetHatchColour();

	//! Get Crosshatch URI as plmxml_api::String
	plmxml_api::String GetCrosshatchURI() const;

	//! Set Crosshatch URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetCrosshatchURI( const plmxml_api::String& );
	
	//! Get the handle of Crosshatch URI. Does not resolve the URI.
	plmxml_api::Result GetCrosshatchURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Crosshatch URI. URI string is unchanged.
	plmxml_api::Result SetCrosshatchURI( const plmxml_api::Handle& );
	
	//! Resolve Crosshatch URI and return an object (handle) it points to.
	plmxml_api::Result ResolveCrosshatchURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Crosshatch URI. Clears URI string and handle.
	plmxml_api::Result DeleteCrosshatchURI();
	
	//! Check if Crosshatch URI is set
	plmxml_api::logical HasCrosshatchURI( ) const;
	

	//! Set RemoveCoincidentEntities
	plmxml_api::Result SetRemoveCoincidentEntities( plmxml_api::logical arg );

	//! Get RemoveCoincidentEntities
	plmxml_api::logical GetRemoveCoincidentEntities() const;

	//! Check if RemoveCoincidentEntities is set
	plmxml_api::logical HasRemoveCoincidentEntities() const;

	//! Unset RemoveCoincidentEntities
	plmxml_api::Result UnsetRemoveCoincidentEntities();

	//! Get Geometry URI as plmxml_api::String
	plmxml_api::String GetGeometryURI() const;

	//! Set Geometry URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetGeometryURI( const plmxml_api::String& );
	
	//! Get the handle of Geometry URI. Does not resolve the URI.
	plmxml_api::Result GetGeometryURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Geometry URI. URI string is unchanged.
	plmxml_api::Result SetGeometryURI( const plmxml_api::Handle& );
	
	//! Resolve Geometry URI and return an object (handle) it points to.
	plmxml_api::Result ResolveGeometryURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Geometry URI. Clears URI string and handle.
	plmxml_api::Result DeleteGeometryURI();
	
	//! Check if Geometry URI is set
	plmxml_api::logical HasGeometryURI( ) const;
	

	//! Set HatchByMaterial
	plmxml_api::Result SetHatchByMaterial( plmxml_api::logical arg );

	//! Get HatchByMaterial
	plmxml_api::logical GetHatchByMaterial() const;

	//! Check if HatchByMaterial is set
	plmxml_api::logical HasHatchByMaterial() const;

	//! Unset HatchByMaterial
	plmxml_api::Result UnsetHatchByMaterial();

	//! Get number of URIs in Component
	int NumberOfComponentURIs() const;

	//! Get i'th URI in Component
	plmxml_api::String GetComponentURI( int i ) const;

	//! Add a URI to Component array. Call ResolveComponentURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddComponentURI( const plmxml_api::String& u );

	//! Set i'th URI in Component array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetComponentURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Component URI. Does not resolve the URI.
	plmxml_api::Result GetComponentURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Component array.
	plmxml_api::Result AddComponentURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Component array to point to 'handle'.
	plmxml_api::Result SetComponentURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Component points to.
	plmxml_api::Result ResolveComponentURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Component array.
	plmxml_api::Result DeleteComponentURI( int i );

	//! Remove all URIs from Component array.
	plmxml_api::Result DeleteComponentURIs( );
	
	//! Check if Component is set
	plmxml_api::logical HasComponentURIs( ) const;

	//! Get number of URIs in Curve
	int NumberOfCurveURIs() const;

	//! Get i'th URI in Curve
	plmxml_api::String GetCurveURI( int i ) const;

	//! Add a URI to Curve array. Call ResolveCurveURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddCurveURI( const plmxml_api::String& u );

	//! Set i'th URI in Curve array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetCurveURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Curve URI. Does not resolve the URI.
	plmxml_api::Result GetCurveURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Curve array.
	plmxml_api::Result AddCurveURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Curve array to point to 'handle'.
	plmxml_api::Result SetCurveURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Curve points to.
	plmxml_api::Result ResolveCurveURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Curve array.
	plmxml_api::Result DeleteCurveURI( int i );

	//! Remove all URIs from Curve array.
	plmxml_api::Result DeleteCurveURIs( );
	
	//! Check if Curve is set
	plmxml_api::logical HasCurveURIs( ) const;

	//! Set CapColourFromBody
	plmxml_api::Result SetCapColourFromBody( plmxml_api::logical arg );

	//! Get CapColourFromBody
	plmxml_api::logical GetCapColourFromBody() const;

	//! Check if CapColourFromBody is set
	plmxml_api::logical HasCapColourFromBody() const;

	//! Unset CapColourFromBody
	plmxml_api::Result UnsetCapColourFromBody();

	//! Set AssemblyCrosshatchAdjacency
	plmxml_api::Result SetAssemblyCrosshatchAdjacency( double arg );

     //! Get AssemblyCrosshatchAdjacency
	double GetAssemblyCrosshatchAdjacency() const;

	//! Check if AssemblyCrosshatchAdjacency is set
	plmxml_api::logical HasAssemblyCrosshatchAdjacency() const;

	//! Unset AssemblyCrosshatchAdjacency
	plmxml_api::Result UnsetAssemblyCrosshatchAdjacency();

	//! Set CurvesDisplay
	plmxml_api::Result SetCurvesDisplay( plmxml_api::logical arg );

	//! Get CurvesDisplay
	plmxml_api::logical GetCurvesDisplay() const;

	//! Check if CurvesDisplay is set
	plmxml_api::logical HasCurvesDisplay() const;

	//! Unset CurvesDisplay
	plmxml_api::Result UnsetCurvesDisplay();

	//! Set CapColour array
	plmxml_api::Result SetCapColour( const double *arg );

	//! Get CapColour array
	plmxml_api::Result GetCapColour( double *arg ) const;

	//! Check if CapColour array is set
	plmxml_api::logical HasCapColour() const;

	//! Unset CapColour array
	plmxml_api::Result UnsetCapColour();

	//! Get DefaultMaterialPattern URI as plmxml_api::String
	plmxml_api::String GetDefaultMaterialPatternURI() const;

	//! Set DefaultMaterialPattern URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetDefaultMaterialPatternURI( const plmxml_api::String& );
	
	//! Get the handle of DefaultMaterialPattern URI. Does not resolve the URI.
	plmxml_api::Result GetDefaultMaterialPatternURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of DefaultMaterialPattern URI. URI string is unchanged.
	plmxml_api::Result SetDefaultMaterialPatternURI( const plmxml_api::Handle& );
	
	//! Resolve DefaultMaterialPattern URI and return an object (handle) it points to.
	plmxml_api::Result ResolveDefaultMaterialPatternURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset DefaultMaterialPattern URI. Clears URI string and handle.
	plmxml_api::Result DeleteDefaultMaterialPatternURI();
	
	//! Check if DefaultMaterialPattern URI is set
	plmxml_api::logical HasDefaultMaterialPatternURI( ) const;
	

	//! Set GeometryType
	plmxml_api::Result SetGeometryType( const eSectionGeometryEnum& arg );

	//! Get GeometryType
	eSectionGeometryEnum GetGeometryType() const;

	//! Set ClipWireframeEntities
	plmxml_api::Result SetClipWireframeEntities( plmxml_api::logical arg );

	//! Get ClipWireframeEntities
	plmxml_api::logical GetClipWireframeEntities() const;

	//! Check if ClipWireframeEntities is set
	plmxml_api::logical HasClipWireframeEntities() const;

	//! Unset ClipWireframeEntities
	plmxml_api::Result UnsetClipWireframeEntities();

	//! Set NameFromCps
	plmxml_api::Result SetNameFromCps( plmxml_api::logical arg );

	//! Get NameFromCps
	plmxml_api::logical GetNameFromCps() const;

	//! Check if NameFromCps is set
	plmxml_api::logical HasNameFromCps() const;

	//! Unset NameFromCps
	plmxml_api::Result UnsetNameFromCps();

	//! Set Render
	plmxml_api::Result SetRender( const eDrawingStyleType& arg );

	//! Get Render
	eDrawingStyleType GetRender() const;

	//! Set CurvesColourFromBody
	plmxml_api::Result SetCurvesColourFromBody( plmxml_api::logical arg );

	//! Get CurvesColourFromBody
	plmxml_api::logical GetCurvesColourFromBody() const;

	//! Check if CurvesColourFromBody is set
	plmxml_api::logical HasCurvesColourFromBody() const;

	//! Unset CurvesColourFromBody
	plmxml_api::Result UnsetCurvesColourFromBody();

	//! Set Display
	plmxml_api::Result SetDisplay( const eSectionDisplayEnum& arg );

	//! Get Display
	eSectionDisplayEnum GetDisplay() const;

	//! Add Reference child element to this Section. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	GDEReference *AddReference();
     
	//! Add 'arg' as Reference child element to this Section.
	plmxml_api::Result AddReference( GDEReference *arg );

	//! Detach and delete all Reference child elements.
	void DeleteReferences();
     
	//! Get number of Reference child elements.
	int NumberOfReferences() const;
     
	//! Get i'th Reference child element.
	GDEReference *GetReference( int i ) const;
     
	//! Get all Reference child element as an array
	void GetReferences( plmxml_api::Array<GDEReference*> &array ) const;
	     
	//! Detach and delete i'th Reference child element
	void DeleteReference( int i );
     
	//! Detach and delete 'arg' if it's one of the Reference child elements
	void DeleteReference( GDEReference *arg );
 
// <PLMXML_UserCode type="functionHeaderSection" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassSection;


////////////////////////////////////////////////////////////////////////////////////
//! EntityRef class
/*!
\verbatim

      Base class for defining a reference to an entity. All entity
      reference elements should be based on this type and defined
      as a substitution class for EntityRef.
  
      Attributes:
      
      select:     Type of the reference - single or multiple.  
      contextRef: Context for the reference
      
\endverbatim
*/
class PLMXML60_API EntityRef : public DescriptionObject
{
public:
     
    //! Default constructor
    EntityRef( );
     
    //! Constructs a EntityRef with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    EntityRef( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~EntityRef();

private:

	//! Assignment operator
	EntityRef& operator=( const EntityRef& iSrc );

	//! Copy constructor
	EntityRef( const EntityRef& original );
     
public:

	//! Get Context URI as plmxml_api::String
	plmxml_api::String GetContextURI() const;

	//! Set Context URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetContextURI( const plmxml_api::String& );
	
	//! Get the handle of Context URI. Does not resolve the URI.
	plmxml_api::Result GetContextURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Context URI. URI string is unchanged.
	plmxml_api::Result SetContextURI( const plmxml_api::Handle& );
	
	//! Resolve Context URI and return an object (handle) it points to.
	plmxml_api::Result ResolveContextURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Context URI. Clears URI string and handle.
	plmxml_api::Result DeleteContextURI();
	
	//! Check if Context URI is set
	plmxml_api::logical HasContextURI( ) const;
	

	//! Set Select
	plmxml_api::Result SetSelect( const eRefSelectType& arg );

	//! Get Select
	eRefSelectType GetSelect() const;
 
// <PLMXML_UserCode type="functionHeaderEntityRef" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassEntityRef;


////////////////////////////////////////////////////////////////////////////////////
//! LocatorRef class
/*!
\verbatim

      Locator reference element. The reference is a URI based reference and
      the syntax of the URI must be pre-defined. Hence the only predefined
      type is currently PLMXMLPointer.
      
      Attributes:
      
      locationRef:  The value of the URI reference.
      type:         Format of the locator reference.
      
\endverbatim
*/
class PLMXML60_API LocatorRef : public EntityRef
{
public:
     
    //! Default constructor
    LocatorRef( );
     
    //! Constructs a LocatorRef with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    LocatorRef( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~LocatorRef();

private:

	//! Assignment operator
	LocatorRef& operator=( const LocatorRef& iSrc );

	//! Copy constructor
	LocatorRef( const LocatorRef& original );
     
public:

	//! Get Location URI as plmxml_api::String
	plmxml_api::String GetLocationURI() const;

	//! Set Location URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetLocationURI( const plmxml_api::String& );
	
	//! Get the handle of Location URI. Does not resolve the URI.
	plmxml_api::Result GetLocationURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Location URI. URI string is unchanged.
	plmxml_api::Result SetLocationURI( const plmxml_api::Handle& );
	
	//! Resolve Location URI and return an object (handle) it points to.
	plmxml_api::Result ResolveLocationURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Location URI. Clears URI string and handle.
	plmxml_api::Result DeleteLocationURI();
	
	//! Check if Location URI is set
	plmxml_api::logical HasLocationURI( ) const;
	

	//! Set Type
	plmxml_api::Result SetType( const eLocatorRefFormatType& arg );

	//! Get Type
	eLocatorRefFormatType GetType() const;
 
// <PLMXML_UserCode type="functionHeaderLocatorRef" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassLocatorRef;


////////////////////////////////////////////////////////////////////////////////////
//! AttributeRef class
/*!
\verbatim

      Attribute reference element. The reference is based on a user
      defined named attribute on the host representation. This type
      enables the author to note the attribute name, field name/index
      and the value of the attribute.

      Attributes:
      
      attribute:  The name of the attribute to query, e.g.
                  "COMPANYNAME/Tracking_attribute".
      field:      The name of the field within the attribute.
      index:      The index of the field within the attribute, if its
                  name is not given. (The first field is index 0).
      value:      The value of the attribute to match.
      
\endverbatim
*/
class PLMXML60_API AttributeRef : public EntityRef
{
public:
     
    //! Default constructor
    AttributeRef( );
     
    //! Constructs a AttributeRef with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    AttributeRef( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~AttributeRef();

private:

	//! Assignment operator
	AttributeRef& operator=( const AttributeRef& iSrc );

	//! Copy constructor
	AttributeRef( const AttributeRef& original );
     
public:

	//! Get Value of this AttributeRef
	plmxml_api::String GetValue() const;

	//! Set Value of this AttributeRef
	plmxml_api::Result SetValue( const plmxml_api::String &s );
	
	//! Check if Value is set
	plmxml_api::logical HasValue( ) const;
	
	//! Unset Value
	plmxml_api::Result UnsetValue( );

	//! Set Index
	plmxml_api::Result SetIndex( int arg );
     
	//! Get Index
	int GetIndex() const;
     
	//! Check if Index is set
	plmxml_api::logical HasIndex() const;
     
	//! Unset Index
	plmxml_api::Result UnsetIndex();

	//! Get Attribute of this AttributeRef
	plmxml_api::String GetAttribute() const;

	//! Set Attribute of this AttributeRef
	plmxml_api::Result SetAttribute( const plmxml_api::String &s );
	
	//! Check if Attribute is set
	plmxml_api::logical HasAttribute( ) const;
	
	//! Unset Attribute
	plmxml_api::Result UnsetAttribute( );

	//! Get Field of this AttributeRef
	plmxml_api::String GetField() const;

	//! Set Field of this AttributeRef
	plmxml_api::Result SetField( const plmxml_api::String &s );
	
	//! Check if Field is set
	plmxml_api::logical HasField( ) const;
	
	//! Unset Field
	plmxml_api::Result UnsetField( );
 
// <PLMXML_UserCode type="functionHeaderAttributeRef" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassAttributeRef;


////////////////////////////////////////////////////////////////////////////////////
//! GUIDRef class
/*!
\verbatim

      GUID reference element. This simply specifies the GUID of the entity
      being referenced.
      
      Attribute:
    
      guid:       The GUID of the entity referenced, in the form of a string containing 
                  32 hex digits, with arbitrary non-hex spacing characters.
      
\endverbatim
*/
class PLMXML60_API GUIDRef : public EntityRef
{
public:
     
    //! Default constructor
    GUIDRef( );
     
    //! Constructs a GUIDRef with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    GUIDRef( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~GUIDRef();

private:

	//! Assignment operator
	GUIDRef& operator=( const GUIDRef& iSrc );

	//! Copy constructor
	GUIDRef( const GUIDRef& original );
     
public:

	//! Get Guid of this GUIDRef
	plmxml_api::String GetGuid() const;

	//! Set Guid of this GUIDRef
	plmxml_api::Result SetGuid( const plmxml_api::String &s );
	
	//! Check if Guid is set
	plmxml_api::logical HasGuid( ) const;
	
	//! Unset Guid
	plmxml_api::Result UnsetGuid( );
 
// <PLMXML_UserCode type="functionHeaderGUIDRef" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassGUIDRef;


////////////////////////////////////////////////////////////////////////////////////
//! RefPoint class
/*!
\verbatim

      Reference Point element
      
\endverbatim
*/
class PLMXML60_API RefPoint : public Point
{
public:
     
    //! Default constructor
    RefPoint( );
     
    //! Constructs a RefPoint with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    RefPoint( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~RefPoint();

private:

	//! Assignment operator
	RefPoint& operator=( const RefPoint& iSrc );

	//! Copy constructor
	RefPoint( const RefPoint& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderRefPoint" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassRefPoint;


////////////////////////////////////////////////////////////////////////////////////
//! Line class
/*!
\verbatim

      Straight line curve.
      
      Attributes:
      
      origin:        start (T=0).
      direction:     direction of increasing T.
      
\endverbatim
*/
class PLMXML60_API Line : public Curve
{
public:
     
    //! Default constructor
    Line( );
     
    //! Constructs a Line with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Line( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Line();

private:

	//! Assignment operator
	Line& operator=( const Line& iSrc );

	//! Copy constructor
	Line( const Line& original );
     
public:

	//! Set Direction using plmxml_api::Vector components
	plmxml_api::Result SetDirection( const plmxml_api::Vector& arg );

	//! Get Direction as plmxml_api::Vector
	plmxml_api::Result GetDirection( plmxml_api::Vector& arg ) const;

	//! Check if Direction is set
	plmxml_api::logical HasDirection() const;

	//! Unset Direction
	plmxml_api::Result UnsetDirection();

	//! Set Origin using plmxml_api::Vector components
	plmxml_api::Result SetOrigin( const plmxml_api::Vector& arg );

	//! Get Origin as plmxml_api::Vector
	plmxml_api::Result GetOrigin( plmxml_api::Vector& arg ) const;

	//! Check if Origin is set
	plmxml_api::logical HasOrigin() const;

	//! Unset Origin
	plmxml_api::Result UnsetOrigin();
 
// <PLMXML_UserCode type="functionHeaderLine" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassLine;


////////////////////////////////////////////////////////////////////////////////////
//! PolyLine class
/*!
\verbatim

      Polyline, i.e. sequence of connected line-segments.
      
      Attributes:
      
      closed:        true if the end of the polyline equals its start.
      dimension:     dimension of the curve. This determines the length of each 
                     vector in 'Points'. Defaults to 3.
                     
      type:          an optional indication of the shape of the polyline, e.g. "arc".
                     
      Elements:
      
      Points:        coordinates of the ends of the line segments, in order.
      
\endverbatim
*/
class PLMXML60_API PolyLine : public Curve
{
public:
     
    //! Default constructor
    PolyLine( );
     
    //! Constructs a PolyLine with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    PolyLine( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~PolyLine();

private:

	//! Assignment operator
	PolyLine& operator=( const PolyLine& iSrc );

	//! Copy constructor
	PolyLine( const PolyLine& original );
     
public:

	//! Set Dimension
	plmxml_api::Result SetDimension( int arg );
     
	//! Get Dimension
	int GetDimension() const;
     
	//! Check if Dimension is set
	plmxml_api::logical HasDimension() const;
     
	//! Unset Dimension
	plmxml_api::Result UnsetDimension();

	//! Set Closed
	plmxml_api::Result SetClosed( plmxml_api::logical arg );

	//! Get Closed
	plmxml_api::logical GetClosed() const;

	//! Check if Closed is set
	plmxml_api::logical HasClosed() const;

	//! Unset Closed
	plmxml_api::Result UnsetClosed();

	//! Get Type of this PolyLine
	plmxml_api::String GetType() const;

	//! Set Type of this PolyLine
	plmxml_api::Result SetType( const plmxml_api::String &s );
	
	//! Check if Type is set
	plmxml_api::logical HasType( ) const;
	
	//! Unset Type
	plmxml_api::Result UnsetType( );

	//! Set Points
	plmxml_api::Result SetPoints( const plmxml_api::Array<double>& arg );

	//! Get Points
	plmxml_api::Result GetPoints( plmxml_api::Array<double>& arg ) const;

	//! Check if Points is set
	plmxml_api::logical HasPoints() const;

	//! Unset Points
	plmxml_api::Result UnsetPoints();
 
// <PLMXML_UserCode type="functionHeaderPolyLine" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassPolyLine;


////////////////////////////////////////////////////////////////////////////////////
//! PolyTriangle class
/*!
\verbatim

      A planar triangle, triangle strip or triangle fan used for PMI
      presentation.

      Attributes:

      type:             The type of PolyTriangle.
      dimension:        The dimension of the PolyTriangle.

      Sub-elements:

      Points:           The coordinates of the points, in order.
      
\endverbatim
*/
class PLMXML60_API PolyTriangle : public Surface
{
public:
     
    //! Default constructor
    PolyTriangle( );
     
    //! Constructs a PolyTriangle with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    PolyTriangle( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~PolyTriangle();

private:

	//! Assignment operator
	PolyTriangle& operator=( const PolyTriangle& iSrc );

	//! Copy constructor
	PolyTriangle( const PolyTriangle& original );
     
public:

	//! Set Type
	plmxml_api::Result SetType( const ePolyTriangleEnum& arg );

	//! Get Type
	ePolyTriangleEnum GetType() const;

	//! Set Dimension
	plmxml_api::Result SetDimension( int arg );
     
	//! Get Dimension
	int GetDimension() const;
     
	//! Check if Dimension is set
	plmxml_api::logical HasDimension() const;
     
	//! Unset Dimension
	plmxml_api::Result UnsetDimension();

	//! Set Points
	plmxml_api::Result SetPoints( const plmxml_api::Array<double>& arg );

	//! Get Points
	plmxml_api::Result GetPoints( plmxml_api::Array<double>& arg ) const;

	//! Check if Points is set
	plmxml_api::logical HasPoints() const;

	//! Unset Points
	plmxml_api::Result UnsetPoints();
 
// <PLMXML_UserCode type="functionHeaderPolyTriangle" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassPolyTriangle;


////////////////////////////////////////////////////////////////////////////////////
//! Circle class
/*!
\verbatim

      Circular curve. The T=0 point is on the positive x-axis of the underlying plane. The
      T=pi/2 point is on the positive y-axis.
      
      Attributes:
      
      radius:        radius
      
\endverbatim
*/
class PLMXML60_API Circle : public PlaneCurve
{
public:
     
    //! Default constructor
    Circle( );
     
    //! Constructs a Circle with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Circle( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Circle();

private:

	//! Assignment operator
	Circle& operator=( const Circle& iSrc );

	//! Copy constructor
	Circle( const Circle& original );
     
public:

	//! Set Radius
	plmxml_api::Result SetRadius( double arg );

     //! Get Radius
	double GetRadius() const;

	//! Check if Radius is set
	plmxml_api::logical HasRadius() const;

	//! Unset Radius
	plmxml_api::Result UnsetRadius();
 
// <PLMXML_UserCode type="functionHeaderCircle" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassCircle;


////////////////////////////////////////////////////////////////////////////////////
//! Ellipse class
/*!
\verbatim

      Elliptical curve. The T=0 point is on the positive x-axis of the underlying plane,
      at a distance 'majorRadius' from the origin. The T=pi/2 point is on the positive
      y-axis, at a distance 'minorRadius' from the origin.
      
      Attributes:
      
      majorRadius:   major radius.
      minorRadius:   minor radius.
      
\endverbatim
*/
class PLMXML60_API Ellipse : public PlaneCurve
{
public:
     
    //! Default constructor
    Ellipse( );
     
    //! Constructs a Ellipse with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Ellipse( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Ellipse();

private:

	//! Assignment operator
	Ellipse& operator=( const Ellipse& iSrc );

	//! Copy constructor
	Ellipse( const Ellipse& original );
     
public:

	//! Set MajorRadius
	plmxml_api::Result SetMajorRadius( double arg );

     //! Get MajorRadius
	double GetMajorRadius() const;

	//! Check if MajorRadius is set
	plmxml_api::logical HasMajorRadius() const;

	//! Unset MajorRadius
	plmxml_api::Result UnsetMajorRadius();

	//! Set MinorRadius
	plmxml_api::Result SetMinorRadius( double arg );

     //! Get MinorRadius
	double GetMinorRadius() const;

	//! Check if MinorRadius is set
	plmxml_api::logical HasMinorRadius() const;

	//! Unset MinorRadius
	plmxml_api::Result UnsetMinorRadius();
 
// <PLMXML_UserCode type="functionHeaderEllipse" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassEllipse;


////////////////////////////////////////////////////////////////////////////////////
//! BSplineCurve class
/*!
\verbatim

      B-Spline curve in 2- or 3-dimensional space.
      
      Attributes:
      
      degree:        degree of the curve.
      dimension:     dimension of the curve. This determines the length of each vector in 
                     'Vertices': if isRational is true, it is 'dimension+1', else it is
                     'dimension'. Defaults to 3.
      isRational:    true if the spline is rational.
      isPeriodic:    true if the spline is periodic.
      isClosed:      true if the start and end of the curve coincide.
      form:          form of the curve.

      Elements:
      
      Knots:         knot values, in increasing order, no repetitions.
      KnotMultiplicities: multiplicities of the knots.
      Vertices:      coordinates of the vertices.
      
\endverbatim
*/
class PLMXML60_API BSplineCurve : public Curve
{
public:
     
    //! Default constructor
    BSplineCurve( );
     
    //! Constructs a BSplineCurve with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    BSplineCurve( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~BSplineCurve();

private:

	//! Assignment operator
	BSplineCurve& operator=( const BSplineCurve& iSrc );

	//! Copy constructor
	BSplineCurve( const BSplineCurve& original );
     
public:

	//! Set IsRational
	plmxml_api::Result SetIsRational( plmxml_api::logical arg );

	//! Get IsRational
	plmxml_api::logical GetIsRational() const;

	//! Check if IsRational is set
	plmxml_api::logical HasIsRational() const;

	//! Unset IsRational
	plmxml_api::Result UnsetIsRational();

	//! Set IsPeriodic
	plmxml_api::Result SetIsPeriodic( plmxml_api::logical arg );

	//! Get IsPeriodic
	plmxml_api::logical GetIsPeriodic() const;

	//! Check if IsPeriodic is set
	plmxml_api::logical HasIsPeriodic() const;

	//! Unset IsPeriodic
	plmxml_api::Result UnsetIsPeriodic();

	//! Set Degree
	plmxml_api::Result SetDegree( int arg );
     
	//! Get Degree
	int GetDegree() const;
     
	//! Check if Degree is set
	plmxml_api::logical HasDegree() const;
     
	//! Unset Degree
	plmxml_api::Result UnsetDegree();

	//! Set IsClosed
	plmxml_api::Result SetIsClosed( plmxml_api::logical arg );

	//! Get IsClosed
	plmxml_api::logical GetIsClosed() const;

	//! Check if IsClosed is set
	plmxml_api::logical HasIsClosed() const;

	//! Unset IsClosed
	plmxml_api::Result UnsetIsClosed();

	//! Set Form
	plmxml_api::Result SetForm( const eSplineCurveFormType& arg );

	//! Get Form
	eSplineCurveFormType GetForm() const;

	//! Set Dimension
	plmxml_api::Result SetDimension( int arg );
     
	//! Get Dimension
	int GetDimension() const;
     
	//! Check if Dimension is set
	plmxml_api::logical HasDimension() const;
     
	//! Unset Dimension
	plmxml_api::Result UnsetDimension();

	//! Set Knots
	plmxml_api::Result SetKnots( const plmxml_api::Array<double>& arg );

	//! Get Knots
	plmxml_api::Result GetKnots( plmxml_api::Array<double>& arg ) const;

	//! Check if Knots is set
	plmxml_api::logical HasKnots() const;

	//! Unset Knots
	plmxml_api::Result UnsetKnots();

     //! Set KnotMultiplicities array
     plmxml_api::Result SetKnotMultiplicities( const plmxml_api::Array<int>& arg );
     
     //! Get KnotMultiplicities array
     plmxml_api::Result GetKnotMultiplicities( plmxml_api::Array<int>& arg ) const;
     
     //! Check if KnotMultiplicities array is set
     plmxml_api::logical HasKnotMultiplicities() const;
     
     //! Empty KnotMultiplicities array
     plmxml_api::Result UnsetKnotMultiplicities();

	//! Set Vertices
	plmxml_api::Result SetVertices( const plmxml_api::Array<double>& arg );

	//! Get Vertices
	plmxml_api::Result GetVertices( plmxml_api::Array<double>& arg ) const;

	//! Check if Vertices is set
	plmxml_api::logical HasVertices() const;

	//! Unset Vertices
	plmxml_api::Result UnsetVertices();
 
// <PLMXML_UserCode type="functionHeaderBSplineCurve" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassBSplineCurve;


////////////////////////////////////////////////////////////////////////////////////
//! CompositeCurve class
/*!
\verbatim

      Composite Curve, formed by joining curves together end-to-end.
             
      Attributes:
      
      curves:        sequence of curves. NB this attribute name is non-standard,
                     PLMXML conventions require that IDREFS attributes end in 'Refs'.
      isClosed:      true if the end of the last curve coincides with the start
                     of the first.
      
\endverbatim
*/
class PLMXML60_API CompositeCurve : public Curve
{
public:
     
    //! Default constructor
    CompositeCurve( );
     
    //! Constructs a CompositeCurve with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    CompositeCurve( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~CompositeCurve();

private:

	//! Assignment operator
	CompositeCurve& operator=( const CompositeCurve& iSrc );

	//! Copy constructor
	CompositeCurve( const CompositeCurve& original );
     
public:

	//! Get number of references in Curves array
	int NumberOfCurvesRefs() const;
     
	//! Add reference to 'arg' to Curves array
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical AddCurvesRef( plmxml60::IdObject *arg );
     
	//! Add reference to an object pointed to by 'u' to Curves array
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical AddCurvesId( const plmxml_api::String &u );
     
	//! Set i'th reference in Curves array to 'arg'
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical SetCurvesRef( int i, plmxml60::IdObject *arg );
     
	//! Set i'th reference in Curves array to an object pointed to by 'u'
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical SetCurvesId( int i, const plmxml_api::String &u );
     
	//! Resolve i'th reference in Curves array and return an object it points to.
	plmxml60::IdObject *ResolveCurvesRef( int i, plmxml_api::Configuration* config = NULL );
     
	//! Resolve all references in Curves array and return objects they point to.
	void ResolveCurvesRefs( plmxml_api::Array<plmxml60::IdObject *> & array, plmxml_api::Configuration* config = NULL );
     
	//! Get i'th reference in Curves array as plmxml_api::String
	plmxml_api::String GetCurvesId( int i ) const;
     
	//! Get all references in Curves array as an array of plmxml_api::String
	void GetCurvesIds( plmxml_api::Array<plmxml_api::String> &array ) const;
     
	//! Remove i'th reference from the Curves array.
	void RemoveCurvesRef( int i );
     
	//! Remove reference to an object pointed to by 'u' from the Curves array.
	void RemoveCurvesRef( const plmxml_api::String &u );
     
	//! Remove reference to 'arg' from the Curves array.
	void RemoveCurvesRef( plmxml60::IdObject *arg );
     
	//! Remove all references Curves array.
	void RemoveCurvesRefs();
	
	//! Check if Curves is set
	plmxml_api::logical HasCurvesRefs( ) const;

	//! Set IsClosed
	plmxml_api::Result SetIsClosed( plmxml_api::logical arg );

	//! Get IsClosed
	plmxml_api::logical GetIsClosed() const;

	//! Check if IsClosed is set
	plmxml_api::logical HasIsClosed() const;

	//! Unset IsClosed
	plmxml_api::Result UnsetIsClosed();
 
// <PLMXML_UserCode type="functionHeaderCompositeCurve" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassCompositeCurve;


////////////////////////////////////////////////////////////////////////////////////
//! SPCurve class
/*!
\verbatim

      A curve defined in the parameter-space of a surface. The x,y positions
      of the curve correspond to u,v parameters in the surface.
             
      Attributes:
      
      parameterCurve:  reference to a 2-dimensional BSpline curve.
      surface:         reference to a surface.
      
                       NB both these attributes have non-standard names, PLMXML
                       conventions require reference attributes to end in 'Ref'.
      
\endverbatim
*/
class PLMXML60_API SPCurve : public Curve
{
public:
     
    //! Default constructor
    SPCurve( );
     
    //! Constructs a SPCurve with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    SPCurve( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~SPCurve();

private:

	//! Assignment operator
	SPCurve& operator=( const SPCurve& iSrc );

	//! Copy constructor
	SPCurve( const SPCurve& original );
     
public:

	//! Set reference to Surface using 'arg's plmxml_api::Id.
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical SetSurfaceRef( plmxml60::IdObject *arg );

	//! Clear reference to Surface
	void RemoveSurfaceRef( );

	//! Find a plmxml60::IdObject referenced by Surface
	plmxml60::IdObject *ResolveSurfaceRef( plmxml_api::Configuration* config = NULL );

	//! Get Surface reference
	plmxml_api::String GetSurfaceId() const;

	//! Set Surface reference.
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical SetSurfaceId( const plmxml_api::String& u );
	
	//! Check if Surface is set
	plmxml_api::logical HasSurfaceRef( ) const;

	//! Set reference to ParameterCurve using 'arg's plmxml_api::Id.
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical SetParameterCurveRef( plmxml60::IdObject *arg );

	//! Clear reference to ParameterCurve
	void RemoveParameterCurveRef( );

	//! Find a plmxml60::IdObject referenced by ParameterCurve
	plmxml60::IdObject *ResolveParameterCurveRef( plmxml_api::Configuration* config = NULL );

	//! Get ParameterCurve reference
	plmxml_api::String GetParameterCurveId() const;

	//! Set ParameterCurve reference.
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical SetParameterCurveId( const plmxml_api::String& u );
	
	//! Check if ParameterCurve is set
	plmxml_api::logical HasParameterCurveRef( ) const;
 
// <PLMXML_UserCode type="functionHeaderSPCurve" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassSPCurve;


////////////////////////////////////////////////////////////////////////////////////
//! Plane class
/*!
\verbatim

\endverbatim
*/
class PLMXML60_API Plane : public SurfacePosition
{
public:
     
    //! Default constructor
    Plane( );
     
    //! Constructs a Plane with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Plane( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Plane();

private:

	//! Assignment operator
	Plane& operator=( const Plane& iSrc );

	//! Copy constructor
	Plane( const Plane& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderPlane" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassPlane;


////////////////////////////////////////////////////////////////////////////////////
//! Cylinder class
/*!
\verbatim

\endverbatim
*/
class PLMXML60_API Cylinder : public SurfacePosition
{
public:
     
    //! Default constructor
    Cylinder( );
     
    //! Constructs a Cylinder with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Cylinder( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Cylinder();

private:

	//! Assignment operator
	Cylinder& operator=( const Cylinder& iSrc );

	//! Copy constructor
	Cylinder( const Cylinder& original );
     
public:

	//! Set Radius
	plmxml_api::Result SetRadius( double arg );

     //! Get Radius
	double GetRadius() const;

	//! Check if Radius is set
	plmxml_api::logical HasRadius() const;

	//! Unset Radius
	plmxml_api::Result UnsetRadius();
 
// <PLMXML_UserCode type="functionHeaderCylinder" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassCylinder;


////////////////////////////////////////////////////////////////////////////////////
//! Sphere class
/*!
\verbatim

\endverbatim
*/
class PLMXML60_API Sphere : public SurfacePosition
{
public:
     
    //! Default constructor
    Sphere( );
     
    //! Constructs a Sphere with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Sphere( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Sphere();

private:

	//! Assignment operator
	Sphere& operator=( const Sphere& iSrc );

	//! Copy constructor
	Sphere( const Sphere& original );
     
public:

	//! Set Radius
	plmxml_api::Result SetRadius( double arg );

     //! Get Radius
	double GetRadius() const;

	//! Check if Radius is set
	plmxml_api::logical HasRadius() const;

	//! Unset Radius
	plmxml_api::Result UnsetRadius();
 
// <PLMXML_UserCode type="functionHeaderSphere" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassSphere;


////////////////////////////////////////////////////////////////////////////////////
//! Cone class
/*!
\verbatim

      Conical surface. The cone axis is along the Z-Axis of the underlying 
      coordinate frame. The cone radius increases in the direction of the
      Z-Axis.
      
      Attributes:
      
      radius:          radius of the cone at the origin of the coordinate frame.
                       This is zero or positive.
      halfAngle:       the positive angle between the Z-Axis and a line in the
                       cone, in radians.
      
\endverbatim
*/
class PLMXML60_API Cone : public SurfacePosition
{
public:
     
    //! Default constructor
    Cone( );
     
    //! Constructs a Cone with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Cone( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Cone();

private:

	//! Assignment operator
	Cone& operator=( const Cone& iSrc );

	//! Copy constructor
	Cone( const Cone& original );
     
public:

	//! Set Radius
	plmxml_api::Result SetRadius( double arg );

     //! Get Radius
	double GetRadius() const;

	//! Check if Radius is set
	plmxml_api::logical HasRadius() const;

	//! Unset Radius
	plmxml_api::Result UnsetRadius();

	//! Set HalfAngle
	plmxml_api::Result SetHalfAngle( double arg );

     //! Get HalfAngle
	double GetHalfAngle() const;

	//! Check if HalfAngle is set
	plmxml_api::logical HasHalfAngle() const;

	//! Unset HalfAngle
	plmxml_api::Result UnsetHalfAngle();
 
// <PLMXML_UserCode type="functionHeaderCone" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassCone;


////////////////////////////////////////////////////////////////////////////////////
//! Torus class
/*!
\verbatim

      Toroidal surface. The axis of the torus is the Z-Axis of the underlying
      coordinate frame.
      
      Attributes:
      
      majorRadius:     major radius 
      minorRadius:     minor radius
      
\endverbatim
*/
class PLMXML60_API Torus : public SurfacePosition
{
public:
     
    //! Default constructor
    Torus( );
     
    //! Constructs a Torus with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Torus( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Torus();

private:

	//! Assignment operator
	Torus& operator=( const Torus& iSrc );

	//! Copy constructor
	Torus( const Torus& original );
     
public:

	//! Set MajorRadius
	plmxml_api::Result SetMajorRadius( double arg );

     //! Get MajorRadius
	double GetMajorRadius() const;

	//! Check if MajorRadius is set
	plmxml_api::logical HasMajorRadius() const;

	//! Unset MajorRadius
	plmxml_api::Result UnsetMajorRadius();

	//! Set MinorRadius
	plmxml_api::Result SetMinorRadius( double arg );

     //! Get MinorRadius
	double GetMinorRadius() const;

	//! Check if MinorRadius is set
	plmxml_api::logical HasMinorRadius() const;

	//! Unset MinorRadius
	plmxml_api::Result UnsetMinorRadius();
 
// <PLMXML_UserCode type="functionHeaderTorus" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassTorus;


////////////////////////////////////////////////////////////////////////////////////
//! Prism class
/*!
\verbatim

      A regular polygonal prismatic surface. The axis of the surface is the Z
      axis of the underlying coordinate frame.

      Attributes:

      sides:            The number of sides of the prismatic surface.
      radius:           The perpendicular distance from the axis to each edge.
                        One such distance lies in the X direction.
      
\endverbatim
*/
class PLMXML60_API Prism : public SurfacePosition
{
public:
     
    //! Default constructor
    Prism( );
     
    //! Constructs a Prism with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Prism( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Prism();

private:

	//! Assignment operator
	Prism& operator=( const Prism& iSrc );

	//! Copy constructor
	Prism( const Prism& original );
     
public:

	//! Set Radius
	plmxml_api::Result SetRadius( double arg );

     //! Get Radius
	double GetRadius() const;

	//! Check if Radius is set
	plmxml_api::logical HasRadius() const;

	//! Unset Radius
	plmxml_api::Result UnsetRadius();

	//! Set Sides
	plmxml_api::Result SetSides( int arg );
     
	//! Get Sides
	int GetSides() const;
     
	//! Check if Sides is set
	plmxml_api::logical HasSides() const;
     
	//! Unset Sides
	plmxml_api::Result UnsetSides();

     // <PLMXML_UserCode type="functionHeaderPrism" >
     // TODO: Add extra function headers within this block
     // </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassPrism;


////////////////////////////////////////////////////////////////////////////////////
//! BSplineSurface class
/*!
\verbatim

      B-Spline surface, normally in 3-dimensional space.
      
      Attributes:
      
      uDegree:       degree of the surface in U.
      vDegree:       degree of the surface in V.
      dimension:     dimension of the surface. This determines the length of each vector
                     in 'Vertices': if isRational is true, it is 'dimension+1', else it
                     is 'dimension'. Defaults to 3.
      isRational:    true if the surface is rational.
      isUPeriodic:   true if the surface is periodic in U.
      isUPeriodic:   true if the surface is periodic in U.
      isVClosed:     true if the surface is closed in V.
      isVClosed:     true if the surface is closed in V.
      numberOfUVertices: number of U vertices.
      numberOfVVertices: number of V vertices.

      Elements:
      
      UKnots:        U knot values, in increasing order, no repetitions.
      VKnots:        V knot values, in increasing order, no repetitions.
      UKnotMultiplicities: multiplicities of the U knots.
      VKnotMultiplicities: multiplicities of the V knots.
      Vertices:      coordinates of the vertices.
      
\endverbatim
*/
class PLMXML60_API BSplineSurface : public Surface
{
public:
     
    //! Default constructor
    BSplineSurface( );
     
    //! Constructs a BSplineSurface with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    BSplineSurface( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~BSplineSurface();

private:

	//! Assignment operator
	BSplineSurface& operator=( const BSplineSurface& iSrc );

	//! Copy constructor
	BSplineSurface( const BSplineSurface& original );
     
public:

	//! Set IsRational
	plmxml_api::Result SetIsRational( plmxml_api::logical arg );

	//! Get IsRational
	plmxml_api::logical GetIsRational() const;

	//! Check if IsRational is set
	plmxml_api::logical HasIsRational() const;

	//! Unset IsRational
	plmxml_api::Result UnsetIsRational();

	//! Set NumberOfVVertices
	plmxml_api::Result SetNumberOfVVertices( int arg );
     
	//! Get NumberOfVVertices
	int GetNumberOfVVertices() const;
     
	//! Check if NumberOfVVertices is set
	plmxml_api::logical HasNumberOfVVertices() const;
     
	//! Unset NumberOfVVertices
	plmxml_api::Result UnsetNumberOfVVertices();

	//! Set VDegree
	plmxml_api::Result SetVDegree( int arg );
     
	//! Get VDegree
	int GetVDegree() const;
     
	//! Check if VDegree is set
	plmxml_api::logical HasVDegree() const;
     
	//! Unset VDegree
	plmxml_api::Result UnsetVDegree();

	//! Set IsVClosed
	plmxml_api::Result SetIsVClosed( plmxml_api::logical arg );

	//! Get IsVClosed
	plmxml_api::logical GetIsVClosed() const;

	//! Check if IsVClosed is set
	plmxml_api::logical HasIsVClosed() const;

	//! Unset IsVClosed
	plmxml_api::Result UnsetIsVClosed();

	//! Set IsUClosed
	plmxml_api::Result SetIsUClosed( plmxml_api::logical arg );

	//! Get IsUClosed
	plmxml_api::logical GetIsUClosed() const;

	//! Check if IsUClosed is set
	plmxml_api::logical HasIsUClosed() const;

	//! Unset IsUClosed
	plmxml_api::Result UnsetIsUClosed();

	//! Set IsUPeriodic
	plmxml_api::Result SetIsUPeriodic( plmxml_api::logical arg );

	//! Get IsUPeriodic
	plmxml_api::logical GetIsUPeriodic() const;

	//! Check if IsUPeriodic is set
	plmxml_api::logical HasIsUPeriodic() const;

	//! Unset IsUPeriodic
	plmxml_api::Result UnsetIsUPeriodic();

	//! Set Dimension
	plmxml_api::Result SetDimension( int arg );
     
	//! Get Dimension
	int GetDimension() const;
     
	//! Check if Dimension is set
	plmxml_api::logical HasDimension() const;
     
	//! Unset Dimension
	plmxml_api::Result UnsetDimension();

	//! Set NumberOfUVertices
	plmxml_api::Result SetNumberOfUVertices( int arg );
     
	//! Get NumberOfUVertices
	int GetNumberOfUVertices() const;
     
	//! Check if NumberOfUVertices is set
	plmxml_api::logical HasNumberOfUVertices() const;
     
	//! Unset NumberOfUVertices
	plmxml_api::Result UnsetNumberOfUVertices();

	//! Set IsVPeriodic
	plmxml_api::Result SetIsVPeriodic( plmxml_api::logical arg );

	//! Get IsVPeriodic
	plmxml_api::logical GetIsVPeriodic() const;

	//! Check if IsVPeriodic is set
	plmxml_api::logical HasIsVPeriodic() const;

	//! Unset IsVPeriodic
	plmxml_api::Result UnsetIsVPeriodic();

	//! Set UDegree
	plmxml_api::Result SetUDegree( int arg );
     
	//! Get UDegree
	int GetUDegree() const;
     
	//! Check if UDegree is set
	plmxml_api::logical HasUDegree() const;
     
	//! Unset UDegree
	plmxml_api::Result UnsetUDegree();

	//! Set UKnots
	plmxml_api::Result SetUKnots( const plmxml_api::Array<double>& arg );

	//! Get UKnots
	plmxml_api::Result GetUKnots( plmxml_api::Array<double>& arg ) const;

	//! Check if UKnots is set
	plmxml_api::logical HasUKnots() const;

	//! Unset UKnots
	plmxml_api::Result UnsetUKnots();

	//! Set VKnots
	plmxml_api::Result SetVKnots( const plmxml_api::Array<double>& arg );

	//! Get VKnots
	plmxml_api::Result GetVKnots( plmxml_api::Array<double>& arg ) const;

	//! Check if VKnots is set
	plmxml_api::logical HasVKnots() const;

	//! Unset VKnots
	plmxml_api::Result UnsetVKnots();

     //! Set UKnotMultiplicities array
     plmxml_api::Result SetUKnotMultiplicities( const plmxml_api::Array<int>& arg );
     
     //! Get UKnotMultiplicities array
     plmxml_api::Result GetUKnotMultiplicities( plmxml_api::Array<int>& arg ) const;
     
     //! Check if UKnotMultiplicities array is set
     plmxml_api::logical HasUKnotMultiplicities() const;
     
     //! Empty UKnotMultiplicities array
     plmxml_api::Result UnsetUKnotMultiplicities();

     //! Set VKnotMultiplicities array
     plmxml_api::Result SetVKnotMultiplicities( const plmxml_api::Array<int>& arg );
     
     //! Get VKnotMultiplicities array
     plmxml_api::Result GetVKnotMultiplicities( plmxml_api::Array<int>& arg ) const;
     
     //! Check if VKnotMultiplicities array is set
     plmxml_api::logical HasVKnotMultiplicities() const;
     
     //! Empty VKnotMultiplicities array
     plmxml_api::Result UnsetVKnotMultiplicities();

	//! Set Vertices
	plmxml_api::Result SetVertices( const plmxml_api::Array<double>& arg );

	//! Get Vertices
	plmxml_api::Result GetVertices( plmxml_api::Array<double>& arg ) const;

	//! Check if Vertices is set
	plmxml_api::logical HasVertices() const;

	//! Unset Vertices
	plmxml_api::Result UnsetVertices();
 
// <PLMXML_UserCode type="functionHeaderBSplineSurface" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassBSplineSurface;


////////////////////////////////////////////////////////////////////////////////////
//! CoordinateSystem class
/*!
\verbatim

      Cartesian Coordinate system.
      
\endverbatim
*/
class PLMXML60_API CoordinateSystem : public Geometry
{
public:
     
    //! Default constructor
    CoordinateSystem( );
     
    //! Constructs a CoordinateSystem with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    CoordinateSystem( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~CoordinateSystem();

private:

	//! Assignment operator
	CoordinateSystem& operator=( const CoordinateSystem& iSrc );

	//! Copy constructor
	CoordinateSystem( const CoordinateSystem& original );
     
public:

	//! Set Origin using plmxml_api::Vector components
	plmxml_api::Result SetOrigin( const plmxml_api::Vector& arg );

	//! Get Origin as plmxml_api::Vector
	plmxml_api::Result GetOrigin( plmxml_api::Vector& arg ) const;

	//! Check if Origin is set
	plmxml_api::logical HasOrigin() const;

	//! Unset Origin
	plmxml_api::Result UnsetOrigin();

	//! Set XAxis using plmxml_api::Vector components
	plmxml_api::Result SetXAxis( const plmxml_api::Vector& arg );

	//! Get XAxis as plmxml_api::Vector
	plmxml_api::Result GetXAxis( plmxml_api::Vector& arg ) const;

	//! Check if XAxis is set
	plmxml_api::logical HasXAxis() const;

	//! Unset XAxis
	plmxml_api::Result UnsetXAxis();

	//! Set ZAxis using plmxml_api::Vector components
	plmxml_api::Result SetZAxis( const plmxml_api::Vector& arg );

	//! Get ZAxis as plmxml_api::Vector
	plmxml_api::Result GetZAxis( plmxml_api::Vector& arg ) const;

	//! Check if ZAxis is set
	plmxml_api::logical HasZAxis() const;

	//! Unset ZAxis
	plmxml_api::Result UnsetZAxis();
 
// <PLMXML_UserCode type="functionHeaderCoordinateSystem" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassCoordinateSystem;


////////////////////////////////////////////////////////////////////////////////////
//! GeometryComposition class
/*!
\verbatim

      Geometry composition.

      Attributes:

      font:          The font when the GeometryComposition represents a glyph.
      textHeight:    The height in metres when the GeometryComposition
                     represents a glyph.

      Elements:

      Point:         any elements derived from Point.
      Curve:         any elements derived from Curve.
      Surface:       any elements derived from Surface.
      CoordinateSystem:  coordinate systems.
      
\endverbatim
*/
class PLMXML60_API GeometryComposition : public EntityObject
{
public:
     
    //! Default constructor
    GeometryComposition( );
     
    //! Constructs a GeometryComposition with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    GeometryComposition( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~GeometryComposition();

private:

	//! Assignment operator
	GeometryComposition& operator=( const GeometryComposition& iSrc );

	//! Copy constructor
	GeometryComposition( const GeometryComposition& original );
     
public:

	//! Set TextHeight
	plmxml_api::Result SetTextHeight( double arg );

     //! Get TextHeight
	double GetTextHeight() const;

	//! Check if TextHeight is set
	plmxml_api::logical HasTextHeight() const;

	//! Unset TextHeight
	plmxml_api::Result UnsetTextHeight();

	//! Get Font of this GeometryComposition
	plmxml_api::String GetFont() const;

	//! Set Font of this GeometryComposition
	plmxml_api::Result SetFont( const plmxml_api::String &s );
	
	//! Check if Font is set
	plmxml_api::logical HasFont( ) const;
	
	//! Unset Font
	plmxml_api::Result UnsetFont( );

	//! Add LocalCoordinateSystem child element to this GeometryComposition. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	CoordinateSystem *AddLocalCoordinateSystem();
     
	//! Set LocalCoordinateSystem child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetLocalCoordinateSystem( CoordinateSystem *arg );
     
	//! Get LocalCoordinateSystem child element of this GeometryComposition.
	CoordinateSystem *GetLocalCoordinateSystem() const;
     
	//! Detach and delete LocalCoordinateSystem child element tree from this GeometryComposition.
	void DeleteLocalCoordinateSystem();

	//! Add Point child element to this GeometryComposition. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Point *AddPoint();
     
	//! Add 'arg' as Point child element to this GeometryComposition.
	plmxml_api::Result AddPoint( Point *arg );

	//! Detach and delete all Point child elements.
	void DeletePoints();
     
	//! Get number of Point child elements.
	int NumberOfPoints() const;
     
	//! Get i'th Point child element.
	Point *GetPoint( int i ) const;
     
	//! Get all Point child element as an array
	void GetPoints( plmxml_api::Array<Point*> &array ) const;
	     
	//! Detach and delete i'th Point child element
	void DeletePoint( int i );
     
	//! Detach and delete 'arg' if it's one of the Point child elements
	void DeletePoint( Point *arg );

	//! Add Curve child element to this GeometryComposition. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Curve *AddCurve();
     
	//! Add 'arg' as Curve child element to this GeometryComposition.
	plmxml_api::Result AddCurve( Curve *arg );

	//! Detach and delete all Curve child elements.
	void DeleteCurves();
     
	//! Get number of Curve child elements.
	int NumberOfCurves() const;
     
	//! Get i'th Curve child element.
	Curve *GetCurve( int i ) const;
     
	//! Get all Curve child element as an array
	void GetCurves( plmxml_api::Array<Curve*> &array ) const;
	     
	//! Detach and delete i'th Curve child element
	void DeleteCurve( int i );
     
	//! Detach and delete 'arg' if it's one of the Curve child elements
	void DeleteCurve( Curve *arg );

	//! Add Surface child element to this GeometryComposition. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Surface *AddSurface();
     
	//! Add 'arg' as Surface child element to this GeometryComposition.
	plmxml_api::Result AddSurface( Surface *arg );

	//! Detach and delete all Surface child elements.
	void DeleteSurfaces();
     
	//! Get number of Surface child elements.
	int NumberOfSurfaces() const;
     
	//! Get i'th Surface child element.
	Surface *GetSurface( int i ) const;
     
	//! Get all Surface child element as an array
	void GetSurfaces( plmxml_api::Array<Surface*> &array ) const;
	     
	//! Detach and delete i'th Surface child element
	void DeleteSurface( int i );
     
	//! Detach and delete 'arg' if it's one of the Surface child elements
	void DeleteSurface( Surface *arg );

	//! Add CoordinateSystem child element to this GeometryComposition. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	CoordinateSystem *AddCoordinateSystem();
     
	//! Add 'arg' as CoordinateSystem child element to this GeometryComposition.
	plmxml_api::Result AddCoordinateSystem( CoordinateSystem *arg );

	//! Detach and delete all CoordinateSystem child elements.
	void DeleteCoordinateSystems();
     
	//! Get number of CoordinateSystem child elements.
	int NumberOfCoordinateSystems() const;
     
	//! Get i'th CoordinateSystem child element.
	CoordinateSystem *GetCoordinateSystem( int i ) const;
     
	//! Get all CoordinateSystem child element as an array
	void GetCoordinateSystems( plmxml_api::Array<CoordinateSystem*> &array ) const;
	     
	//! Detach and delete i'th CoordinateSystem child element
	void DeleteCoordinateSystem( int i );
     
	//! Detach and delete 'arg' if it's one of the CoordinateSystem child elements
	void DeleteCoordinateSystem( CoordinateSystem *arg );
 
// <PLMXML_UserCode type="functionHeaderGeometryComposition" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassGeometryComposition;


////////////////////////////////////////////////////////////////////////////////////
//! ConstructionGeometry class
/*!
\verbatim

      Top level construction geometry element.

      Attributes:

      purpose:       The purpose or function of the geometry when this complex
                     type is used as a Geometry sub-element of an Ann3DDisplay.
      font:          The default font for all glyph representations contained in
                     the Geometry.
      textHeight:    The default height in metres for all glyph representations
                     contained in the Geometry.

      Elements:

      Point:         any elements derived from Point.
      Curve:         any elements derived from Curve.
      Surface:       any elements derived from Surface.
      CoordinateSystem:     coordinate systems.
      GeometryComposition:  geometry compositions.
      
\endverbatim
*/
class PLMXML60_API ConstructionGeometry : public EntityObject
{
public:
     
    //! Default constructor
    ConstructionGeometry( );
     
    //! Constructs a ConstructionGeometry with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ConstructionGeometry( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ConstructionGeometry();

private:

	//! Assignment operator
	ConstructionGeometry& operator=( const ConstructionGeometry& iSrc );

	//! Copy constructor
	ConstructionGeometry( const ConstructionGeometry& original );
     
public:

	//! Set Purpose
	plmxml_api::Result SetPurpose( const eGeometryPurposeEnum& arg );

	//! Get Purpose
	eGeometryPurposeEnum GetPurpose() const;

	//! Set TextHeight
	plmxml_api::Result SetTextHeight( double arg );

     //! Get TextHeight
	double GetTextHeight() const;

	//! Check if TextHeight is set
	plmxml_api::logical HasTextHeight() const;

	//! Unset TextHeight
	plmxml_api::Result UnsetTextHeight();

	//! Get Font of this ConstructionGeometry
	plmxml_api::String GetFont() const;

	//! Set Font of this ConstructionGeometry
	plmxml_api::Result SetFont( const plmxml_api::String &s );
	
	//! Check if Font is set
	plmxml_api::logical HasFont( ) const;
	
	//! Unset Font
	plmxml_api::Result UnsetFont( );

	//! Add Point child element to this ConstructionGeometry. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Point *AddPoint();
     
	//! Add 'arg' as Point child element to this ConstructionGeometry.
	plmxml_api::Result AddPoint( Point *arg );

	//! Detach and delete all Point child elements.
	void DeletePoints();
     
	//! Get number of Point child elements.
	int NumberOfPoints() const;
     
	//! Get i'th Point child element.
	Point *GetPoint( int i ) const;
     
	//! Get all Point child element as an array
	void GetPoints( plmxml_api::Array<Point*> &array ) const;
	     
	//! Detach and delete i'th Point child element
	void DeletePoint( int i );
     
	//! Detach and delete 'arg' if it's one of the Point child elements
	void DeletePoint( Point *arg );

	//! Add Curve child element to this ConstructionGeometry. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Curve *AddCurve();
     
	//! Add 'arg' as Curve child element to this ConstructionGeometry.
	plmxml_api::Result AddCurve( Curve *arg );

	//! Detach and delete all Curve child elements.
	void DeleteCurves();
     
	//! Get number of Curve child elements.
	int NumberOfCurves() const;
     
	//! Get i'th Curve child element.
	Curve *GetCurve( int i ) const;
     
	//! Get all Curve child element as an array
	void GetCurves( plmxml_api::Array<Curve*> &array ) const;
	     
	//! Detach and delete i'th Curve child element
	void DeleteCurve( int i );
     
	//! Detach and delete 'arg' if it's one of the Curve child elements
	void DeleteCurve( Curve *arg );

	//! Add Surface child element to this ConstructionGeometry. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Surface *AddSurface();
     
	//! Add 'arg' as Surface child element to this ConstructionGeometry.
	plmxml_api::Result AddSurface( Surface *arg );

	//! Detach and delete all Surface child elements.
	void DeleteSurfaces();
     
	//! Get number of Surface child elements.
	int NumberOfSurfaces() const;
     
	//! Get i'th Surface child element.
	Surface *GetSurface( int i ) const;
     
	//! Get all Surface child element as an array
	void GetSurfaces( plmxml_api::Array<Surface*> &array ) const;
	     
	//! Detach and delete i'th Surface child element
	void DeleteSurface( int i );
     
	//! Detach and delete 'arg' if it's one of the Surface child elements
	void DeleteSurface( Surface *arg );

	//! Add CoordinateSystem child element to this ConstructionGeometry. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	CoordinateSystem *AddCoordinateSystem();
     
	//! Add 'arg' as CoordinateSystem child element to this ConstructionGeometry.
	plmxml_api::Result AddCoordinateSystem( CoordinateSystem *arg );

	//! Detach and delete all CoordinateSystem child elements.
	void DeleteCoordinateSystems();
     
	//! Get number of CoordinateSystem child elements.
	int NumberOfCoordinateSystems() const;
     
	//! Get i'th CoordinateSystem child element.
	CoordinateSystem *GetCoordinateSystem( int i ) const;
     
	//! Get all CoordinateSystem child element as an array
	void GetCoordinateSystems( plmxml_api::Array<CoordinateSystem*> &array ) const;
	     
	//! Detach and delete i'th CoordinateSystem child element
	void DeleteCoordinateSystem( int i );
     
	//! Detach and delete 'arg' if it's one of the CoordinateSystem child elements
	void DeleteCoordinateSystem( CoordinateSystem *arg );

	//! Add GeometryComposition child element to this ConstructionGeometry. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	GeometryComposition *AddGeometryComposition();
     
	//! Add 'arg' as GeometryComposition child element to this ConstructionGeometry.
	plmxml_api::Result AddGeometryComposition( GeometryComposition *arg );

	//! Detach and delete all GeometryComposition child elements.
	void DeleteGeometryCompositions();
     
	//! Get number of GeometryComposition child elements.
	int NumberOfGeometryCompositions() const;
     
	//! Get i'th GeometryComposition child element.
	GeometryComposition *GetGeometryComposition( int i ) const;
     
	//! Get all GeometryComposition child element as an array
	void GetGeometryCompositions( plmxml_api::Array<GeometryComposition*> &array ) const;
	     
	//! Detach and delete i'th GeometryComposition child element
	void DeleteGeometryComposition( int i );
     
	//! Detach and delete 'arg' if it's one of the GeometryComposition child elements
	void DeleteGeometryComposition( GeometryComposition *arg );
 
// <PLMXML_UserCode type="functionHeaderConstructionGeometry" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassConstructionGeometry;


////////////////////////////////////////////////////////////////////////////////////
//! Perspective class
/*!
\verbatim

      Defines a perspective view from a point.
      
      Elements:
      
      ViewFrom:        eye point
      ViewTo:          point towards which eye is looking
      ViewVertical:    vector which is vertical in the view. Should be
                       perpendicular to (ViewFrom - ViewTo).
      
\endverbatim
*/
class PLMXML60_API Perspective : public plmxml_api::Object
{
public:
     
    //! Default constructor
    Perspective( );
     
    //! Constructs a Perspective with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Perspective( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Perspective();

private:

	//! Assignment operator
	Perspective& operator=( const Perspective& iSrc );

	//! Copy constructor
	Perspective( const Perspective& original );
     
public:

	//! Set ViewFrom using plmxml_api::Vector components
	plmxml_api::Result SetViewFrom( const plmxml_api::Vector& arg );

	//! Get ViewFrom as plmxml_api::Vector
	plmxml_api::Result GetViewFrom( plmxml_api::Vector& arg ) const;

	//! Check if ViewFrom is set
	plmxml_api::logical HasViewFrom() const;

	//! Unset ViewFrom
	plmxml_api::Result UnsetViewFrom();

	//! Set ViewTo using plmxml_api::Vector components
	plmxml_api::Result SetViewTo( const plmxml_api::Vector& arg );

	//! Get ViewTo as plmxml_api::Vector
	plmxml_api::Result GetViewTo( plmxml_api::Vector& arg ) const;

	//! Check if ViewTo is set
	plmxml_api::logical HasViewTo() const;

	//! Unset ViewTo
	plmxml_api::Result UnsetViewTo();

	//! Set ViewVertical using plmxml_api::Vector components
	plmxml_api::Result SetViewVertical( const plmxml_api::Vector& arg );

	//! Get ViewVertical as plmxml_api::Vector
	plmxml_api::Result GetViewVertical( plmxml_api::Vector& arg ) const;

	//! Check if ViewVertical is set
	plmxml_api::logical HasViewVertical() const;

	//! Unset ViewVertical
	plmxml_api::Result UnsetViewVertical();
 
// <PLMXML_UserCode type="functionHeaderPerspective" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassPerspective;


////////////////////////////////////////////////////////////////////////////////////
//! Orthographic class
/*!
\verbatim

      Defines a view from infinity (no perspective).
      
      Elements:
      
      ViewDirection:   direction eye is looking in.
      ViewVertical:    vector which is vertical in the view. Should be
                       perpendicular to ViewDirection.
      ViewTo:          optional point at which eye is looking, only needed
                       if depth is significant in the view.
      
\endverbatim
*/
class PLMXML60_API Orthographic : public plmxml_api::Object
{
public:
     
    //! Default constructor
    Orthographic( );
     
    //! Constructs a Orthographic with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Orthographic( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Orthographic();

private:

	//! Assignment operator
	Orthographic& operator=( const Orthographic& iSrc );

	//! Copy constructor
	Orthographic( const Orthographic& original );
     
public:

	//! Set ViewDirection using plmxml_api::Vector components
	plmxml_api::Result SetViewDirection( const plmxml_api::Vector& arg );

	//! Get ViewDirection as plmxml_api::Vector
	plmxml_api::Result GetViewDirection( plmxml_api::Vector& arg ) const;

	//! Check if ViewDirection is set
	plmxml_api::logical HasViewDirection() const;

	//! Unset ViewDirection
	plmxml_api::Result UnsetViewDirection();

	//! Set ViewVertical using plmxml_api::Vector components
	plmxml_api::Result SetViewVertical( const plmxml_api::Vector& arg );

	//! Get ViewVertical as plmxml_api::Vector
	plmxml_api::Result GetViewVertical( plmxml_api::Vector& arg ) const;

	//! Check if ViewVertical is set
	plmxml_api::logical HasViewVertical() const;

	//! Unset ViewVertical
	plmxml_api::Result UnsetViewVertical();

	//! Set ViewTo using plmxml_api::Vector components
	plmxml_api::Result SetViewTo( const plmxml_api::Vector& arg );

	//! Get ViewTo as plmxml_api::Vector
	plmxml_api::Result GetViewTo( plmxml_api::Vector& arg ) const;

	//! Check if ViewTo is set
	plmxml_api::logical HasViewTo() const;

	//! Unset ViewTo
	plmxml_api::Result UnsetViewTo();
 
// <PLMXML_UserCode type="functionHeaderOrthographic" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassOrthographic;


////////////////////////////////////////////////////////////////////////////////////
//! ViewPort class
/*!
\verbatim

      Defines a window on the viewing plane.

      The BackgroundColour sub-elements take precedence over the
      backgroundColour attribute on any DisplayControl.

      Sub-elements:

      ViewPortLow:              The bottom left corner of the window.
      ViewPortHigh:             The top right corner of the window.
      BottomLeftBackgroundColour: The background colour at the bottom left
                                corner.
      BottomRightBackgroundColour: The background colour at the bottom right
                                corner.
      TopLeftBackgroundColour: The background colour at the top left corner.
      TopRightBackgroundColour: The background colour at the top right corner.
      
\endverbatim
*/
class PLMXML60_API ViewPort : public plmxml_api::Object
{
public:
     
    //! Default constructor
    ViewPort( );
     
    //! Constructs a ViewPort with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ViewPort( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ViewPort();

private:

	//! Assignment operator
	ViewPort& operator=( const ViewPort& iSrc );

	//! Copy constructor
	ViewPort( const ViewPort& original );
     
public:

	//! Set ViewPortLow array
	plmxml_api::Result SetViewPortLow( const double *arg );

	//! Get ViewPortLow array
	plmxml_api::Result GetViewPortLow( double *arg ) const;

	//! Check if ViewPortLow array is set
	plmxml_api::logical HasViewPortLow() const;

	//! Unset ViewPortLow array
	plmxml_api::Result UnsetViewPortLow();

	//! Set ViewPortHigh array
	plmxml_api::Result SetViewPortHigh( const double *arg );

	//! Get ViewPortHigh array
	plmxml_api::Result GetViewPortHigh( double *arg ) const;

	//! Check if ViewPortHigh array is set
	plmxml_api::logical HasViewPortHigh() const;

	//! Unset ViewPortHigh array
	plmxml_api::Result UnsetViewPortHigh();

	//! Set BottomLeftBackgroundColour array
	plmxml_api::Result SetBottomLeftBackgroundColour( const double *arg );

	//! Get BottomLeftBackgroundColour array
	plmxml_api::Result GetBottomLeftBackgroundColour( double *arg ) const;

	//! Check if BottomLeftBackgroundColour array is set
	plmxml_api::logical HasBottomLeftBackgroundColour() const;

	//! Unset BottomLeftBackgroundColour array
	plmxml_api::Result UnsetBottomLeftBackgroundColour();

	//! Set BottomRightBackgroundColour array
	plmxml_api::Result SetBottomRightBackgroundColour( const double *arg );

	//! Get BottomRightBackgroundColour array
	plmxml_api::Result GetBottomRightBackgroundColour( double *arg ) const;

	//! Check if BottomRightBackgroundColour array is set
	plmxml_api::logical HasBottomRightBackgroundColour() const;

	//! Unset BottomRightBackgroundColour array
	plmxml_api::Result UnsetBottomRightBackgroundColour();

	//! Set TopLeftBackgroundColour array
	plmxml_api::Result SetTopLeftBackgroundColour( const double *arg );

	//! Get TopLeftBackgroundColour array
	plmxml_api::Result GetTopLeftBackgroundColour( double *arg ) const;

	//! Check if TopLeftBackgroundColour array is set
	plmxml_api::logical HasTopLeftBackgroundColour() const;

	//! Unset TopLeftBackgroundColour array
	plmxml_api::Result UnsetTopLeftBackgroundColour();

	//! Set TopRightBackgroundColour array
	plmxml_api::Result SetTopRightBackgroundColour( const double *arg );

	//! Get TopRightBackgroundColour array
	plmxml_api::Result GetTopRightBackgroundColour( double *arg ) const;

	//! Check if TopRightBackgroundColour array is set
	plmxml_api::logical HasTopRightBackgroundColour() const;

	//! Unset TopRightBackgroundColour array
	plmxml_api::Result UnsetTopRightBackgroundColour();
 
// <PLMXML_UserCode type="functionHeaderViewPort" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassViewPort;


////////////////////////////////////////////////////////////////////////////////////
//! ViewControl class
/*!
\verbatim

      Defines a view, i.e. a camera position and optional viewport.
      
      Elements:
      
      One of Perspective, Orthographic or ViewMatrix (4 by 4).
      
      ViewPort:        optional viewport definition.
      
\endverbatim
*/
class PLMXML60_API ViewControl : public DescriptionObject
{
public:
     
    //! Default constructor
    ViewControl( );
     
    //! Constructs a ViewControl with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ViewControl( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ViewControl();

private:

	//! Assignment operator
	ViewControl& operator=( const ViewControl& iSrc );

	//! Copy constructor
	ViewControl( const ViewControl& original );
     
public:

	//! Add Perspective child element to this ViewControl. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	Perspective *AddPerspective();
     
	//! Set Perspective child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetPerspective( Perspective *arg );
     
	//! Get Perspective child element of this ViewControl.
	Perspective *GetPerspective() const;
     
	//! Detach and delete Perspective child element tree from this ViewControl.
	void DeletePerspective();

	//! Add Orthographic child element to this ViewControl. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	Orthographic *AddOrthographic();
     
	//! Set Orthographic child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetOrthographic( Orthographic *arg );
     
	//! Get Orthographic child element of this ViewControl.
	Orthographic *GetOrthographic() const;
     
	//! Detach and delete Orthographic child element tree from this ViewControl.
	void DeleteOrthographic();

	//! Set ViewMatrix using plmxml_api::Transf
	plmxml_api::Result SetViewMatrix( const plmxml_api::Transf& arg );

	//! Get ViewMatrix as plmxml_api::Transf
	plmxml_api::Result GetViewMatrix( plmxml_api::Transf& arg ) const;

	//! Check if ViewMatrix is set
	plmxml_api::logical HasViewMatrix() const;

	//! Unset ViewMatrix
	plmxml_api::Result UnsetViewMatrix();

	//! Add ViewPort child element to this ViewControl. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	ViewPort *AddViewPort();
     
	//! Set ViewPort child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetViewPort( ViewPort *arg );
     
	//! Get ViewPort child element of this ViewControl.
	ViewPort *GetViewPort() const;
     
	//! Detach and delete ViewPort child element tree from this ViewControl.
	void DeleteViewPort();
 
// <PLMXML_UserCode type="functionHeaderViewControl" >
    
	//! Set ViewPort high corner.
	void SetViewPortHigh( double ViewPortHigh[2] );

	//! GetViewPort high corner.
	plmxml_api::logical GetViewPortHigh( double ViewPortHigh[2] ) const;

	//! Set ViewPort low corner.
	void SetViewPortLow( double ViewPortLow[2] );

	//! Get ViewPort low corner.
    plmxml_api::logical GetViewPortLow( double ViewPortLow[2] ) const;

	//! Set vector to view from.
	void  SetViewFrom(const plmxml_api::Vector &v); 

	//! Get vector to view from.
	plmxml_api::logical  GetViewFrom(plmxml_api::Vector &v) const;
  
	//! Set vector to view to.
	void SetViewTo(const plmxml_api::Vector &v);
  
	//! Get vector to view to.
	plmxml_api::logical  GetViewTo(plmxml_api::Vector &v) const;
  
	//! Set view vertical vector.
	void  SetViewVertical(const plmxml_api::Vector &v);
 
	//! Get view vertical vector.
	plmxml_api::logical  GetViewVertical(plmxml_api::Vector &v) const;
  
	//! Set view direction.
	void  SetViewDirection(const plmxml_api::Vector &v);

	//! Get view direction.
	plmxml_api::logical  GetViewDirection(plmxml_api::Vector &v) const;

// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassViewControl;


////////////////////////////////////////////////////////////////////////////////////
//! Texture1DData class
/*!
\verbatim

      Basic 1D texture data definition 
      
\endverbatim
*/
class PLMXML60_API Texture1DData : public plmxml_api::Object
{
public:
     
    //! Default constructor
    Texture1DData( );
     
    //! Constructs a Texture1DData with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Texture1DData( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Texture1DData();

private:

	//! Assignment operator
	Texture1DData& operator=( const Texture1DData& iSrc );

	//! Copy constructor
	Texture1DData( const Texture1DData& original );
     
public:

	//! Set Level
	plmxml_api::Result SetLevel( int arg );
     
	//! Get Level
	int GetLevel() const;
     
	//! Check if Level is set
	plmxml_api::logical HasLevel() const;
     
	//! Unset Level
	plmxml_api::Result UnsetLevel();

	//! Set Width
	plmxml_api::Result SetWidth( int arg );
     
	//! Get Width
	int GetWidth() const;
     
	//! Check if Width is set
	plmxml_api::logical HasWidth() const;
     
	//! Unset Width
	plmxml_api::Result UnsetWidth();

	//! Get Location URI as plmxml_api::String
	plmxml_api::String GetLocationURI() const;

	//! Set Location URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetLocationURI( const plmxml_api::String& );
	
	//! Get the handle of Location URI. Does not resolve the URI.
	plmxml_api::Result GetLocationURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Location URI. URI string is unchanged.
	plmxml_api::Result SetLocationURI( const plmxml_api::Handle& );
	
	//! Resolve Location URI and return an object (handle) it points to.
	plmxml_api::Result ResolveLocationURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Location URI. Clears URI string and handle.
	plmxml_api::Result DeleteLocationURI();
	
	//! Check if Location URI is set
	plmxml_api::logical HasLocationURI( ) const;
	

	//! Set Border
	plmxml_api::Result SetBorder( int arg );
     
	//! Get Border
	int GetBorder() const;
     
	//! Check if Border is set
	plmxml_api::logical HasBorder() const;
     
	//! Unset Border
	plmxml_api::Result UnsetBorder();
 
// <PLMXML_UserCode type="functionHeaderTexture1DData" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassTexture1DData;


////////////////////////////////////////////////////////////////////////////////////
//! Texture1D class
/*!
\verbatim

\endverbatim
*/
class PLMXML60_API Texture1D : public plmxml_api::Object
{
public:
     
    //! Default constructor
    Texture1D( );
     
    //! Constructs a Texture1D with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Texture1D( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Texture1D();

private:

	//! Assignment operator
	Texture1D& operator=( const Texture1D& iSrc );

	//! Copy constructor
	Texture1D( const Texture1D& original );
     
public:

	//! Set Levels
	plmxml_api::Result SetLevels( int arg );
     
	//! Get Levels
	int GetLevels() const;
     
	//! Check if Levels is set
	plmxml_api::logical HasLevels() const;
     
	//! Unset Levels
	plmxml_api::Result UnsetLevels();

	//! Set Format
	plmxml_api::Result SetFormat( const eTextureDataFormatType& arg );

	//! Get Format
	eTextureDataFormatType GetFormat() const;

	//! Add Data child element to this Texture1D. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Texture1DData *AddData();
     
	//! Add 'arg' as Data child element to this Texture1D.
	plmxml_api::Result AddData( Texture1DData *arg );

	//! Detach and delete all Data child elements.
	void DeleteDatas();
     
	//! Get number of Data child elements.
	int NumberOfDatas() const;
     
	//! Get i'th Data child element.
	Texture1DData *GetData( int i ) const;
     
	//! Get all Data child element as an array
	void GetDatas( plmxml_api::Array<Texture1DData*> &array ) const;
	     
	//! Detach and delete i'th Data child element
	void DeleteData( int i );
     
	//! Detach and delete 'arg' if it's one of the Data child elements
	void DeleteData( Texture1DData *arg );
 
// <PLMXML_UserCode type="functionHeaderTexture1D" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassTexture1D;


////////////////////////////////////////////////////////////////////////////////////
//! Texture2DData class
/*!
\verbatim

      Basic 2D texture data definition
      
\endverbatim
*/
class PLMXML60_API Texture2DData : public plmxml_api::Object
{
public:
     
    //! Default constructor
    Texture2DData( );
     
    //! Constructs a Texture2DData with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Texture2DData( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Texture2DData();

private:

	//! Assignment operator
	Texture2DData& operator=( const Texture2DData& iSrc );

	//! Copy constructor
	Texture2DData( const Texture2DData& original );
     
public:

	//! Set Level
	plmxml_api::Result SetLevel( int arg );
     
	//! Get Level
	int GetLevel() const;
     
	//! Check if Level is set
	plmxml_api::logical HasLevel() const;
     
	//! Unset Level
	plmxml_api::Result UnsetLevel();

	//! Set Width
	plmxml_api::Result SetWidth( int arg );
     
	//! Get Width
	int GetWidth() const;
     
	//! Check if Width is set
	plmxml_api::logical HasWidth() const;
     
	//! Unset Width
	plmxml_api::Result UnsetWidth();

	//! Get Location URI as plmxml_api::String
	plmxml_api::String GetLocationURI() const;

	//! Set Location URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetLocationURI( const plmxml_api::String& );
	
	//! Get the handle of Location URI. Does not resolve the URI.
	plmxml_api::Result GetLocationURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Location URI. URI string is unchanged.
	plmxml_api::Result SetLocationURI( const plmxml_api::Handle& );
	
	//! Resolve Location URI and return an object (handle) it points to.
	plmxml_api::Result ResolveLocationURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Location URI. Clears URI string and handle.
	plmxml_api::Result DeleteLocationURI();
	
	//! Check if Location URI is set
	plmxml_api::logical HasLocationURI( ) const;
	

	//! Set Height
	plmxml_api::Result SetHeight( int arg );
     
	//! Get Height
	int GetHeight() const;
     
	//! Check if Height is set
	plmxml_api::logical HasHeight() const;
     
	//! Unset Height
	plmxml_api::Result UnsetHeight();

	//! Set Border
	plmxml_api::Result SetBorder( int arg );
     
	//! Get Border
	int GetBorder() const;
     
	//! Check if Border is set
	plmxml_api::logical HasBorder() const;
     
	//! Unset Border
	plmxml_api::Result UnsetBorder();
 
// <PLMXML_UserCode type="functionHeaderTexture2DData" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassTexture2DData;


////////////////////////////////////////////////////////////////////////////////////
//! Texture2D class
/*!
\verbatim

\endverbatim
*/
class PLMXML60_API Texture2D : public plmxml_api::Object
{
public:
     
    //! Default constructor
    Texture2D( );
     
    //! Constructs a Texture2D with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Texture2D( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Texture2D();

private:

	//! Assignment operator
	Texture2D& operator=( const Texture2D& iSrc );

	//! Copy constructor
	Texture2D( const Texture2D& original );
     
public:

	//! Set Levels
	plmxml_api::Result SetLevels( int arg );
     
	//! Get Levels
	int GetLevels() const;
     
	//! Check if Levels is set
	plmxml_api::logical HasLevels() const;
     
	//! Unset Levels
	plmxml_api::Result UnsetLevels();

	//! Set Format
	plmxml_api::Result SetFormat( const eTextureDataFormatType& arg );

	//! Get Format
	eTextureDataFormatType GetFormat() const;

	//! Add Data child element to this Texture2D. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Texture2DData *AddData();
     
	//! Add 'arg' as Data child element to this Texture2D.
	plmxml_api::Result AddData( Texture2DData *arg );

	//! Detach and delete all Data child elements.
	void DeleteDatas();
     
	//! Get number of Data child elements.
	int NumberOfDatas() const;
     
	//! Get i'th Data child element.
	Texture2DData *GetData( int i ) const;
     
	//! Get all Data child element as an array
	void GetDatas( plmxml_api::Array<Texture2DData*> &array ) const;
	     
	//! Detach and delete i'th Data child element
	void DeleteData( int i );
     
	//! Detach and delete 'arg' if it's one of the Data child elements
	void DeleteData( Texture2DData *arg );
 
// <PLMXML_UserCode type="functionHeaderTexture2D" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassTexture2D;


////////////////////////////////////////////////////////////////////////////////////
//! TextureData class
/*!
\verbatim

      Basic texture data definition 
      
\endverbatim
*/
class PLMXML60_API TextureData : public AttribOwner
{
public:
     
    //! Default constructor
    TextureData( );
     
    //! Constructs a TextureData with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    TextureData( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~TextureData();

private:

	//! Assignment operator
	TextureData& operator=( const TextureData& iSrc );

	//! Copy constructor
	TextureData( const TextureData& original );
     
public:

	//! Add Texture2D child element to this TextureData. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	Texture2D *AddTexture2D();
     
	//! Set Texture2D child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetTexture2D( Texture2D *arg );
     
	//! Get Texture2D child element of this TextureData.
	Texture2D *GetTexture2D() const;
     
	//! Detach and delete Texture2D child element tree from this TextureData.
	void DeleteTexture2D();

	//! Add Texture1D child element to this TextureData. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	Texture1D *AddTexture1D();
     
	//! Set Texture1D child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetTexture1D( Texture1D *arg );
     
	//! Get Texture1D child element of this TextureData.
	Texture1D *GetTexture1D() const;
     
	//! Detach and delete Texture1D child element tree from this TextureData.
	void DeleteTexture1D();
 
// <PLMXML_UserCode type="functionHeaderTextureData" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassTextureData;


////////////////////////////////////////////////////////////////////////////////////
//! Texture class
/*!
\verbatim

      Basic texture definition
      
\endverbatim
*/
class PLMXML60_API Texture : public AttribOwner
{
public:
     
    //! Default constructor
    Texture( );
     
    //! Constructs a Texture with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Texture( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Texture();

private:

	//! Assignment operator
	Texture& operator=( const Texture& iSrc );

	//! Copy constructor
	Texture( const Texture& original );
     
public:

	//! Set reference to Data using 'arg's plmxml_api::Id.
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical SetDataRef( plmxml60::IdObject *arg );

	//! Clear reference to Data
	void RemoveDataRef( );

	//! Find a plmxml60::IdObject referenced by Data
	plmxml60::IdObject *ResolveDataRef( plmxml_api::Configuration* config = NULL );

	//! Get Data reference
	plmxml_api::String GetDataId() const;

	//! Set Data reference.
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical SetDataId( const plmxml_api::String& u );
	
	//! Check if Data is set
	plmxml_api::logical HasDataRef( ) const;

	//! Set SubsamplingLow
	plmxml_api::Result SetSubsamplingLow( const eTextureSampleType& arg );

	//! Get SubsamplingLow
	eTextureSampleType GetSubsamplingLow() const;

	//! Set Wrapping
	plmxml_api::Result SetWrapping( const eTextureWrapType& arg );

	//! Get Wrapping
	eTextureWrapType GetWrapping() const;

	//! Set Oversampling
	plmxml_api::Result SetOversampling( const eTextureSampleType& arg );

	//! Get Oversampling
	eTextureSampleType GetOversampling() const;

	//! Set BorderColour array
	plmxml_api::Result SetBorderColour( const double *arg );

	//! Get BorderColour array
	plmxml_api::Result GetBorderColour( double *arg ) const;

	//! Check if BorderColour array is set
	plmxml_api::logical HasBorderColour() const;

	//! Unset BorderColour array
	plmxml_api::Result UnsetBorderColour();

	//! Set Mapping
	plmxml_api::Result SetMapping( const eTextureMapType& arg );

	//! Get Mapping
	eTextureMapType GetMapping() const;

	//! Set SubsamplingHigh
	plmxml_api::Result SetSubsamplingHigh( const eTextureSampleType& arg );

	//! Get SubsamplingHigh
	eTextureSampleType GetSubsamplingHigh() const;

	//! Add TextureData child element to this Texture. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	TextureData *AddTextureData();
     
	//! Set TextureData child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetTextureData( TextureData *arg );
     
	//! Get TextureData child element of this Texture.
	TextureData *GetTextureData() const;
     
	//! Detach and delete TextureData child element tree from this Texture.
	void DeleteTextureData();
 
// <PLMXML_UserCode type="functionHeaderTexture" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassTexture;


////////////////////////////////////////////////////////////////////////////////////
//! TextureCoord class
/*!
\verbatim

\endverbatim
*/
class PLMXML60_API TextureCoord : public IdObject
{
public:
     
    //! Default constructor
    TextureCoord( );
     
    //! Constructs a TextureCoord with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    TextureCoord( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~TextureCoord();

private:

	//! Assignment operator
	TextureCoord& operator=( const TextureCoord& iSrc );

	//! Copy constructor
	TextureCoord( const TextureCoord& original );
     
public:

	//! Set reference to Texture using 'arg's plmxml_api::Id.
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical SetTextureRef( plmxml60::IdObject *arg );

	//! Clear reference to Texture
	void RemoveTextureRef( );

	//! Find a plmxml60::IdObject referenced by Texture
	plmxml60::IdObject *ResolveTextureRef( plmxml_api::Configuration* config = NULL );

	//! Get Texture reference
	plmxml_api::String GetTextureId() const;

	//! Set Texture reference.
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical SetTextureId( const plmxml_api::String& u );
	
	//! Check if Texture is set
	plmxml_api::logical HasTextureRef( ) const;

	//! Set GeometryCoord using plmxml_api::Vector components
	plmxml_api::Result SetGeometryCoord( const plmxml_api::Vector& arg );

	//! Get GeometryCoord as plmxml_api::Vector
	plmxml_api::Result GetGeometryCoord( plmxml_api::Vector& arg ) const;

	//! Check if GeometryCoord is set
	plmxml_api::logical HasGeometryCoord() const;

	//! Unset GeometryCoord
	plmxml_api::Result UnsetGeometryCoord();

	//! Set GeometryParam array
	plmxml_api::Result SetGeometryParam( const double *arg );

	//! Get GeometryParam array
	plmxml_api::Result GetGeometryParam( double *arg ) const;

	//! Check if GeometryParam array is set
	plmxml_api::logical HasGeometryParam() const;

	//! Unset GeometryParam array
	plmxml_api::Result UnsetGeometryParam();
 
// <PLMXML_UserCode type="functionHeaderTextureCoord" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassTextureCoord;


////////////////////////////////////////////////////////////////////////////////////
//! MappingGeometry class
/*!
\verbatim

      Simple intermediate mapping geometry for a texture.

      Attributes:

      type:             The type of mapping geometry.
      width:            The width of a mapping plane in entity units.
      height:           The height of a mapping plane or cylinder in entity
                        units.
      horizontalAngle:  The horizontal sweep angle of a mapping cylinder or
                        sphere in radians.
      verticalAngle:    The vertical sweep angle of a mapping sphere in radians.
      length:           The length of a mapping triplanar in entity units.

      Sub-elements:

      Transform:        The transform from the mapping coordinate system to the
                        entity geometry coordinate system.
      
\endverbatim
*/
class PLMXML60_API MappingGeometry : public AttribOwner
{
public:
     
    //! Default constructor
    MappingGeometry( );
     
    //! Constructs a MappingGeometry with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    MappingGeometry( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~MappingGeometry();

private:

	//! Assignment operator
	MappingGeometry& operator=( const MappingGeometry& iSrc );

	//! Copy constructor
	MappingGeometry( const MappingGeometry& original );
     
public:

	//! Set VerticalAngle
	plmxml_api::Result SetVerticalAngle( double arg );

     //! Get VerticalAngle
	double GetVerticalAngle() const;

	//! Check if VerticalAngle is set
	plmxml_api::logical HasVerticalAngle() const;

	//! Unset VerticalAngle
	plmxml_api::Result UnsetVerticalAngle();

	//! Set HorizontalAngle
	plmxml_api::Result SetHorizontalAngle( double arg );

     //! Get HorizontalAngle
	double GetHorizontalAngle() const;

	//! Check if HorizontalAngle is set
	plmxml_api::logical HasHorizontalAngle() const;

	//! Unset HorizontalAngle
	plmxml_api::Result UnsetHorizontalAngle();

	//! Set Height
	plmxml_api::Result SetHeight( double arg );

     //! Get Height
	double GetHeight() const;

	//! Check if Height is set
	plmxml_api::logical HasHeight() const;

	//! Unset Height
	plmxml_api::Result UnsetHeight();

	//! Set Length
	plmxml_api::Result SetLength( double arg );

     //! Get Length
	double GetLength() const;

	//! Check if Length is set
	plmxml_api::logical HasLength() const;

	//! Unset Length
	plmxml_api::Result UnsetLength();

	//! Set Type
	plmxml_api::Result SetType( const eMappingGeometryEnum& arg );

	//! Get Type
	eMappingGeometryEnum GetType() const;

	//! Set Width
	plmxml_api::Result SetWidth( double arg );

     //! Get Width
	double GetWidth() const;

	//! Check if Width is set
	plmxml_api::logical HasWidth() const;

	//! Unset Width
	plmxml_api::Result UnsetWidth();

	//! Add Transform child element to this MappingGeometry. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	Transform *AddTransform();
     
	//! Set Transform child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetTransform( Transform *arg );
     
	//! Get Transform child element of this MappingGeometry.
	Transform *GetTransform() const;
     
	//! Detach and delete Transform child element tree from this MappingGeometry.
	void DeleteTransform();
 
// <PLMXML_UserCode type="functionHeaderMappingGeometry" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassMappingGeometry;


////////////////////////////////////////////////////////////////////////////////////
//! EntityTexture class
/*!
\verbatim

      Texture structures that can be associated with a remote entity.

      Attributes:

      textureRef:       References the Texture.

      Sub-elements:

      TextureCoord:     The texture coordinates.
      EntityRef:        A reference to the textured entity.
      MappingGeometry:  Any simple intermediate mapping geometry for the
                        texture.
      
\endverbatim
*/
class PLMXML60_API EntityTexture : public AttribOwner
{
public:
     
    //! Default constructor
    EntityTexture( );
     
    //! Constructs a EntityTexture with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    EntityTexture( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~EntityTexture();

private:

	//! Assignment operator
	EntityTexture& operator=( const EntityTexture& iSrc );

	//! Copy constructor
	EntityTexture( const EntityTexture& original );
     
public:

	//! Set reference to Texture using 'arg's plmxml_api::Id.
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical SetTextureRef( plmxml60::IdObject *arg );

	//! Clear reference to Texture
	void RemoveTextureRef( );

	//! Find a plmxml60::IdObject referenced by Texture
	plmxml60::IdObject *ResolveTextureRef( plmxml_api::Configuration* config = NULL );

	//! Get Texture reference
	plmxml_api::String GetTextureId() const;

	//! Set Texture reference.
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical SetTextureId( const plmxml_api::String& u );
	
	//! Check if Texture is set
	plmxml_api::logical HasTextureRef( ) const;

	//! Add TextureCoord child element to this EntityTexture. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	TextureCoord *AddTextureCoord();
     
	//! Add 'arg' as TextureCoord child element to this EntityTexture.
	plmxml_api::Result AddTextureCoord( TextureCoord *arg );

	//! Detach and delete all TextureCoord child elements.
	void DeleteTextureCoords();
     
	//! Get number of TextureCoord child elements.
	int NumberOfTextureCoords() const;
     
	//! Get i'th TextureCoord child element.
	TextureCoord *GetTextureCoord( int i ) const;
     
	//! Get all TextureCoord child element as an array
	void GetTextureCoords( plmxml_api::Array<TextureCoord*> &array ) const;
	     
	//! Detach and delete i'th TextureCoord child element
	void DeleteTextureCoord( int i );
     
	//! Detach and delete 'arg' if it's one of the TextureCoord child elements
	void DeleteTextureCoord( TextureCoord *arg );

	//! Add EntityRef child element to this EntityTexture. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	EntityRef *AddEntityRef();
     
	//! Add 'arg' as EntityRef child element to this EntityTexture.
	plmxml_api::Result AddEntityRef( EntityRef *arg );

	//! Detach and delete all EntityRef child elements.
	void DeleteEntityRefs();
     
	//! Get number of EntityRef child elements.
	int NumberOfEntityRefs() const;
     
	//! Get i'th EntityRef child element.
	EntityRef *GetEntityRef( int i ) const;
     
	//! Get all EntityRef child element as an array
	void GetEntityRefs( plmxml_api::Array<EntityRef*> &array ) const;
	     
	//! Detach and delete i'th EntityRef child element
	void DeleteEntityRef( int i );
     
	//! Detach and delete 'arg' if it's one of the EntityRef child elements
	void DeleteEntityRef( EntityRef *arg );

	//! Add MappingGeometry child element to this EntityTexture. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	MappingGeometry *AddMappingGeometry();
     
	//! Set MappingGeometry child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetMappingGeometry( MappingGeometry *arg );
     
	//! Get MappingGeometry child element of this EntityTexture.
	MappingGeometry *GetMappingGeometry() const;
     
	//! Detach and delete MappingGeometry child element tree from this EntityTexture.
	void DeleteMappingGeometry();
 
// <PLMXML_UserCode type="functionHeaderEntityTexture" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassEntityTexture;


//! Forward class declarations
class PropertyGroup;
class DeterminedPropertyGroup;

////////////////////////////////////////////////////////////////////////////////////
//! CompoundRep class
/*!
\verbatim

      The CompoundRep represents a component of a Representation. The Representation
      then consists of the aggregate or union of the CompoundReps, which may have
      different formats.

      Attributes:

      location:       URI of data source
      load:           True if data is to be loaded at the same time as the PLMXML file.
      format:         Data format. If this is absent, the format is taken from the parent
                      Representation.

      equivalentRef:  an optional reference to a CompoundRep which is equivalent to
                      this one (for example, has the same shape). If this attribute is
                      used, then it should collect together equivalent CompoundReps
                      into a ring, with each CompoundRep using this attribute to point
                      to the next in the ring.

      type:           an optional attribute specifying type or purpose of the CompoundRep.
                      Supported values are:
                      "default" - design geometry.
                      "construction" - construction geometry associated with the
                                       owning representation.
                      "weld" - the geometry of any weld beads.
                      "midsurface" - a special type of construction geometry used with sheet
                                     metal parts.

      baseRef:        an optional reference to a CompoundRep which is overridden by this
                      CompoundRep.

      transformRef:   has the same purpose as the Transform sub-element. Do not use both.

      propertyRefs:   A list of references to Properties.

      Elements:

      PropertyGroup   a collection of Properties of the CompoundRep
      EntityRef:      references to entities in the Representation file. These EntityRef
                      elements can be referenced by RepresentationEntity elements.
      Transform:      optional Transform which positions the geometry in the
                      coordinate frame of the owning Representation.
      DeterminedPropertyGroup: The CompoundRep Properties determined by a
                        specific method.
      
\endverbatim
*/
class PLMXML60_API CompoundRep : public Entity3D
{
public:
     
    //! Default constructor
    CompoundRep( );
     
    //! Constructs a CompoundRep with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    CompoundRep( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~CompoundRep();

private:

	//! Assignment operator
	CompoundRep& operator=( const CompoundRep& iSrc );

	//! Copy constructor
	CompoundRep( const CompoundRep& original );
     
public:

	//! Get Transform URI as plmxml_api::String
	plmxml_api::String GetTransformURI() const;

	//! Set Transform URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetTransformURI( const plmxml_api::String& );
	
	//! Get the handle of Transform URI. Does not resolve the URI.
	plmxml_api::Result GetTransformURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Transform URI. URI string is unchanged.
	plmxml_api::Result SetTransformURI( const plmxml_api::Handle& );
	
	//! Resolve Transform URI and return an object (handle) it points to.
	plmxml_api::Result ResolveTransformURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Transform URI. Clears URI string and handle.
	plmxml_api::Result DeleteTransformURI();
	
	//! Check if Transform URI is set
	plmxml_api::logical HasTransformURI( ) const;
	

	//! Set Format
	plmxml_api::Result SetFormat( const eRepresentationFormatType& arg );

	//! Get Format
	eRepresentationFormatType GetFormat() const;

	//! Set reference to Equivalent using 'arg's plmxml_api::Id.
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical SetEquivalentRef( plmxml60::IdObject *arg );

	//! Clear reference to Equivalent
	void RemoveEquivalentRef( );

	//! Find a plmxml60::IdObject referenced by Equivalent
	plmxml60::IdObject *ResolveEquivalentRef( plmxml_api::Configuration* config = NULL );

	//! Get Equivalent reference
	plmxml_api::String GetEquivalentId() const;

	//! Set Equivalent reference.
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical SetEquivalentId( const plmxml_api::String& u );
	
	//! Check if Equivalent is set
	plmxml_api::logical HasEquivalentRef( ) const;

	//! Set Type
	plmxml_api::Result SetType( const eCompoundRepTypeEnum& arg );

	//! Get Type
	eCompoundRepTypeEnum GetType() const;

	//! Get "location" attribute value
	plmxml_api::String GetExternalRefURI() const;

	//! Get "load" attribute value
	plmxml_api::logical GetExternalRefLoad() const;

	//! Set "load" attribute value
	void SetExternalRefLoad( plmxml_api::logical load );

	//! Set "location" attribute value
	plmxml_api::Result SetExternalRefURI( const plmxml_api::String& u );

	//! Set the 'handle' pointed to by the "location" attribute.
	plmxml_api::Result SetExternalRef( const plmxml_api::Handle& handle );

	//! Set the array of 'handles' pointed to by the "location" attribute.
	plmxml_api::Result SetExternalRef( const plmxml_api::Array<plmxml_api::Handle>& handles );
  
	//! Get the array of 'handles' pointed to by the "location" attribute. Does not resolve.
	plmxml_api::Result GetExternalRef( plmxml_api::Array<plmxml_api::Handle>& handles ) const;
  
	//! Resolve the "location" URI and return objects (handles) it points to.
	plmxml_api::Result ResolveExternalRef( plmxml_api::Array<plmxml_api::Handle>&, plmxml_api::Configuration* config = NULL );
  
	//! Reset the reference. Clears "location" and any handles.
	plmxml_api::Result DeleteExternalRef();
	
	//! Has "locatation" attribute value
	plmxml_api::logical HasExternalRefURI( ) const;

	//! Get number of URIs in Property
	int NumberOfPropertyURIs() const;

	//! Get i'th URI in Property
	plmxml_api::String GetPropertyURI( int i ) const;

	//! Add a URI to Property array. Call ResolvePropertyURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddPropertyURI( const plmxml_api::String& u );

	//! Set i'th URI in Property array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetPropertyURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Property URI. Does not resolve the URI.
	plmxml_api::Result GetPropertyURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Property array.
	plmxml_api::Result AddPropertyURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Property array to point to 'handle'.
	plmxml_api::Result SetPropertyURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Property points to.
	plmxml_api::Result ResolvePropertyURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Property array.
	plmxml_api::Result DeletePropertyURI( int i );

	//! Remove all URIs from Property array.
	plmxml_api::Result DeletePropertyURIs( );
	
	//! Check if Property is set
	plmxml_api::logical HasPropertyURIs( ) const;

	//! Get Base URI as plmxml_api::String
	plmxml_api::String GetBaseURI() const;

	//! Set Base URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetBaseURI( const plmxml_api::String& );
	
	//! Get the handle of Base URI. Does not resolve the URI.
	plmxml_api::Result GetBaseURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Base URI. URI string is unchanged.
	plmxml_api::Result SetBaseURI( const plmxml_api::Handle& );
	
	//! Resolve Base URI and return an object (handle) it points to.
	plmxml_api::Result ResolveBaseURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Base URI. Clears URI string and handle.
	plmxml_api::Result DeleteBaseURI();
	
	//! Check if Base URI is set
	plmxml_api::logical HasBaseURI( ) const;
	

	//! Add PropertyGroup child element to this CompoundRep. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	PropertyGroup *AddPropertyGroup();
     
	//! Set PropertyGroup child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetPropertyGroup( PropertyGroup *arg );
     
	//! Get PropertyGroup child element of this CompoundRep.
	PropertyGroup *GetPropertyGroup() const;
     
	//! Detach and delete PropertyGroup child element tree from this CompoundRep.
	void DeletePropertyGroup();

	//! Add EntityRef child element to this CompoundRep. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	EntityRef *AddEntityRef();
     
	//! Add 'arg' as EntityRef child element to this CompoundRep.
	plmxml_api::Result AddEntityRef( EntityRef *arg );

	//! Detach and delete all EntityRef child elements.
	void DeleteEntityRefs();
     
	//! Get number of EntityRef child elements.
	int NumberOfEntityRefs() const;
     
	//! Get i'th EntityRef child element.
	EntityRef *GetEntityRef( int i ) const;
     
	//! Get all EntityRef child element as an array
	void GetEntityRefs( plmxml_api::Array<EntityRef*> &array ) const;
	     
	//! Detach and delete i'th EntityRef child element
	void DeleteEntityRef( int i );
     
	//! Detach and delete 'arg' if it's one of the EntityRef child elements
	void DeleteEntityRef( EntityRef *arg );

	//! Add Transform child element to this CompoundRep. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	Transform *AddTransform();
     
	//! Set Transform child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetTransform( Transform *arg );
     
	//! Get Transform child element of this CompoundRep.
	Transform *GetTransform() const;
     
	//! Detach and delete Transform child element tree from this CompoundRep.
	void DeleteTransform();

	//! Add DeterminedPropertyGroup child element to this CompoundRep. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	DeterminedPropertyGroup *AddDeterminedPropertyGroup();
     
	//! Set DeterminedPropertyGroup child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetDeterminedPropertyGroup( DeterminedPropertyGroup *arg );
     
	//! Get DeterminedPropertyGroup child element of this CompoundRep.
	DeterminedPropertyGroup *GetDeterminedPropertyGroup() const;
     
	//! Detach and delete DeterminedPropertyGroup child element tree from this CompoundRep.
	void DeleteDeterminedPropertyGroup();
 
// <PLMXML_UserCode type="functionHeaderCompoundRep" >
    //! Return the number of Modeller Handles
	int NumberOfHandles( ) const;

	//! Return the i'th Modeller Handle
	plmxml_api::PLMXML_MODELLER_HANDLE GetHandle( int i ) const;

	//! Append a new handle
	void AddHandle( plmxml_api::PLMXML_MODELLER_HANDLE h );

	//! Set the array of handles
	void SetHandles( int nHandles, plmxml_api::PLMXML_MODELLER_HANDLE *handles );

	//! Return the array of handles and unset this array.
	void DetachHandles( plmxml_api::Array<plmxml_api::Handle>& handles );
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassCompoundRep;


//! Forward class declarations
class PropertyGroup;
class UserValue;
class DeterminedPropertyGroup;

////////////////////////////////////////////////////////////////////////////////////
//! Representation class
/*!
\verbatim

      The Representation element in an PLMXML file refers to a model in some
      particular format, such as XT or jXT. It can refer to the model data in
      another file (an External Representation), or the data can be embedded within
      the Representation element in the XML file (an InternalRepresentation). It
      can also consist of a number of CompoundRep sub-elements.

      Attributes:

      format:         data format
      revision:       revision of data
      transformRef:   has the same purpose as the Transform sub-element. Do not use both.
      location:       URI of data source
      load:           true if data is to be loaded at the same time as the PLMXML file.

      equivalentRef:  an optional reference to a Representation which is equivalent to
                      this one (for example, has the same shape). If this attribute is
                      used, then it should collect together equivalent Representations
                      into a ring, with each Representation using this attribute to point
                      to the next in the ring.

      type:           an optional attribute specifying type or purpose of the Representation.
                      Supported values are:
                      "default" - primary or design geometry.
                      "simplified" - geometry of the simplified model.
                      "flat" - geometry of the unfolded model.
                      "user" - the inherited "name" attribute may be set to the name of an NX
                               ReferenceSet, which implies the purpose of the geometry.

                      Representation type can be used to distinguish between additional
                      and alternative geometry at assembly level in the following way:

                      "default"/"user" - If CompoundReps are all of type "construction", "weld" 
                               or "midsurface", then geometry should be treated additional.
                               Otherwise - alternative.
                      "simplified" - alternative.
                      "flat" - Not expected at assembly level.

      baseRef:        an optional reference to a Representation which is overridden by this
                      Representation.

      propertyRefs:   A list of references to Properties.

      Elements:

      PropertyGroup:  A collection of Properties.
      Transform:      optional Transform which positions the geometry in the
                      coordinate frame of the owner.
      Parameter:      Overrides the Parameters on FeatureTree representations.
      CompoundRep:    the Representation may not have a single location. Instead, it may
                      contain a number of CompoundRep sub-elements, each with its own
                      location. The representation is the aggregate of these data sources.
      InternalRep:    the Representation may contain elements derived from InternalRep,
                      in which case it should not also have a location attribute.

      EntityRef:      references to entities in the Representation file. These EntityRef
                      elements can be referenced by RepresentationEntity elements.
      DeterminedPropertyGroup: The Properties determined by a specific method.

      May also contain elements of type Material, EntityMaterial, TextureData, Texture, or
      EntityTexture.
      
\endverbatim
*/
class PLMXML60_API Representation : public Entity3D
{
public:
     
    //! Default constructor
    Representation( );
     
    //! Constructs a Representation with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Representation( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Representation();

private:

	//! Assignment operator
	Representation& operator=( const Representation& iSrc );

	//! Copy constructor
	Representation( const Representation& original );
     
public:

	//! Set reference to Transform using 'arg's plmxml_api::Id.
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical SetTransformRef( plmxml60::IdObject *arg );

	//! Clear reference to Transform
	void RemoveTransformRef( );

	//! Find a plmxml60::IdObject referenced by Transform
	plmxml60::IdObject *ResolveTransformRef( plmxml_api::Configuration* config = NULL );

	//! Get Transform reference
	plmxml_api::String GetTransformId() const;

	//! Set Transform reference.
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical SetTransformId( const plmxml_api::String& u );
	
	//! Check if Transform is set
	plmxml_api::logical HasTransformRef( ) const;

	//! Set Format
	plmxml_api::Result SetFormat( const eRepresentationFormatType& arg );

	//! Get Format
	eRepresentationFormatType GetFormat() const;

	//! Set reference to Equivalent using 'arg's plmxml_api::Id.
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical SetEquivalentRef( plmxml60::IdObject *arg );

	//! Clear reference to Equivalent
	void RemoveEquivalentRef( );

	//! Find a plmxml60::IdObject referenced by Equivalent
	plmxml60::IdObject *ResolveEquivalentRef( plmxml_api::Configuration* config = NULL );

	//! Get Equivalent reference
	plmxml_api::String GetEquivalentId() const;

	//! Set Equivalent reference.
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical SetEquivalentId( const plmxml_api::String& u );
	
	//! Check if Equivalent is set
	plmxml_api::logical HasEquivalentRef( ) const;

	//! Set Revision
	plmxml_api::Result SetRevision( double arg );

     //! Get Revision
	double GetRevision() const;

	//! Check if Revision is set
	plmxml_api::logical HasRevision() const;

	//! Unset Revision
	plmxml_api::Result UnsetRevision();

	//! Set Type
	plmxml_api::Result SetType( const eRepresentationTypeEnum& arg );

	//! Get Type
	eRepresentationTypeEnum GetType() const;

	//! Get "location" attribute value
	plmxml_api::String GetExternalRefURI() const;

	//! Get "load" attribute value
	plmxml_api::logical GetExternalRefLoad() const;

	//! Set "load" attribute value
	void SetExternalRefLoad( plmxml_api::logical load );

	//! Set "location" attribute value
	plmxml_api::Result SetExternalRefURI( const plmxml_api::String& u );

	//! Set the 'handle' pointed to by the "location" attribute.
	plmxml_api::Result SetExternalRef( const plmxml_api::Handle& handle );

	//! Set the array of 'handles' pointed to by the "location" attribute.
	plmxml_api::Result SetExternalRef( const plmxml_api::Array<plmxml_api::Handle>& handles );
  
	//! Get the array of 'handles' pointed to by the "location" attribute. Does not resolve.
	plmxml_api::Result GetExternalRef( plmxml_api::Array<plmxml_api::Handle>& handles ) const;
  
	//! Resolve the "location" URI and return objects (handles) it points to.
	plmxml_api::Result ResolveExternalRef( plmxml_api::Array<plmxml_api::Handle>&, plmxml_api::Configuration* config = NULL );
  
	//! Reset the reference. Clears "location" and any handles.
	plmxml_api::Result DeleteExternalRef();
	
	//! Has "locatation" attribute value
	plmxml_api::logical HasExternalRefURI( ) const;

	//! Get number of URIs in Property
	int NumberOfPropertyURIs() const;

	//! Get i'th URI in Property
	plmxml_api::String GetPropertyURI( int i ) const;

	//! Add a URI to Property array. Call ResolvePropertyURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddPropertyURI( const plmxml_api::String& u );

	//! Set i'th URI in Property array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetPropertyURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Property URI. Does not resolve the URI.
	plmxml_api::Result GetPropertyURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Property array.
	plmxml_api::Result AddPropertyURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Property array to point to 'handle'.
	plmxml_api::Result SetPropertyURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Property points to.
	plmxml_api::Result ResolvePropertyURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Property array.
	plmxml_api::Result DeletePropertyURI( int i );

	//! Remove all URIs from Property array.
	plmxml_api::Result DeletePropertyURIs( );
	
	//! Check if Property is set
	plmxml_api::logical HasPropertyURIs( ) const;

	//! Get Base URI as plmxml_api::String
	plmxml_api::String GetBaseURI() const;

	//! Set Base URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetBaseURI( const plmxml_api::String& );
	
	//! Get the handle of Base URI. Does not resolve the URI.
	plmxml_api::Result GetBaseURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Base URI. URI string is unchanged.
	plmxml_api::Result SetBaseURI( const plmxml_api::Handle& );
	
	//! Resolve Base URI and return an object (handle) it points to.
	plmxml_api::Result ResolveBaseURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Base URI. Clears URI string and handle.
	plmxml_api::Result DeleteBaseURI();
	
	//! Check if Base URI is set
	plmxml_api::logical HasBaseURI( ) const;
	

	//! Add PropertyGroup child element to this Representation. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	PropertyGroup *AddPropertyGroup();
     
	//! Set PropertyGroup child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetPropertyGroup( PropertyGroup *arg );
     
	//! Get PropertyGroup child element of this Representation.
	PropertyGroup *GetPropertyGroup() const;
     
	//! Detach and delete PropertyGroup child element tree from this Representation.
	void DeletePropertyGroup();

	//! Add Transform child element to this Representation. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	Transform *AddTransform();
     
	//! Set Transform child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetTransform( Transform *arg );
     
	//! Get Transform child element of this Representation.
	Transform *GetTransform() const;
     
	//! Detach and delete Transform child element tree from this Representation.
	void DeleteTransform();

	//! Add Parameter child element to this Representation. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	UserValue *AddParameter();
     
	//! Add 'arg' as Parameter child element to this Representation.
	plmxml_api::Result AddParameter( UserValue *arg );

	//! Detach and delete all Parameter child elements.
	void DeleteParameters();
     
	//! Get number of Parameter child elements.
	int NumberOfParameters() const;
     
	//! Get i'th Parameter child element.
	UserValue *GetParameter( int i ) const;
     
	//! Get all Parameter child element as an array
	void GetParameters( plmxml_api::Array<UserValue*> &array ) const;
	     
	//! Detach and delete i'th Parameter child element
	void DeleteParameter( int i );
     
	//! Detach and delete 'arg' if it's one of the Parameter child elements
	void DeleteParameter( UserValue *arg );

	//! Add InternalRep child element to this Representation. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	InternalRep *AddInternalRep();
     
	//! Add 'arg' as InternalRep child element to this Representation.
	plmxml_api::Result AddInternalRep( InternalRep *arg );

	//! Detach and delete all InternalRep child elements.
	void DeleteInternalReps();
     
	//! Get number of InternalRep child elements.
	int NumberOfInternalReps() const;
     
	//! Get i'th InternalRep child element.
	InternalRep *GetInternalRep( int i ) const;
     
	//! Get all InternalRep child element as an array
	void GetInternalReps( plmxml_api::Array<InternalRep*> &array ) const;
	     
	//! Detach and delete i'th InternalRep child element
	void DeleteInternalRep( int i );
     
	//! Detach and delete 'arg' if it's one of the InternalRep child elements
	void DeleteInternalRep( InternalRep *arg );

	//! Add CompoundRep child element to this Representation. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	CompoundRep *AddCompoundRep();
     
	//! Add 'arg' as CompoundRep child element to this Representation.
	plmxml_api::Result AddCompoundRep( CompoundRep *arg );

	//! Detach and delete all CompoundRep child elements.
	void DeleteCompoundReps();
     
	//! Get number of CompoundRep child elements.
	int NumberOfCompoundReps() const;
     
	//! Get i'th CompoundRep child element.
	CompoundRep *GetCompoundRep( int i ) const;
     
	//! Get all CompoundRep child element as an array
	void GetCompoundReps( plmxml_api::Array<CompoundRep*> &array ) const;
	     
	//! Detach and delete i'th CompoundRep child element
	void DeleteCompoundRep( int i );
     
	//! Detach and delete 'arg' if it's one of the CompoundRep child elements
	void DeleteCompoundRep( CompoundRep *arg );

	//! Add Material child element to this Representation. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Material *AddMaterial();
     
	//! Add 'arg' as Material child element to this Representation.
	plmxml_api::Result AddMaterial( Material *arg );

	//! Detach and delete all Material child elements.
	void DeleteMaterials();
     
	//! Get number of Material child elements.
	int NumberOfMaterials() const;
     
	//! Get i'th Material child element.
	Material *GetMaterial( int i ) const;
     
	//! Get all Material child element as an array
	void GetMaterials( plmxml_api::Array<Material*> &array ) const;
	     
	//! Detach and delete i'th Material child element
	void DeleteMaterial( int i );
     
	//! Detach and delete 'arg' if it's one of the Material child elements
	void DeleteMaterial( Material *arg );

	//! Add EntityMaterial child element to this Representation. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	EntityMaterial *AddEntityMaterial();
     
	//! Add 'arg' as EntityMaterial child element to this Representation.
	plmxml_api::Result AddEntityMaterial( EntityMaterial *arg );

	//! Detach and delete all EntityMaterial child elements.
	void DeleteEntityMaterials();
     
	//! Get number of EntityMaterial child elements.
	int NumberOfEntityMaterials() const;
     
	//! Get i'th EntityMaterial child element.
	EntityMaterial *GetEntityMaterial( int i ) const;
     
	//! Get all EntityMaterial child element as an array
	void GetEntityMaterials( plmxml_api::Array<EntityMaterial*> &array ) const;
	     
	//! Detach and delete i'th EntityMaterial child element
	void DeleteEntityMaterial( int i );
     
	//! Detach and delete 'arg' if it's one of the EntityMaterial child elements
	void DeleteEntityMaterial( EntityMaterial *arg );

	//! Add TextureData child element to this Representation. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	TextureData *AddTextureData();
     
	//! Add 'arg' as TextureData child element to this Representation.
	plmxml_api::Result AddTextureData( TextureData *arg );

	//! Detach and delete all TextureData child elements.
	void DeleteTextureDatas();
     
	//! Get number of TextureData child elements.
	int NumberOfTextureDatas() const;
     
	//! Get i'th TextureData child element.
	TextureData *GetTextureData( int i ) const;
     
	//! Get all TextureData child element as an array
	void GetTextureDatas( plmxml_api::Array<TextureData*> &array ) const;
	     
	//! Detach and delete i'th TextureData child element
	void DeleteTextureData( int i );
     
	//! Detach and delete 'arg' if it's one of the TextureData child elements
	void DeleteTextureData( TextureData *arg );

	//! Add Texture child element to this Representation. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Texture *AddTexture();
     
	//! Add 'arg' as Texture child element to this Representation.
	plmxml_api::Result AddTexture( Texture *arg );

	//! Detach and delete all Texture child elements.
	void DeleteTextures();
     
	//! Get number of Texture child elements.
	int NumberOfTextures() const;
     
	//! Get i'th Texture child element.
	Texture *GetTexture( int i ) const;
     
	//! Get all Texture child element as an array
	void GetTextures( plmxml_api::Array<Texture*> &array ) const;
	     
	//! Detach and delete i'th Texture child element
	void DeleteTexture( int i );
     
	//! Detach and delete 'arg' if it's one of the Texture child elements
	void DeleteTexture( Texture *arg );

	//! Add EntityTexture child element to this Representation. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	EntityTexture *AddEntityTexture();
     
	//! Add 'arg' as EntityTexture child element to this Representation.
	plmxml_api::Result AddEntityTexture( EntityTexture *arg );

	//! Detach and delete all EntityTexture child elements.
	void DeleteEntityTextures();
     
	//! Get number of EntityTexture child elements.
	int NumberOfEntityTextures() const;
     
	//! Get i'th EntityTexture child element.
	EntityTexture *GetEntityTexture( int i ) const;
     
	//! Get all EntityTexture child element as an array
	void GetEntityTextures( plmxml_api::Array<EntityTexture*> &array ) const;
	     
	//! Detach and delete i'th EntityTexture child element
	void DeleteEntityTexture( int i );
     
	//! Detach and delete 'arg' if it's one of the EntityTexture child elements
	void DeleteEntityTexture( EntityTexture *arg );

	//! Add EntityRef child element to this Representation. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	EntityRef *AddEntityRef();
     
	//! Add 'arg' as EntityRef child element to this Representation.
	plmxml_api::Result AddEntityRef( EntityRef *arg );

	//! Detach and delete all EntityRef child elements.
	void DeleteEntityRefs();
     
	//! Get number of EntityRef child elements.
	int NumberOfEntityRefs() const;
     
	//! Get i'th EntityRef child element.
	EntityRef *GetEntityRef( int i ) const;
     
	//! Get all EntityRef child element as an array
	void GetEntityRefs( plmxml_api::Array<EntityRef*> &array ) const;
	     
	//! Detach and delete i'th EntityRef child element
	void DeleteEntityRef( int i );
     
	//! Detach and delete 'arg' if it's one of the EntityRef child elements
	void DeleteEntityRef( EntityRef *arg );

	//! Add DeterminedPropertyGroup child element to this Representation. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	DeterminedPropertyGroup *AddDeterminedPropertyGroup();
     
	//! Set DeterminedPropertyGroup child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetDeterminedPropertyGroup( DeterminedPropertyGroup *arg );
     
	//! Get DeterminedPropertyGroup child element of this Representation.
	DeterminedPropertyGroup *GetDeterminedPropertyGroup() const;
     
	//! Detach and delete DeterminedPropertyGroup child element tree from this Representation.
	void DeleteDeterminedPropertyGroup();
 
// <PLMXML_UserCode type="functionHeaderRepresentation" >
    //! Return the number of Modeller Handles
	int NumberOfHandles( ) const;

	//! Return the i'th Modeller Handle
	plmxml_api::PLMXML_MODELLER_HANDLE GetHandle( int i ) const;

	//! Append a new handle
	void AddHandle( plmxml_api::PLMXML_MODELLER_HANDLE h );

	//! Set the array of handles
	void SetHandles( int nHandles, plmxml_api::PLMXML_MODELLER_HANDLE *handles );

	//! Return the array of handles and unset this array.
	void DetachHandles( plmxml_api::Array<plmxml_api::Handle>& handles );

	//! Set InternalRep child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetInternalRep( InternalRep *arg );

	//! Get InternalRep child element of this Representation.
	InternalRep *GetInternalRep( ) const;

	//! Detach and delete InternalRep child element tree from this Representation.
	void DeleteInternalRep( );
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassRepresentation;


////////////////////////////////////////////////////////////////////////////////////
//! OccurrenceFilter class
/*!
\verbatim

      Abstract base class for filters.

      Attributes:

      contextRef:     The owning StructureRevisionView, if appropriate
      outputRef:      The result of applying the Filter - a ConfiguredOccurrenceGroup
      subType:        The sub-type of the OccurrenceFilter.
      
\endverbatim
*/
class PLMXML60_API OccurrenceFilter : public AttribOwner
{
public:
     
    //! Default constructor
    OccurrenceFilter( );
     
    //! Constructs a OccurrenceFilter with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    OccurrenceFilter( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~OccurrenceFilter();

private:

	//! Assignment operator
	OccurrenceFilter& operator=( const OccurrenceFilter& iSrc );

	//! Copy constructor
	OccurrenceFilter( const OccurrenceFilter& original );
     
public:

	//! Get SubType of this OccurrenceFilter
	plmxml_api::String GetSubType() const;

	//! Set SubType of this OccurrenceFilter
	plmxml_api::Result SetSubType( const plmxml_api::String &s );
	
	//! Check if SubType is set
	plmxml_api::logical HasSubType( ) const;
	
	//! Unset SubType
	plmxml_api::Result UnsetSubType( );

	//! Get Output URI as plmxml_api::String
	plmxml_api::String GetOutputURI() const;

	//! Set Output URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetOutputURI( const plmxml_api::String& );
	
	//! Get the handle of Output URI. Does not resolve the URI.
	plmxml_api::Result GetOutputURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Output URI. URI string is unchanged.
	plmxml_api::Result SetOutputURI( const plmxml_api::Handle& );
	
	//! Resolve Output URI and return an object (handle) it points to.
	plmxml_api::Result ResolveOutputURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Output URI. Clears URI string and handle.
	plmxml_api::Result DeleteOutputURI();
	
	//! Check if Output URI is set
	plmxml_api::logical HasOutputURI( ) const;
	

	//! Get Context URI as plmxml_api::String
	plmxml_api::String GetContextURI() const;

	//! Set Context URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetContextURI( const plmxml_api::String& );
	
	//! Get the handle of Context URI. Does not resolve the URI.
	plmxml_api::Result GetContextURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Context URI. URI string is unchanged.
	plmxml_api::Result SetContextURI( const plmxml_api::Handle& );
	
	//! Resolve Context URI and return an object (handle) it points to.
	plmxml_api::Result ResolveContextURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Context URI. Clears URI string and handle.
	plmxml_api::Result DeleteContextURI();
	
	//! Check if Context URI is set
	plmxml_api::logical HasContextURI( ) const;
	
 
// <PLMXML_UserCode type="functionHeaderOccurrenceFilter" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassOccurrenceFilter;


//! Forward class declarations
class AssociatedAttachment;

////////////////////////////////////////////////////////////////////////////////////
//! ConfiguredOccurrenceGroup class
/*!
\verbatim

      This is the configured form of the OccurrenceGroup element. 
      
      It is a group of Occurrences and other ConfiguredOccurrenceGroups. All the
      Occurrences included (recursively) in a ConfiguredOccurrenceGroup must have the
      same Structure and View as the parent of their top Instance.
    
      ConfiguredOccurrenceGroups can share Occurrences or other 
      ConfiguredOccurrenceGroups, but must not contain recursive loops.
    
      Attributes:
                      
      childRefs:      reference to contained Occurrences or ConfiguredOccurrenceGroups
      sourceRef:      A reference to the OccurrenceGroup to which this corresponds. 
      associatedAttachmentRefs: references to root AssociatedAttachments.
      
      Sub-elements:
      
      AssociatedAttachment
      
\endverbatim
*/
class PLMXML60_API ConfiguredOccurrenceGroup : public Managed
{
public:
     
    //! Default constructor
    ConfiguredOccurrenceGroup( );
     
    //! Constructs a ConfiguredOccurrenceGroup with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ConfiguredOccurrenceGroup( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ConfiguredOccurrenceGroup();

private:

	//! Assignment operator
	ConfiguredOccurrenceGroup& operator=( const ConfiguredOccurrenceGroup& iSrc );

	//! Copy constructor
	ConfiguredOccurrenceGroup( const ConfiguredOccurrenceGroup& original );
     
public:

	//! Get number of URIs in AssociatedAttachment
	int NumberOfAssociatedAttachmentURIs() const;

	//! Get i'th URI in AssociatedAttachment
	plmxml_api::String GetAssociatedAttachmentURI( int i ) const;

	//! Add a URI to AssociatedAttachment array. Call ResolveAssociatedAttachmentURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddAssociatedAttachmentURI( const plmxml_api::String& u );

	//! Set i'th URI in AssociatedAttachment array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetAssociatedAttachmentURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of AssociatedAttachment URI. Does not resolve the URI.
	plmxml_api::Result GetAssociatedAttachmentURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to AssociatedAttachment array.
	plmxml_api::Result AddAssociatedAttachmentURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in AssociatedAttachment array to point to 'handle'.
	plmxml_api::Result SetAssociatedAttachmentURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in AssociatedAttachment points to.
	plmxml_api::Result ResolveAssociatedAttachmentURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from AssociatedAttachment array.
	plmxml_api::Result DeleteAssociatedAttachmentURI( int i );

	//! Remove all URIs from AssociatedAttachment array.
	plmxml_api::Result DeleteAssociatedAttachmentURIs( );
	
	//! Check if AssociatedAttachment is set
	plmxml_api::logical HasAssociatedAttachmentURIs( ) const;

	//! Get Source URI as plmxml_api::String
	plmxml_api::String GetSourceURI() const;

	//! Set Source URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetSourceURI( const plmxml_api::String& );
	
	//! Get the handle of Source URI. Does not resolve the URI.
	plmxml_api::Result GetSourceURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Source URI. URI string is unchanged.
	plmxml_api::Result SetSourceURI( const plmxml_api::Handle& );
	
	//! Resolve Source URI and return an object (handle) it points to.
	plmxml_api::Result ResolveSourceURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Source URI. Clears URI string and handle.
	plmxml_api::Result DeleteSourceURI();
	
	//! Check if Source URI is set
	plmxml_api::logical HasSourceURI( ) const;
	

	//! Get number of URIs in Child
	int NumberOfChildURIs() const;

	//! Get i'th URI in Child
	plmxml_api::String GetChildURI( int i ) const;

	//! Add a URI to Child array. Call ResolveChildURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddChildURI( const plmxml_api::String& u );

	//! Set i'th URI in Child array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetChildURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Child URI. Does not resolve the URI.
	plmxml_api::Result GetChildURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Child array.
	plmxml_api::Result AddChildURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Child array to point to 'handle'.
	plmxml_api::Result SetChildURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Child points to.
	plmxml_api::Result ResolveChildURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Child array.
	plmxml_api::Result DeleteChildURI( int i );

	//! Remove all URIs from Child array.
	plmxml_api::Result DeleteChildURIs( );
	
	//! Check if Child is set
	plmxml_api::logical HasChildURIs( ) const;

	//! Add AssociatedAttachment child element to this ConfiguredOccurrenceGroup. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	AssociatedAttachment *AddAssociatedAttachment();
     
	//! Add 'arg' as AssociatedAttachment child element to this ConfiguredOccurrenceGroup.
	plmxml_api::Result AddAssociatedAttachment( AssociatedAttachment *arg );

	//! Detach and delete all AssociatedAttachment child elements.
	void DeleteAssociatedAttachments();
     
	//! Get number of AssociatedAttachment child elements.
	int NumberOfAssociatedAttachments() const;
     
	//! Get i'th AssociatedAttachment child element.
	AssociatedAttachment *GetAssociatedAttachment( int i ) const;
     
	//! Get all AssociatedAttachment child element as an array
	void GetAssociatedAttachments( plmxml_api::Array<AssociatedAttachment*> &array ) const;
	     
	//! Detach and delete i'th AssociatedAttachment child element
	void DeleteAssociatedAttachment( int i );
     
	//! Detach and delete 'arg' if it's one of the AssociatedAttachment child elements
	void DeleteAssociatedAttachment( AssociatedAttachment *arg );
 
// <PLMXML_UserCode type="functionHeaderConfiguredOccurrenceGroup" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassConfiguredOccurrenceGroup;


////////////////////////////////////////////////////////////////////////////////////
//! ConfigRule class
/*!
\verbatim

      Abstract base class for Configuration Rule elements
      
\endverbatim
*/
class PLMXML60_API ConfigRule : public Managed
{
public:
     
    //! Default constructor
    ConfigRule( );
     
    //! Constructs a ConfigRule with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ConfigRule( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ConfigRule();

private:

	//! Assignment operator
	ConfigRule& operator=( const ConfigRule& iSrc );

	//! Copy constructor
	ConfigRule( const ConfigRule& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderConfigRule" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassConfigRule;


//! Forward class declarations
class AssociatedAttachment;

////////////////////////////////////////////////////////////////////////////////////
//! ConfigurationView class
/*!
\verbatim

      This represents a configured structure. 
 
      Attributes:
    
      ruleRefs:       references to configuration rules (derived from ConfigRuleBase) 
      attachmentRefs: references to root attachments.
      
      Elements:

      AssociatedAttachment: These elements specify the elements attached to the
                      ConfigurationView. 
      
\endverbatim
*/
class PLMXML60_API ConfigurationView : public AttribOwner
{
public:
     
    //! Default constructor
    ConfigurationView( );
     
    //! Constructs a ConfigurationView with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ConfigurationView( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ConfigurationView();

private:

	//! Assignment operator
	ConfigurationView& operator=( const ConfigurationView& iSrc );

	//! Copy constructor
	ConfigurationView( const ConfigurationView& original );
     
public:

	//! Get number of URIs in Rule
	int NumberOfRuleURIs() const;

	//! Get i'th URI in Rule
	plmxml_api::String GetRuleURI( int i ) const;

	//! Add a URI to Rule array. Call ResolveRuleURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddRuleURI( const plmxml_api::String& u );

	//! Set i'th URI in Rule array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetRuleURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Rule URI. Does not resolve the URI.
	plmxml_api::Result GetRuleURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Rule array.
	plmxml_api::Result AddRuleURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Rule array to point to 'handle'.
	plmxml_api::Result SetRuleURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Rule points to.
	plmxml_api::Result ResolveRuleURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Rule array.
	plmxml_api::Result DeleteRuleURI( int i );

	//! Remove all URIs from Rule array.
	plmxml_api::Result DeleteRuleURIs( );
	
	//! Check if Rule is set
	plmxml_api::logical HasRuleURIs( ) const;

	//! Get number of URIs in Attachment
	int NumberOfAttachmentURIs() const;

	//! Get i'th URI in Attachment
	plmxml_api::String GetAttachmentURI( int i ) const;

	//! Add a URI to Attachment array. Call ResolveAttachmentURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddAttachmentURI( const plmxml_api::String& u );

	//! Set i'th URI in Attachment array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetAttachmentURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Attachment URI. Does not resolve the URI.
	plmxml_api::Result GetAttachmentURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Attachment array.
	plmxml_api::Result AddAttachmentURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Attachment array to point to 'handle'.
	plmxml_api::Result SetAttachmentURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Attachment points to.
	plmxml_api::Result ResolveAttachmentURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Attachment array.
	plmxml_api::Result DeleteAttachmentURI( int i );

	//! Remove all URIs from Attachment array.
	plmxml_api::Result DeleteAttachmentURIs( );
	
	//! Check if Attachment is set
	plmxml_api::logical HasAttachmentURIs( ) const;

	//! Add AssociatedAttachment child element to this ConfigurationView. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	AssociatedAttachment *AddAssociatedAttachment();
     
	//! Add 'arg' as AssociatedAttachment child element to this ConfigurationView.
	plmxml_api::Result AddAssociatedAttachment( AssociatedAttachment *arg );

	//! Detach and delete all AssociatedAttachment child elements.
	void DeleteAssociatedAttachments();
     
	//! Get number of AssociatedAttachment child elements.
	int NumberOfAssociatedAttachments() const;
     
	//! Get i'th AssociatedAttachment child element.
	AssociatedAttachment *GetAssociatedAttachment( int i ) const;
     
	//! Get all AssociatedAttachment child element as an array
	void GetAssociatedAttachments( plmxml_api::Array<AssociatedAttachment*> &array ) const;
	     
	//! Detach and delete i'th AssociatedAttachment child element
	void DeleteAssociatedAttachment( int i );
     
	//! Detach and delete 'arg' if it's one of the AssociatedAttachment child elements
	void DeleteAssociatedAttachment( AssociatedAttachment *arg );
 
// <PLMXML_UserCode type="functionHeaderConfigurationView" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassConfigurationView;


//! Forward class declarations
class Occurrence;
class SymbolicOccurrence;

////////////////////////////////////////////////////////////////////////////////////
//! ProductView class
/*!
\verbatim

      ProductView. This is a collection of Occurrences and ConfiguredOccurrenceGroups
      with the same top Structure and View.

      Attributes:

      viewControlRef:    optional reference to a ViewControl
      displayControlRef: optional reference to a DisplayControl

      alternativeOfRef:  A ProductView may be defined by reference to another
                      ProductView, in which case it may include Occurrences which
                      override certain corresponding Occurrences in the other
                      ProductView. This attribute is used to specify other ProductView,
                      which must have the same 'top Structure' as this one.

      definition:     how the ProductView is defined.

                      "select" means the ProductView is a selection of Occurrences from
                      the InstanceGraph.

                      "overlay" mean the ProductView modifies the view implied by the
                      InstanceGraph by changing some of the Occurrences. (Occurrences can
                      also be masked by including an "invisible" Occurrence in the
                      ProductView)

      usage:          This optional attribute specifies the intent of the ProductView.
                      Possible values are:

                      "visual". This means that the Occurrences in the ProductView are
                      simply for display, as in an exploded view. They do not necessarily
                      represent a physically realisable state.

                      "arrangement". The Occurrences represent a realisable state or
                      position of (part of) the assembly.

                      "variant". The Occurrences represent a configuration of the Product
                      Structure, i.e. with certain Options chosen.

                      "modelView". The ProductView represents a Model View, i.e.
                      annotated view of (partial) geometry of the model.

      rootRefs:       specifies the root Occurrences, i.e. those which are not children
                      of other Occurrences in this ProductView.

      primaryOccurrenceRef: (deprecated). Used when there is only one root Occurrence.

      sectionRef:     specifies the Section (i.e. cutter geometry) associated with this view.

      default:        "true" if this is a default ProductView.

      state:          state of the ProductView.

      viewOrientation: When the ProductView represents a Model View and the
                      Model View is a member of a View Set, viewOrientation is
                      the type of transform as a ViewOrientationEnum.
      disclosurePurpose: When the ProductView represents a Model View in a
                      Disclosure, disclosurePurpose holds the purpose or intent.
      dateModified:   When the ProductView represents a Model View in a
                      Disclosure, dateModified holds the last modified date.
      thumbnailRef:   References a thumbnail image of the ProductView when it
                      represents a Model View in a Disclosure.
      imageRef:       References a high definition image of the ProductView when
                      it represents a Model View in a Disclosure.
      exploded:       Whether the ProductView is exploded.
      stringRep:      When the ProductView represents a Model View, stringRep is
                      a string representation, often used for validation.

      Elements:

      Occurrence:           the Occurrences in the ProductView.
      ConfiguredOccurrenceGroup: ConfiguredOccurrenceGroups in the ProductView
      Transform:            Transforms which may be referenced by the Occurrences.
      SymbolicOccurrence:   SymbolicOccurrences in the ProductView
      
\endverbatim
*/
class PLMXML60_API ProductView : public ConfigurationView
{
public:
     
    //! Default constructor
    ProductView( );
     
    //! Constructs a ProductView with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ProductView( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ProductView();

private:

	//! Assignment operator
	ProductView& operator=( const ProductView& iSrc );

	//! Copy constructor
	ProductView( const ProductView& original );
     
public:

	//! Get AlternativeOf URI as plmxml_api::String
	plmxml_api::String GetAlternativeOfURI() const;

	//! Set AlternativeOf URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetAlternativeOfURI( const plmxml_api::String& );
	
	//! Get the handle of AlternativeOf URI. Does not resolve the URI.
	plmxml_api::Result GetAlternativeOfURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of AlternativeOf URI. URI string is unchanged.
	plmxml_api::Result SetAlternativeOfURI( const plmxml_api::Handle& );
	
	//! Resolve AlternativeOf URI and return an object (handle) it points to.
	plmxml_api::Result ResolveAlternativeOfURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset AlternativeOf URI. Clears URI string and handle.
	plmxml_api::Result DeleteAlternativeOfURI();
	
	//! Check if AlternativeOf URI is set
	plmxml_api::logical HasAlternativeOfURI( ) const;
	

	//! Set ViewOrientation
	plmxml_api::Result SetViewOrientation( const eViewOrientationEnum& arg );

	//! Get ViewOrientation
	eViewOrientationEnum GetViewOrientation() const;

	//! Set Usage
	plmxml_api::Result SetUsage( const eProductViewUsageType& arg );

	//! Get Usage
	eProductViewUsageType GetUsage() const;

	//! Get StringRep of this ProductView
	plmxml_api::String GetStringRep() const;

	//! Set StringRep of this ProductView
	plmxml_api::Result SetStringRep( const plmxml_api::String &s );
	
	//! Check if StringRep is set
	plmxml_api::logical HasStringRep( ) const;
	
	//! Unset StringRep
	plmxml_api::Result UnsetStringRep( );

	//! Set Default
	plmxml_api::Result SetDefault( plmxml_api::logical arg );

	//! Get Default
	plmxml_api::logical GetDefault() const;

	//! Check if Default is set
	plmxml_api::logical HasDefault() const;

	//! Unset Default
	plmxml_api::Result UnsetDefault();

	//! Set State
	plmxml_api::Result SetState( const eProductViewStateEnum& arg );

	//! Get State
	eProductViewStateEnum GetState() const;

	//! Set reference to ViewControl using 'arg's plmxml_api::Id.
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical SetViewControlRef( plmxml60::IdObject *arg );

	//! Clear reference to ViewControl
	void RemoveViewControlRef( );

	//! Find a plmxml60::IdObject referenced by ViewControl
	plmxml60::IdObject *ResolveViewControlRef( plmxml_api::Configuration* config = NULL );

	//! Get ViewControl reference
	plmxml_api::String GetViewControlId() const;

	//! Set ViewControl reference.
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical SetViewControlId( const plmxml_api::String& u );
	
	//! Check if ViewControl is set
	plmxml_api::logical HasViewControlRef( ) const;

	//! Set reference to DisplayControl using 'arg's plmxml_api::Id.
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical SetDisplayControlRef( plmxml60::IdObject *arg );

	//! Clear reference to DisplayControl
	void RemoveDisplayControlRef( );

	//! Find a plmxml60::IdObject referenced by DisplayControl
	plmxml60::IdObject *ResolveDisplayControlRef( plmxml_api::Configuration* config = NULL );

	//! Get DisplayControl reference
	plmxml_api::String GetDisplayControlId() const;

	//! Set DisplayControl reference.
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical SetDisplayControlId( const plmxml_api::String& u );
	
	//! Check if DisplayControl is set
	plmxml_api::logical HasDisplayControlRef( ) const;

	//! Set reference to PrimaryOccurrence using 'arg's plmxml_api::Id.
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical SetPrimaryOccurrenceRef( plmxml60::IdObject *arg );

	//! Clear reference to PrimaryOccurrence
	void RemovePrimaryOccurrenceRef( );

	//! Find a plmxml60::IdObject referenced by PrimaryOccurrence
	plmxml60::IdObject *ResolvePrimaryOccurrenceRef( plmxml_api::Configuration* config = NULL );

	//! Get PrimaryOccurrence reference
	plmxml_api::String GetPrimaryOccurrenceId() const;

	//! Set PrimaryOccurrence reference.
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical SetPrimaryOccurrenceId( const plmxml_api::String& u );
	
	//! Check if PrimaryOccurrence is set
	plmxml_api::logical HasPrimaryOccurrenceRef( ) const;

	//! Set Exploded
	plmxml_api::Result SetExploded( plmxml_api::logical arg );

	//! Get Exploded
	plmxml_api::logical GetExploded() const;

	//! Check if Exploded is set
	plmxml_api::logical HasExploded() const;

	//! Unset Exploded
	plmxml_api::Result UnsetExploded();

	//! Get DateModified of this ProductView
	plmxml_api::String GetDateModified() const;

	//! Set DateModified of this ProductView
	plmxml_api::Result SetDateModified( const plmxml_api::String &s );
	
	//! Check if DateModified is set
	plmxml_api::logical HasDateModified( ) const;
	
	//! Unset DateModified
	plmxml_api::Result UnsetDateModified( );

	//! Get Section URI as plmxml_api::String
	plmxml_api::String GetSectionURI() const;

	//! Set Section URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetSectionURI( const plmxml_api::String& );
	
	//! Get the handle of Section URI. Does not resolve the URI.
	plmxml_api::Result GetSectionURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Section URI. URI string is unchanged.
	plmxml_api::Result SetSectionURI( const plmxml_api::Handle& );
	
	//! Resolve Section URI and return an object (handle) it points to.
	plmxml_api::Result ResolveSectionURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Section URI. Clears URI string and handle.
	plmxml_api::Result DeleteSectionURI();
	
	//! Check if Section URI is set
	plmxml_api::logical HasSectionURI( ) const;
	

	//! Get DisclosurePurpose of this ProductView
	plmxml_api::String GetDisclosurePurpose() const;

	//! Set DisclosurePurpose of this ProductView
	plmxml_api::Result SetDisclosurePurpose( const plmxml_api::String &s );
	
	//! Check if DisclosurePurpose is set
	plmxml_api::logical HasDisclosurePurpose( ) const;
	
	//! Unset DisclosurePurpose
	plmxml_api::Result UnsetDisclosurePurpose( );

	//! Set Definition
	plmxml_api::Result SetDefinition( const eProductViewDefinitionType& arg );

	//! Get Definition
	eProductViewDefinitionType GetDefinition() const;

	//! Get Thumbnail URI as plmxml_api::String
	plmxml_api::String GetThumbnailURI() const;

	//! Set Thumbnail URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetThumbnailURI( const plmxml_api::String& );
	
	//! Get the handle of Thumbnail URI. Does not resolve the URI.
	plmxml_api::Result GetThumbnailURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Thumbnail URI. URI string is unchanged.
	plmxml_api::Result SetThumbnailURI( const plmxml_api::Handle& );
	
	//! Resolve Thumbnail URI and return an object (handle) it points to.
	plmxml_api::Result ResolveThumbnailURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Thumbnail URI. Clears URI string and handle.
	plmxml_api::Result DeleteThumbnailURI();
	
	//! Check if Thumbnail URI is set
	plmxml_api::logical HasThumbnailURI( ) const;
	

	//! Get Image URI as plmxml_api::String
	plmxml_api::String GetImageURI() const;

	//! Set Image URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetImageURI( const plmxml_api::String& );
	
	//! Get the handle of Image URI. Does not resolve the URI.
	plmxml_api::Result GetImageURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Image URI. URI string is unchanged.
	plmxml_api::Result SetImageURI( const plmxml_api::Handle& );
	
	//! Resolve Image URI and return an object (handle) it points to.
	plmxml_api::Result ResolveImageURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Image URI. Clears URI string and handle.
	plmxml_api::Result DeleteImageURI();
	
	//! Check if Image URI is set
	plmxml_api::logical HasImageURI( ) const;
	

	//! Get number of references in Root array
	int NumberOfRootRefs() const;
     
	//! Add reference to 'arg' to Root array
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical AddRootRef( plmxml60::IdObject *arg );
     
	//! Add reference to an object pointed to by 'u' to Root array
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical AddRootId( const plmxml_api::String &u );
     
	//! Set i'th reference in Root array to 'arg'
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical SetRootRef( int i, plmxml60::IdObject *arg );
     
	//! Set i'th reference in Root array to an object pointed to by 'u'
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical SetRootId( int i, const plmxml_api::String &u );
     
	//! Resolve i'th reference in Root array and return an object it points to.
	plmxml60::IdObject *ResolveRootRef( int i, plmxml_api::Configuration* config = NULL );
     
	//! Resolve all references in Root array and return objects they point to.
	void ResolveRootRefs( plmxml_api::Array<plmxml60::IdObject *> & array, plmxml_api::Configuration* config = NULL );
     
	//! Get i'th reference in Root array as plmxml_api::String
	plmxml_api::String GetRootId( int i ) const;
     
	//! Get all references in Root array as an array of plmxml_api::String
	void GetRootIds( plmxml_api::Array<plmxml_api::String> &array ) const;
     
	//! Remove i'th reference from the Root array.
	void RemoveRootRef( int i );
     
	//! Remove reference to an object pointed to by 'u' from the Root array.
	void RemoveRootRef( const plmxml_api::String &u );
     
	//! Remove reference to 'arg' from the Root array.
	void RemoveRootRef( plmxml60::IdObject *arg );
     
	//! Remove all references Root array.
	void RemoveRootRefs();
	
	//! Check if Root is set
	plmxml_api::logical HasRootRefs( ) const;

	//! Add Occurrence child element to this ProductView. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Occurrence *AddOccurrence();
     
	//! Add 'arg' as Occurrence child element to this ProductView.
	plmxml_api::Result AddOccurrence( Occurrence *arg );

	//! Detach and delete all Occurrence child elements.
	void DeleteOccurrences();
     
	//! Get number of Occurrence child elements.
	int NumberOfOccurrences() const;
     
	//! Get i'th Occurrence child element.
	Occurrence *GetOccurrence( int i ) const;
     
	//! Get all Occurrence child element as an array
	void GetOccurrences( plmxml_api::Array<Occurrence*> &array ) const;
	     
	//! Detach and delete i'th Occurrence child element
	void DeleteOccurrence( int i );
     
	//! Detach and delete 'arg' if it's one of the Occurrence child elements
	void DeleteOccurrence( Occurrence *arg );

	//! Add ConfiguredOccurrenceGroup child element to this ProductView. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	ConfiguredOccurrenceGroup *AddConfiguredOccurrenceGroup();
     
	//! Add 'arg' as ConfiguredOccurrenceGroup child element to this ProductView.
	plmxml_api::Result AddConfiguredOccurrenceGroup( ConfiguredOccurrenceGroup *arg );

	//! Detach and delete all ConfiguredOccurrenceGroup child elements.
	void DeleteConfiguredOccurrenceGroups();
     
	//! Get number of ConfiguredOccurrenceGroup child elements.
	int NumberOfConfiguredOccurrenceGroups() const;
     
	//! Get i'th ConfiguredOccurrenceGroup child element.
	ConfiguredOccurrenceGroup *GetConfiguredOccurrenceGroup( int i ) const;
     
	//! Get all ConfiguredOccurrenceGroup child element as an array
	void GetConfiguredOccurrenceGroups( plmxml_api::Array<ConfiguredOccurrenceGroup*> &array ) const;
	     
	//! Detach and delete i'th ConfiguredOccurrenceGroup child element
	void DeleteConfiguredOccurrenceGroup( int i );
     
	//! Detach and delete 'arg' if it's one of the ConfiguredOccurrenceGroup child elements
	void DeleteConfiguredOccurrenceGroup( ConfiguredOccurrenceGroup *arg );

	//! Add Transform child element to this ProductView. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Transform *AddTransform();
     
	//! Add 'arg' as Transform child element to this ProductView.
	plmxml_api::Result AddTransform( Transform *arg );

	//! Detach and delete all Transform child elements.
	void DeleteTransforms();
     
	//! Get number of Transform child elements.
	int NumberOfTransforms() const;
     
	//! Get i'th Transform child element.
	Transform *GetTransform( int i ) const;
     
	//! Get all Transform child element as an array
	void GetTransforms( plmxml_api::Array<Transform*> &array ) const;
	     
	//! Detach and delete i'th Transform child element
	void DeleteTransform( int i );
     
	//! Detach and delete 'arg' if it's one of the Transform child elements
	void DeleteTransform( Transform *arg );

	//! Add SymbolicOccurrence child element to this ProductView. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	SymbolicOccurrence *AddSymbolicOccurrence();
     
	//! Add 'arg' as SymbolicOccurrence child element to this ProductView.
	plmxml_api::Result AddSymbolicOccurrence( SymbolicOccurrence *arg );

	//! Detach and delete all SymbolicOccurrence child elements.
	void DeleteSymbolicOccurrences();
     
	//! Get number of SymbolicOccurrence child elements.
	int NumberOfSymbolicOccurrences() const;
     
	//! Get i'th SymbolicOccurrence child element.
	SymbolicOccurrence *GetSymbolicOccurrence( int i ) const;
     
	//! Get all SymbolicOccurrence child element as an array
	void GetSymbolicOccurrences( plmxml_api::Array<SymbolicOccurrence*> &array ) const;
	     
	//! Detach and delete i'th SymbolicOccurrence child element
	void DeleteSymbolicOccurrence( int i );
     
	//! Detach and delete 'arg' if it's one of the SymbolicOccurrence child elements
	void DeleteSymbolicOccurrence( SymbolicOccurrence *arg );
 
// <PLMXML_UserCode type="functionHeaderProductView" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassProductView;


//! Forward class declarations
class Instance;
class GDEInstanceGroup;
class StructureRevisionView;
class Structure;
class StructureRevision;

////////////////////////////////////////////////////////////////////////////////////
//! InstanceGraph class
/*!
\verbatim

      InstanceGraph. This is an element used as a container for elements which
      represent an assembly graph. 
      
      Attributes:

      rootInstanceRef: if the graph of Instances and StructureRevisionViews 
                       in the InstanceGraph has a single root, which is an Instance, 
                       this may be use to indicate it. 
      rootRefs:        however, in general there may be more than one root, and the 
                       roots may be Instances or StructureRevisionViews. The use of 
                       this attribute to specify the root(s) is preferred.
      
      viewControlRef:    optional reference to a ViewControl
      displayControlRef: optional reference to a DisplayControl
      
      Elements:
      
      May contain any element derived from Instance, GDEInstanceGroup, Structure
      StructureRevision or StructureRevisionView. May also contain Transforms which
      may be referenced by Instances.
      
\endverbatim
*/
class PLMXML60_API InstanceGraph : public Entity3D
{
public:
     
    //! Default constructor
    InstanceGraph( );
     
    //! Constructs a InstanceGraph with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    InstanceGraph( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~InstanceGraph();

private:

	//! Assignment operator
	InstanceGraph& operator=( const InstanceGraph& iSrc );

	//! Copy constructor
	InstanceGraph( const InstanceGraph& original );
     
public:

	//! Get number of references in Root array
	int NumberOfRootRefs() const;
     
	//! Add reference to 'arg' to Root array
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical AddRootRef( plmxml60::IdObject *arg );
     
	//! Add reference to an object pointed to by 'u' to Root array
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical AddRootId( const plmxml_api::String &u );
     
	//! Set i'th reference in Root array to 'arg'
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical SetRootRef( int i, plmxml60::IdObject *arg );
     
	//! Set i'th reference in Root array to an object pointed to by 'u'
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical SetRootId( int i, const plmxml_api::String &u );
     
	//! Resolve i'th reference in Root array and return an object it points to.
	plmxml60::IdObject *ResolveRootRef( int i, plmxml_api::Configuration* config = NULL );
     
	//! Resolve all references in Root array and return objects they point to.
	void ResolveRootRefs( plmxml_api::Array<plmxml60::IdObject *> & array, plmxml_api::Configuration* config = NULL );
     
	//! Get i'th reference in Root array as plmxml_api::String
	plmxml_api::String GetRootId( int i ) const;
     
	//! Get all references in Root array as an array of plmxml_api::String
	void GetRootIds( plmxml_api::Array<plmxml_api::String> &array ) const;
     
	//! Remove i'th reference from the Root array.
	void RemoveRootRef( int i );
     
	//! Remove reference to an object pointed to by 'u' from the Root array.
	void RemoveRootRef( const plmxml_api::String &u );
     
	//! Remove reference to 'arg' from the Root array.
	void RemoveRootRef( plmxml60::IdObject *arg );
     
	//! Remove all references Root array.
	void RemoveRootRefs();
	
	//! Check if Root is set
	plmxml_api::logical HasRootRefs( ) const;

	//! Set reference to DisplayControl using 'arg's plmxml_api::Id.
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical SetDisplayControlRef( plmxml60::IdObject *arg );

	//! Clear reference to DisplayControl
	void RemoveDisplayControlRef( );

	//! Find a plmxml60::IdObject referenced by DisplayControl
	plmxml60::IdObject *ResolveDisplayControlRef( plmxml_api::Configuration* config = NULL );

	//! Get DisplayControl reference
	plmxml_api::String GetDisplayControlId() const;

	//! Set DisplayControl reference.
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical SetDisplayControlId( const plmxml_api::String& u );
	
	//! Check if DisplayControl is set
	plmxml_api::logical HasDisplayControlRef( ) const;

	//! Set reference to RootInstance using 'arg's plmxml_api::Id.
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical SetRootInstanceRef( plmxml60::IdObject *arg );

	//! Clear reference to RootInstance
	void RemoveRootInstanceRef( );

	//! Find a plmxml60::IdObject referenced by RootInstance
	plmxml60::IdObject *ResolveRootInstanceRef( plmxml_api::Configuration* config = NULL );

	//! Get RootInstance reference
	plmxml_api::String GetRootInstanceId() const;

	//! Set RootInstance reference.
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical SetRootInstanceId( const plmxml_api::String& u );
	
	//! Check if RootInstance is set
	plmxml_api::logical HasRootInstanceRef( ) const;

	//! Set reference to ViewControl using 'arg's plmxml_api::Id.
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical SetViewControlRef( plmxml60::IdObject *arg );

	//! Clear reference to ViewControl
	void RemoveViewControlRef( );

	//! Find a plmxml60::IdObject referenced by ViewControl
	plmxml60::IdObject *ResolveViewControlRef( plmxml_api::Configuration* config = NULL );

	//! Get ViewControl reference
	plmxml_api::String GetViewControlId() const;

	//! Set ViewControl reference.
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical SetViewControlId( const plmxml_api::String& u );
	
	//! Check if ViewControl is set
	plmxml_api::logical HasViewControlRef( ) const;

	//! Add Instance child element to this InstanceGraph. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Instance *AddInstance();
     
	//! Add 'arg' as Instance child element to this InstanceGraph.
	plmxml_api::Result AddInstance( Instance *arg );

	//! Detach and delete all Instance child elements.
	void DeleteInstances();
     
	//! Get number of Instance child elements.
	int NumberOfInstances() const;
     
	//! Get i'th Instance child element.
	Instance *GetInstance( int i ) const;
     
	//! Get all Instance child element as an array
	void GetInstances( plmxml_api::Array<Instance*> &array ) const;
	     
	//! Detach and delete i'th Instance child element
	void DeleteInstance( int i );
     
	//! Detach and delete 'arg' if it's one of the Instance child elements
	void DeleteInstance( Instance *arg );

	//! Add GDEInstanceGroup child element to this InstanceGraph. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	GDEInstanceGroup *AddGDEInstanceGroup();
     
	//! Add 'arg' as GDEInstanceGroup child element to this InstanceGraph.
	plmxml_api::Result AddGDEInstanceGroup( GDEInstanceGroup *arg );

	//! Detach and delete all GDEInstanceGroup child elements.
	void DeleteGDEInstanceGroups();
     
	//! Get number of GDEInstanceGroup child elements.
	int NumberOfGDEInstanceGroups() const;
     
	//! Get i'th GDEInstanceGroup child element.
	GDEInstanceGroup *GetGDEInstanceGroup( int i ) const;
     
	//! Get all GDEInstanceGroup child element as an array
	void GetGDEInstanceGroups( plmxml_api::Array<GDEInstanceGroup*> &array ) const;
	     
	//! Detach and delete i'th GDEInstanceGroup child element
	void DeleteGDEInstanceGroup( int i );
     
	//! Detach and delete 'arg' if it's one of the GDEInstanceGroup child elements
	void DeleteGDEInstanceGroup( GDEInstanceGroup *arg );

	//! Add StructureRevisionView child element to this InstanceGraph. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	StructureRevisionView *AddStructureRevisionView();
     
	//! Add 'arg' as StructureRevisionView child element to this InstanceGraph.
	plmxml_api::Result AddStructureRevisionView( StructureRevisionView *arg );

	//! Detach and delete all StructureRevisionView child elements.
	void DeleteStructureRevisionViews();
     
	//! Get number of StructureRevisionView child elements.
	int NumberOfStructureRevisionViews() const;
     
	//! Get i'th StructureRevisionView child element.
	StructureRevisionView *GetStructureRevisionView( int i ) const;
     
	//! Get all StructureRevisionView child element as an array
	void GetStructureRevisionViews( plmxml_api::Array<StructureRevisionView*> &array ) const;
	     
	//! Detach and delete i'th StructureRevisionView child element
	void DeleteStructureRevisionView( int i );
     
	//! Detach and delete 'arg' if it's one of the StructureRevisionView child elements
	void DeleteStructureRevisionView( StructureRevisionView *arg );

	//! Add Structure child element to this InstanceGraph. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Structure *AddStructure();
     
	//! Add 'arg' as Structure child element to this InstanceGraph.
	plmxml_api::Result AddStructure( Structure *arg );

	//! Detach and delete all Structure child elements.
	void DeleteStructures();
     
	//! Get number of Structure child elements.
	int NumberOfStructures() const;
     
	//! Get i'th Structure child element.
	Structure *GetStructure( int i ) const;
     
	//! Get all Structure child element as an array
	void GetStructures( plmxml_api::Array<Structure*> &array ) const;
	     
	//! Detach and delete i'th Structure child element
	void DeleteStructure( int i );
     
	//! Detach and delete 'arg' if it's one of the Structure child elements
	void DeleteStructure( Structure *arg );

	//! Add StructureRevision child element to this InstanceGraph. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	StructureRevision *AddStructureRevision();
     
	//! Add 'arg' as StructureRevision child element to this InstanceGraph.
	plmxml_api::Result AddStructureRevision( StructureRevision *arg );

	//! Detach and delete all StructureRevision child elements.
	void DeleteStructureRevisions();
     
	//! Get number of StructureRevision child elements.
	int NumberOfStructureRevisions() const;
     
	//! Get i'th StructureRevision child element.
	StructureRevision *GetStructureRevision( int i ) const;
     
	//! Get all StructureRevision child element as an array
	void GetStructureRevisions( plmxml_api::Array<StructureRevision*> &array ) const;
	     
	//! Detach and delete i'th StructureRevision child element
	void DeleteStructureRevision( int i );
     
	//! Detach and delete 'arg' if it's one of the StructureRevision child elements
	void DeleteStructureRevision( StructureRevision *arg );

	//! Add Transform child element to this InstanceGraph. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Transform *AddTransform();
     
	//! Add 'arg' as Transform child element to this InstanceGraph.
	plmxml_api::Result AddTransform( Transform *arg );

	//! Detach and delete all Transform child elements.
	void DeleteTransforms();
     
	//! Get number of Transform child elements.
	int NumberOfTransforms() const;
     
	//! Get i'th Transform child element.
	Transform *GetTransform( int i ) const;
     
	//! Get all Transform child element as an array
	void GetTransforms( plmxml_api::Array<Transform*> &array ) const;
	     
	//! Detach and delete i'th Transform child element
	void DeleteTransform( int i );
     
	//! Detach and delete 'arg' if it's one of the Transform child elements
	void DeleteTransform( Transform *arg );
 
// <PLMXML_UserCode type="functionHeaderInstanceGraph" >
    // for compatibility with SDK 4.0:
    //! Add Part child element to this InstanceGraph. A pointer to added element is returned.
	Part *AddPart();
     
	//! Add 'arg' as Part child element to this InstanceGraph.
	plmxml_api::Result AddPart( Part *arg );

	//! Detach and delete all Part child elements.
	void DeleteParts();
     
	//! Get number of Part child elements.
	int NumberOfParts() const;
     
	//! Get i'th Part child element.
	Part *GetPart( int i ) const;
     
	//! Get all Part child element as an array
	void GetParts( plmxml_api::Array<Part*> &array ) const;
	     
	//! Detach and delete i'th Part child element
	void DeletePart( int i );
     
	//! Detach and delete 'arg' if it's one of the Part child elements
	void DeletePart( Part *arg );
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassInstanceGraph;


//! Forward class declarations
class StructureRevisionView;
class GDE;

////////////////////////////////////////////////////////////////////////////////////
//! StructureDef class
/*!
\verbatim

      This element may contain one or more InstanceGraphs, representing
      all or part of one or more assembly graphs. It also contains elements relating
      to its display. 
   
      Attributes:

      revision:           revision.
      defaultProductViewRef: may be used to indicate a default from among the ProductViews.
      default:            may be used to indicate that this is the default from among the
                          StructureDefs in the document.
      
      revisionRuleRef:    reference to a RevisionRule which was used to generate this
                          assembly from an Unconfigured Product Structure.
                          NB: this elements is not defined in this schema.

      variantRuleRef:     reference to a VariantRule which was use to generate this
                          configured structure.
                          
      configured:         indicates whether the Structure is Configured or
                          Unconfigured.
                             
      Elements:

      This element may contain Representations, DisplayControls, ViewControls, Light
      Sources, ProductViews, Materials, ConstructionGeometry, StructureRevisionViews,
      GDEs, Sections or InstanceGraphs.
      
\endverbatim
*/
class PLMXML60_API StructureDef : public AttribOwner
{
public:
     
    //! Default constructor
    StructureDef( );
     
    //! Constructs a StructureDef with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    StructureDef( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~StructureDef();

private:

	//! Assignment operator
	StructureDef& operator=( const StructureDef& iSrc );

	//! Copy constructor
	StructureDef( const StructureDef& original );
     
public:

	//! Set Default
	plmxml_api::Result SetDefault( plmxml_api::logical arg );

	//! Get Default
	plmxml_api::logical GetDefault() const;

	//! Check if Default is set
	plmxml_api::logical HasDefault() const;

	//! Unset Default
	plmxml_api::Result UnsetDefault();

	//! Get RevisionRule URI as plmxml_api::String
	plmxml_api::String GetRevisionRuleURI() const;

	//! Set RevisionRule URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetRevisionRuleURI( const plmxml_api::String& );
	
	//! Get the handle of RevisionRule URI. Does not resolve the URI.
	plmxml_api::Result GetRevisionRuleURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of RevisionRule URI. URI string is unchanged.
	plmxml_api::Result SetRevisionRuleURI( const plmxml_api::Handle& );
	
	//! Resolve RevisionRule URI and return an object (handle) it points to.
	plmxml_api::Result ResolveRevisionRuleURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset RevisionRule URI. Clears URI string and handle.
	plmxml_api::Result DeleteRevisionRuleURI();
	
	//! Check if RevisionRule URI is set
	plmxml_api::logical HasRevisionRuleURI( ) const;
	

	//! Get VariantRule URI as plmxml_api::String
	plmxml_api::String GetVariantRuleURI() const;

	//! Set VariantRule URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetVariantRuleURI( const plmxml_api::String& );
	
	//! Get the handle of VariantRule URI. Does not resolve the URI.
	plmxml_api::Result GetVariantRuleURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of VariantRule URI. URI string is unchanged.
	plmxml_api::Result SetVariantRuleURI( const plmxml_api::Handle& );
	
	//! Resolve VariantRule URI and return an object (handle) it points to.
	plmxml_api::Result ResolveVariantRuleURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset VariantRule URI. Clears URI string and handle.
	plmxml_api::Result DeleteVariantRuleURI();
	
	//! Check if VariantRule URI is set
	plmxml_api::logical HasVariantRuleURI( ) const;
	

	//! Set Revision
	plmxml_api::Result SetRevision( double arg );

     //! Get Revision
	double GetRevision() const;

	//! Check if Revision is set
	plmxml_api::logical HasRevision() const;

	//! Unset Revision
	plmxml_api::Result UnsetRevision();

	//! Set reference to DefaultProductView using 'arg's plmxml_api::Id.
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical SetDefaultProductViewRef( plmxml60::IdObject *arg );

	//! Clear reference to DefaultProductView
	void RemoveDefaultProductViewRef( );

	//! Find a plmxml60::IdObject referenced by DefaultProductView
	plmxml60::IdObject *ResolveDefaultProductViewRef( plmxml_api::Configuration* config = NULL );

	//! Get DefaultProductView reference
	plmxml_api::String GetDefaultProductViewId() const;

	//! Set DefaultProductView reference.
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical SetDefaultProductViewId( const plmxml_api::String& u );
	
	//! Check if DefaultProductView is set
	plmxml_api::logical HasDefaultProductViewRef( ) const;

	//! Set Configured
	plmxml_api::Result SetConfigured( plmxml_api::logical arg );

	//! Get Configured
	plmxml_api::logical GetConfigured() const;

	//! Check if Configured is set
	plmxml_api::logical HasConfigured() const;

	//! Unset Configured
	plmxml_api::Result UnsetConfigured();

	//! Add InstanceGraph child element to this StructureDef. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	InstanceGraph *AddInstanceGraph();
     
	//! Add 'arg' as InstanceGraph child element to this StructureDef.
	plmxml_api::Result AddInstanceGraph( InstanceGraph *arg );

	//! Detach and delete all InstanceGraph child elements.
	void DeleteInstanceGraphs();
     
	//! Get number of InstanceGraph child elements.
	int NumberOfInstanceGraphs() const;
     
	//! Get i'th InstanceGraph child element.
	InstanceGraph *GetInstanceGraph( int i ) const;
     
	//! Get all InstanceGraph child element as an array
	void GetInstanceGraphs( plmxml_api::Array<InstanceGraph*> &array ) const;
	     
	//! Detach and delete i'th InstanceGraph child element
	void DeleteInstanceGraph( int i );
     
	//! Detach and delete 'arg' if it's one of the InstanceGraph child elements
	void DeleteInstanceGraph( InstanceGraph *arg );

	//! Add StructureRevisionView child element to this StructureDef. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	StructureRevisionView *AddStructureRevisionView();
     
	//! Add 'arg' as StructureRevisionView child element to this StructureDef.
	plmxml_api::Result AddStructureRevisionView( StructureRevisionView *arg );

	//! Detach and delete all StructureRevisionView child elements.
	void DeleteStructureRevisionViews();
     
	//! Get number of StructureRevisionView child elements.
	int NumberOfStructureRevisionViews() const;
     
	//! Get i'th StructureRevisionView child element.
	StructureRevisionView *GetStructureRevisionView( int i ) const;
     
	//! Get all StructureRevisionView child element as an array
	void GetStructureRevisionViews( plmxml_api::Array<StructureRevisionView*> &array ) const;
	     
	//! Detach and delete i'th StructureRevisionView child element
	void DeleteStructureRevisionView( int i );
     
	//! Detach and delete 'arg' if it's one of the StructureRevisionView child elements
	void DeleteStructureRevisionView( StructureRevisionView *arg );

	//! Add Representation child element to this StructureDef. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Representation *AddRepresentation();
     
	//! Add 'arg' as Representation child element to this StructureDef.
	plmxml_api::Result AddRepresentation( Representation *arg );

	//! Detach and delete all Representation child elements.
	void DeleteRepresentations();
     
	//! Get number of Representation child elements.
	int NumberOfRepresentations() const;
     
	//! Get i'th Representation child element.
	Representation *GetRepresentation( int i ) const;
     
	//! Get all Representation child element as an array
	void GetRepresentations( plmxml_api::Array<Representation*> &array ) const;
	     
	//! Detach and delete i'th Representation child element
	void DeleteRepresentation( int i );
     
	//! Detach and delete 'arg' if it's one of the Representation child elements
	void DeleteRepresentation( Representation *arg );

	//! Add ProductView child element to this StructureDef. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	ProductView *AddProductView();
     
	//! Add 'arg' as ProductView child element to this StructureDef.
	plmxml_api::Result AddProductView( ProductView *arg );

	//! Detach and delete all ProductView child elements.
	void DeleteProductViews();
     
	//! Get number of ProductView child elements.
	int NumberOfProductViews() const;
     
	//! Get i'th ProductView child element.
	ProductView *GetProductView( int i ) const;
     
	//! Get all ProductView child element as an array
	void GetProductViews( plmxml_api::Array<ProductView*> &array ) const;
	     
	//! Detach and delete i'th ProductView child element
	void DeleteProductView( int i );
     
	//! Detach and delete 'arg' if it's one of the ProductView child elements
	void DeleteProductView( ProductView *arg );

	//! Add DisplayControl child element to this StructureDef. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	DisplayControl *AddDisplayControl();
     
	//! Add 'arg' as DisplayControl child element to this StructureDef.
	plmxml_api::Result AddDisplayControl( DisplayControl *arg );

	//! Detach and delete all DisplayControl child elements.
	void DeleteDisplayControls();
     
	//! Get number of DisplayControl child elements.
	int NumberOfDisplayControls() const;
     
	//! Get i'th DisplayControl child element.
	DisplayControl *GetDisplayControl( int i ) const;
     
	//! Get all DisplayControl child element as an array
	void GetDisplayControls( plmxml_api::Array<DisplayControl*> &array ) const;
	     
	//! Detach and delete i'th DisplayControl child element
	void DeleteDisplayControl( int i );
     
	//! Detach and delete 'arg' if it's one of the DisplayControl child elements
	void DeleteDisplayControl( DisplayControl *arg );

	//! Add ViewControl child element to this StructureDef. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	ViewControl *AddViewControl();
     
	//! Add 'arg' as ViewControl child element to this StructureDef.
	plmxml_api::Result AddViewControl( ViewControl *arg );

	//! Detach and delete all ViewControl child elements.
	void DeleteViewControls();
     
	//! Get number of ViewControl child elements.
	int NumberOfViewControls() const;
     
	//! Get i'th ViewControl child element.
	ViewControl *GetViewControl( int i ) const;
     
	//! Get all ViewControl child element as an array
	void GetViewControls( plmxml_api::Array<ViewControl*> &array ) const;
	     
	//! Detach and delete i'th ViewControl child element
	void DeleteViewControl( int i );
     
	//! Detach and delete 'arg' if it's one of the ViewControl child elements
	void DeleteViewControl( ViewControl *arg );

	//! Add LightSource child element to this StructureDef. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	LightSource *AddLightSource();
     
	//! Add 'arg' as LightSource child element to this StructureDef.
	plmxml_api::Result AddLightSource( LightSource *arg );

	//! Detach and delete all LightSource child elements.
	void DeleteLightSources();
     
	//! Get number of LightSource child elements.
	int NumberOfLightSources() const;
     
	//! Get i'th LightSource child element.
	LightSource *GetLightSource( int i ) const;
     
	//! Get all LightSource child element as an array
	void GetLightSources( plmxml_api::Array<LightSource*> &array ) const;
	     
	//! Detach and delete i'th LightSource child element
	void DeleteLightSource( int i );
     
	//! Detach and delete 'arg' if it's one of the LightSource child elements
	void DeleteLightSource( LightSource *arg );

	//! Add Material child element to this StructureDef. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Material *AddMaterial();
     
	//! Add 'arg' as Material child element to this StructureDef.
	plmxml_api::Result AddMaterial( Material *arg );

	//! Detach and delete all Material child elements.
	void DeleteMaterials();
     
	//! Get number of Material child elements.
	int NumberOfMaterials() const;
     
	//! Get i'th Material child element.
	Material *GetMaterial( int i ) const;
     
	//! Get all Material child element as an array
	void GetMaterials( plmxml_api::Array<Material*> &array ) const;
	     
	//! Detach and delete i'th Material child element
	void DeleteMaterial( int i );
     
	//! Detach and delete 'arg' if it's one of the Material child elements
	void DeleteMaterial( Material *arg );

	//! Add ConstructionGeometry child element to this StructureDef. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	ConstructionGeometry *AddConstructionGeometry();
     
	//! Add 'arg' as ConstructionGeometry child element to this StructureDef.
	plmxml_api::Result AddConstructionGeometry( ConstructionGeometry *arg );

	//! Detach and delete all ConstructionGeometry child elements.
	void DeleteConstructionGeometries();
     
	//! Get number of ConstructionGeometry child elements.
	int NumberOfConstructionGeometries() const;
     
	//! Get i'th ConstructionGeometry child element.
	ConstructionGeometry *GetConstructionGeometry( int i ) const;
     
	//! Get all ConstructionGeometry child element as an array
	void GetConstructionGeometries( plmxml_api::Array<ConstructionGeometry*> &array ) const;
	     
	//! Detach and delete i'th ConstructionGeometry child element
	void DeleteConstructionGeometry( int i );
     
	//! Detach and delete 'arg' if it's one of the ConstructionGeometry child elements
	void DeleteConstructionGeometry( ConstructionGeometry *arg );

	//! Add GDE child element to this StructureDef. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	GDE *AddGDE();
     
	//! Add 'arg' as GDE child element to this StructureDef.
	plmxml_api::Result AddGDE( GDE *arg );

	//! Detach and delete all GDE child elements.
	void DeleteGDEs();
     
	//! Get number of GDE child elements.
	int NumberOfGDEs() const;
     
	//! Get i'th GDE child element.
	GDE *GetGDE( int i ) const;
     
	//! Get all GDE child element as an array
	void GetGDEs( plmxml_api::Array<GDE*> &array ) const;
	     
	//! Detach and delete i'th GDE child element
	void DeleteGDE( int i );
     
	//! Detach and delete 'arg' if it's one of the GDE child elements
	void DeleteGDE( GDE *arg );

	//! Add Section child element to this StructureDef. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Section *AddSection();
     
	//! Add 'arg' as Section child element to this StructureDef.
	plmxml_api::Result AddSection( Section *arg );

	//! Detach and delete all Section child elements.
	void DeleteSections();
     
	//! Get number of Section child elements.
	int NumberOfSections() const;
     
	//! Get i'th Section child element.
	Section *GetSection( int i ) const;
     
	//! Get all Section child element as an array
	void GetSections( plmxml_api::Array<Section*> &array ) const;
	     
	//! Detach and delete i'th Section child element
	void DeleteSection( int i );
     
	//! Detach and delete 'arg' if it's one of the Section child elements
	void DeleteSection( Section *arg );
 
// <PLMXML_UserCode type="functionHeaderStructureDef" >
    // for compatibility with SDK 4.0:
    //! Add Part child element to this StructureDef. A pointer to added element is returned.
	Part *AddPart();
     
	//! Add 'arg' as Part child element to this StructureDef.
	plmxml_api::Result AddPart( Part *arg );

	//! Detach and delete all Part child elements.
	void DeleteParts();
     
	//! Get number of Part child elements.
	int NumberOfParts() const;
     
	//! Get i'th Part child element.
	Part *GetPart( int i ) const;
     
	//! Get all Part child element as an array
	void GetParts( plmxml_api::Array<Part*> &array ) const;
	     
	//! Detach and delete i'th Part child element
	void DeletePart( int i );
     
	//! Detach and delete 'arg' if it's one of the Part child elements
	void DeletePart( Part *arg );
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassStructureDef;


////////////////////////////////////////////////////////////////////////////////////
//! ProductDef class
/*!
\verbatim

      This element may contain one or more InstanceGraphs, containing ProductInstances
      and ProductRevisionViews, representing all or part of one or more assembly graphs. 
      It also contains elements relating to its display.
      
\endverbatim
*/
class PLMXML60_API ProductDef : public StructureDef
{
public:
     
    //! Default constructor
    ProductDef( );
     
    //! Constructs a ProductDef with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ProductDef( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ProductDef();

private:

	//! Assignment operator
	ProductDef& operator=( const ProductDef& iSrc );

	//! Copy constructor
	ProductDef( const ProductDef& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderProductDef" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassProductDef;


////////////////////////////////////////////////////////////////////////////////////
//! UserListElement class
/*!
\verbatim

      This element defines a single entry in a UserList. The 'value' attribute
      must contain data of the type specified by the 'type' attribute in the
      owning list.

      Attributes:

      value:            data value (required).
      description:      textual description of the value.
      valueRef:         References a multiple language version of value. If
                        multiple language support is required, valueRef should
                        be used in addition to value.
      descriptionRef:   References a multiple language version of description.
                        If multiple language support is required, descriptionRef
                        should be used in addition to description.
      
\endverbatim
*/
class PLMXML60_API UserListElement : public plmxml_api::Object
{
public:
     
    //! Default constructor
    UserListElement( );
     
    //! Constructs a UserListElement with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    UserListElement( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~UserListElement();

private:

	//! Assignment operator
	UserListElement& operator=( const UserListElement& iSrc );

	//! Copy constructor
	UserListElement( const UserListElement& original );
     
public:

	//! Get Description of this UserListElement
	plmxml_api::String GetDescription() const;

	//! Set Description of this UserListElement
	plmxml_api::Result SetDescription( const plmxml_api::String &s );
	
	//! Check if Description is set
	plmxml_api::logical HasDescription( ) const;
	
	//! Unset Description
	plmxml_api::Result UnsetDescription( );

	//! Get Description URI as plmxml_api::String
	plmxml_api::String GetDescriptionURI() const;

	//! Set Description URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetDescriptionURI( const plmxml_api::String& );
	
	//! Get the handle of Description URI. Does not resolve the URI.
	plmxml_api::Result GetDescriptionURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Description URI. URI string is unchanged.
	plmxml_api::Result SetDescriptionURI( const plmxml_api::Handle& );
	
	//! Resolve Description URI and return an object (handle) it points to.
	plmxml_api::Result ResolveDescriptionURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Description URI. Clears URI string and handle.
	plmxml_api::Result DeleteDescriptionURI();
	
	//! Check if Description URI is set
	plmxml_api::logical HasDescriptionURI( ) const;
	

	//! Get Value URI as plmxml_api::String
	plmxml_api::String GetValueURI() const;

	//! Set Value URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetValueURI( const plmxml_api::String& );
	
	//! Get the handle of Value URI. Does not resolve the URI.
	plmxml_api::Result GetValueURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Value URI. URI string is unchanged.
	plmxml_api::Result SetValueURI( const plmxml_api::Handle& );
	
	//! Resolve Value URI and return an object (handle) it points to.
	plmxml_api::Result ResolveValueURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Value URI. Clears URI string and handle.
	plmxml_api::Result DeleteValueURI();
	
	//! Check if Value URI is set
	plmxml_api::logical HasValueURI( ) const;
	

	//! Get Value of this UserListElement
	plmxml_api::String GetValue() const;

	//! Set Value of this UserListElement
	plmxml_api::Result SetValue( const plmxml_api::String &s );
	
	//! Check if Value is set
	plmxml_api::logical HasValue( ) const;
	
	//! Unset Value
	plmxml_api::Result UnsetValue( );
 
// <PLMXML_UserCode type="functionHeaderUserListElement" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassUserListElement;


////////////////////////////////////////////////////////////////////////////////////
//! UserList class
/*!
\verbatim

      This element defines a list of user specified data items. Each item in the 
      list is of the same type - as specified by the 'type' attribute'.

      Attributes:

      type:           type of data items, i.e. int, ints, etc. 

      Elements:

      Item:           One element per data item.
      
\endverbatim
*/
class PLMXML60_API UserList : public Attribute
{
public:
     
    //! Default constructor
    UserList( );
     
    //! Constructs a UserList with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    UserList( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~UserList();

private:

	//! Assignment operator
	UserList& operator=( const UserList& iSrc );

	//! Copy constructor
	UserList( const UserList& original );
     
public:

	//! Set Type
	plmxml_api::Result SetType( const eUserValueDataType& arg );

	//! Get Type
	eUserValueDataType GetType() const;

	//! Add Item child element to this UserList. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	UserListElement *AddItem();
     
	//! Add 'arg' as Item child element to this UserList.
	plmxml_api::Result AddItem( UserListElement *arg );

	//! Detach and delete all Item child elements.
	void DeleteItems();
     
	//! Get number of Item child elements.
	int NumberOfItems() const;
     
	//! Get i'th Item child element.
	UserListElement *GetItem( int i ) const;
     
	//! Get all Item child element as an array
	void GetItems( plmxml_api::Array<UserListElement*> &array ) const;
	     
	//! Detach and delete i'th Item child element
	void DeleteItem( int i );
     
	//! Detach and delete 'arg' if it's one of the Item child elements
	void DeleteItem( UserListElement *arg );
 
// <PLMXML_UserCode type="functionHeaderUserList" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassUserList;


////////////////////////////////////////////////////////////////////////////////////
//! UserValue class
/*!
\verbatim

      This element defines a single title/value pair in a UserData table.

      Attributes:

      title:            name of this entry in the table.
      value:            value of the entry.
      type:             datatype of the value, i.e. int, ints, etc, from
                        UserValueDataType.
      format:           format string as used by printf.
      editable:         false if this value should not be modified by the
                        receiving application.
      dataRef:          If type is 'reference', dataRef specifies the referenced
                        element. The value attribute is ignored.
                        If type is 'enum' or 'list', then a UserList element
                        should be specified either by dataRef, or by being
                        included as a sub-element. In the 'enum' case, the
                        UserList gives the valid values of the enum; in the
                        'list' case, 'value' is ignored and the UserList IS the
                        value of this entry in the table.
      minInclusive:     Minimum value allowed (inclusive).
      minExclusive:     Minimum value allowed (exclusive).
      maxInclusive:     Maximum value allowed (inclusive).
      maxExclusive:     Maximum value allowed (exclusive).
      stepValue:        Allowed values go from min to max in steps of
                        'stepValue'.
      minLength:        Minimum list length allowed (only for type="list").
      maxLength:        Maximum list length allowed (ditto).
      titleRef:         References a multiple language version of title. If
                        multiple language support is required, titleRef should
                        be used in addition to title.
      valueRef:         References a multiple language version of value. If
                        multiple language support is required, valueRef should
                        be used in addition to value.

      Elements:

      UserList:         May contain a single UserList element (see dataRef
                        above).
      
\endverbatim
*/
class PLMXML60_API UserValue : public plmxml_api::Object
{
public:
     
    //! Default constructor
    UserValue( );
     
    //! Constructs a UserValue with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    UserValue( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~UserValue();

private:

	//! Assignment operator
	UserValue& operator=( const UserValue& iSrc );

	//! Copy constructor
	UserValue( const UserValue& original );
     
public:

	//! Set StepValue
	plmxml_api::Result SetStepValue( double arg );

     //! Get StepValue
	double GetStepValue() const;

	//! Check if StepValue is set
	plmxml_api::logical HasStepValue() const;

	//! Unset StepValue
	plmxml_api::Result UnsetStepValue();

	//! Set MinExclusive
	plmxml_api::Result SetMinExclusive( double arg );

     //! Get MinExclusive
	double GetMinExclusive() const;

	//! Check if MinExclusive is set
	plmxml_api::logical HasMinExclusive() const;

	//! Unset MinExclusive
	plmxml_api::Result UnsetMinExclusive();

	//! Get Title of this UserValue
	plmxml_api::String GetTitle() const;

	//! Set Title of this UserValue
	plmxml_api::Result SetTitle( const plmxml_api::String &s );
	
	//! Check if Title is set
	plmxml_api::logical HasTitle( ) const;
	
	//! Unset Title
	plmxml_api::Result UnsetTitle( );

	//! Set MaxExclusive
	plmxml_api::Result SetMaxExclusive( double arg );

     //! Get MaxExclusive
	double GetMaxExclusive() const;

	//! Check if MaxExclusive is set
	plmxml_api::logical HasMaxExclusive() const;

	//! Unset MaxExclusive
	plmxml_api::Result UnsetMaxExclusive();

	//! Get Title URI as plmxml_api::String
	plmxml_api::String GetTitleURI() const;

	//! Set Title URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetTitleURI( const plmxml_api::String& );
	
	//! Get the handle of Title URI. Does not resolve the URI.
	plmxml_api::Result GetTitleURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Title URI. URI string is unchanged.
	plmxml_api::Result SetTitleURI( const plmxml_api::Handle& );
	
	//! Resolve Title URI and return an object (handle) it points to.
	plmxml_api::Result ResolveTitleURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Title URI. Clears URI string and handle.
	plmxml_api::Result DeleteTitleURI();
	
	//! Check if Title URI is set
	plmxml_api::logical HasTitleURI( ) const;
	

	//! Set Type
	plmxml_api::Result SetType( const eUserValueDataType& arg );

	//! Get Type
	eUserValueDataType GetType() const;

	//! Set MaxLength
	plmxml_api::Result SetMaxLength( int arg );
     
	//! Get MaxLength
	int GetMaxLength() const;
     
	//! Check if MaxLength is set
	plmxml_api::logical HasMaxLength() const;
     
	//! Unset MaxLength
	plmxml_api::Result UnsetMaxLength();

	//! Get Format of this UserValue
	plmxml_api::String GetFormat() const;

	//! Set Format of this UserValue
	plmxml_api::Result SetFormat( const plmxml_api::String &s );
	
	//! Check if Format is set
	plmxml_api::logical HasFormat( ) const;
	
	//! Unset Format
	plmxml_api::Result UnsetFormat( );

	//! Get Value URI as plmxml_api::String
	plmxml_api::String GetValueURI() const;

	//! Set Value URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetValueURI( const plmxml_api::String& );
	
	//! Get the handle of Value URI. Does not resolve the URI.
	plmxml_api::Result GetValueURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Value URI. URI string is unchanged.
	plmxml_api::Result SetValueURI( const plmxml_api::Handle& );
	
	//! Resolve Value URI and return an object (handle) it points to.
	plmxml_api::Result ResolveValueURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Value URI. Clears URI string and handle.
	plmxml_api::Result DeleteValueURI();
	
	//! Check if Value URI is set
	plmxml_api::logical HasValueURI( ) const;
	

	//! Set MinInclusive
	plmxml_api::Result SetMinInclusive( double arg );

     //! Get MinInclusive
	double GetMinInclusive() const;

	//! Check if MinInclusive is set
	plmxml_api::logical HasMinInclusive() const;

	//! Unset MinInclusive
	plmxml_api::Result UnsetMinInclusive();

	//! Set Editable
	plmxml_api::Result SetEditable( plmxml_api::logical arg );

	//! Get Editable
	plmxml_api::logical GetEditable() const;

	//! Check if Editable is set
	plmxml_api::logical HasEditable() const;

	//! Unset Editable
	plmxml_api::Result UnsetEditable();

	//! Get Value of this UserValue
	plmxml_api::String GetValue() const;

	//! Set Value of this UserValue
	plmxml_api::Result SetValue( const plmxml_api::String &s );
	
	//! Check if Value is set
	plmxml_api::logical HasValue( ) const;
	
	//! Unset Value
	plmxml_api::Result UnsetValue( );

	//! Set MaxInclusive
	plmxml_api::Result SetMaxInclusive( double arg );

     //! Get MaxInclusive
	double GetMaxInclusive() const;

	//! Check if MaxInclusive is set
	plmxml_api::logical HasMaxInclusive() const;

	//! Unset MaxInclusive
	plmxml_api::Result UnsetMaxInclusive();

	//! Get Data URI as plmxml_api::String
	plmxml_api::String GetDataURI() const;

	//! Set Data URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetDataURI( const plmxml_api::String& );
	
	//! Get the handle of Data URI. Does not resolve the URI.
	plmxml_api::Result GetDataURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Data URI. URI string is unchanged.
	plmxml_api::Result SetDataURI( const plmxml_api::Handle& );
	
	//! Resolve Data URI and return an object (handle) it points to.
	plmxml_api::Result ResolveDataURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Data URI. Clears URI string and handle.
	plmxml_api::Result DeleteDataURI();
	
	//! Check if Data URI is set
	plmxml_api::logical HasDataURI( ) const;
	

	//! Set MinLength
	plmxml_api::Result SetMinLength( int arg );
     
	//! Get MinLength
	int GetMinLength() const;
     
	//! Check if MinLength is set
	plmxml_api::logical HasMinLength() const;
     
	//! Unset MinLength
	plmxml_api::Result UnsetMinLength();

	//! Add UserList child element to this UserValue. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	UserList *AddUserList();
     
	//! Set UserList child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetUserList( UserList *arg );
     
	//! Get UserList child element of this UserValue.
	UserList *GetUserList() const;
     
	//! Detach and delete UserList child element tree from this UserValue.
	void DeleteUserList();
 
// <PLMXML_UserCode type="functionHeaderUserValue" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassUserValue;


////////////////////////////////////////////////////////////////////////////////////
//! UserData class
/*!
\verbatim

      The UserData element is a PLMXML Attribute used to represent a table of
      title/value pairs. It is up to communicating applications to agree on the
      meaning of these tables.
      UserData is based on the plm:Attribute base class so that it may be
      substituted wherever PLMXML Attributes are permitted.

      Attributes:

      type:             A string giving the type of UserData. No specified
                        values.
      typeRef:          References a multiple language version of type. If
                        multiple language support is required, typeRef should be
                        used in addition to type.

      Elements:

      UserValue:      One element per entry in the table (at least one).
      
\endverbatim
*/
class PLMXML60_API UserData : public Attribute
{
public:
     
    //! Default constructor
    UserData( );
     
    //! Constructs a UserData with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    UserData( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~UserData();

private:

	//! Assignment operator
	UserData& operator=( const UserData& iSrc );

	//! Copy constructor
	UserData( const UserData& original );
     
public:

	//! Get Type of this UserData
	plmxml_api::String GetType() const;

	//! Set Type of this UserData
	plmxml_api::Result SetType( const plmxml_api::String &s );
	
	//! Check if Type is set
	plmxml_api::logical HasType( ) const;
	
	//! Unset Type
	plmxml_api::Result UnsetType( );

	//! Get Type URI as plmxml_api::String
	plmxml_api::String GetTypeURI() const;

	//! Set Type URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetTypeURI( const plmxml_api::String& );
	
	//! Get the handle of Type URI. Does not resolve the URI.
	plmxml_api::Result GetTypeURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Type URI. URI string is unchanged.
	plmxml_api::Result SetTypeURI( const plmxml_api::Handle& );
	
	//! Resolve Type URI and return an object (handle) it points to.
	plmxml_api::Result ResolveTypeURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Type URI. Clears URI string and handle.
	plmxml_api::Result DeleteTypeURI();
	
	//! Check if Type URI is set
	plmxml_api::logical HasTypeURI( ) const;
	

	//! Add UserValue child element to this UserData. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	UserValue *AddUserValue();
     
	//! Add 'arg' as UserValue child element to this UserData.
	plmxml_api::Result AddUserValue( UserValue *arg );

	//! Detach and delete all UserValue child elements.
	void DeleteUserValues();
     
	//! Get number of UserValue child elements.
	int NumberOfUserValues() const;
     
	//! Get i'th UserValue child element.
	UserValue *GetUserValue( int i ) const;
     
	//! Get all UserValue child element as an array
	void GetUserValues( plmxml_api::Array<UserValue*> &array ) const;
	     
	//! Detach and delete i'th UserValue child element
	void DeleteUserValue( int i );
     
	//! Detach and delete 'arg' if it's one of the UserValue child elements
	void DeleteUserValue( UserValue *arg );
 
// <PLMXML_UserCode type="functionHeaderUserData" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassUserData;


////////////////////////////////////////////////////////////////////////////////////
//! UserEnum class
/*!
\verbatim

      This element represents a user defined enumeration value. 

      Attributes:

      value:            the enum value (required).
      listRef:          reference to a UserList element which gives the valid
                        values in the enum. 'value' must be one of these values.
      valueRef:         References a multiple language version of value. If
                        multiple language support is required, valueRef should
                        be used in addition to value.
      
\endverbatim
*/
class PLMXML60_API UserEnum : public plmxml_api::Object
{
public:
     
    //! Default constructor
    UserEnum( );
     
    //! Constructs a UserEnum with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    UserEnum( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~UserEnum();

private:

	//! Assignment operator
	UserEnum& operator=( const UserEnum& iSrc );

	//! Copy constructor
	UserEnum( const UserEnum& original );
     
public:

	//! Get List URI as plmxml_api::String
	plmxml_api::String GetListURI() const;

	//! Set List URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetListURI( const plmxml_api::String& );
	
	//! Get the handle of List URI. Does not resolve the URI.
	plmxml_api::Result GetListURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of List URI. URI string is unchanged.
	plmxml_api::Result SetListURI( const plmxml_api::Handle& );
	
	//! Resolve List URI and return an object (handle) it points to.
	plmxml_api::Result ResolveListURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset List URI. Clears URI string and handle.
	plmxml_api::Result DeleteListURI();
	
	//! Check if List URI is set
	plmxml_api::logical HasListURI( ) const;
	

	//! Get Value URI as plmxml_api::String
	plmxml_api::String GetValueURI() const;

	//! Set Value URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetValueURI( const plmxml_api::String& );
	
	//! Get the handle of Value URI. Does not resolve the URI.
	plmxml_api::Result GetValueURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Value URI. URI string is unchanged.
	plmxml_api::Result SetValueURI( const plmxml_api::Handle& );
	
	//! Resolve Value URI and return an object (handle) it points to.
	plmxml_api::Result ResolveValueURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Value URI. Clears URI string and handle.
	plmxml_api::Result DeleteValueURI();
	
	//! Check if Value URI is set
	plmxml_api::logical HasValueURI( ) const;
	

	//! Get Value of this UserEnum
	plmxml_api::String GetValue() const;

	//! Set Value of this UserEnum
	plmxml_api::Result SetValue( const plmxml_api::String &s );
	
	//! Check if Value is set
	plmxml_api::logical HasValue( ) const;
	
	//! Unset Value
	plmxml_api::Result UnsetValue( );
 
// <PLMXML_UserCode type="functionHeaderUserEnum" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassUserEnum;


////////////////////////////////////////////////////////////////////////////////////
//! EntityUserData class
/*!
\verbatim

      This element is used to associate one or more entities with a set of UserData 
      elements. It is substitutable for Attribute.
      
      Attributes:
      
      userDataRefs:  IDREFS to the UserData element(s).
      
      Elements:
      
      EntityRef:     Element derived from EntityRef, used to specify which entity
                     is to be associated with the UserData.
      
\endverbatim
*/
class PLMXML60_API EntityUserData : public Attribute
{
public:
     
    //! Default constructor
    EntityUserData( );
     
    //! Constructs a EntityUserData with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    EntityUserData( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~EntityUserData();

private:

	//! Assignment operator
	EntityUserData& operator=( const EntityUserData& iSrc );

	//! Copy constructor
	EntityUserData( const EntityUserData& original );
     
public:

	//! Get number of references in UserData array
	int NumberOfUserDataRefs() const;
     
	//! Add reference to 'arg' to UserData array
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical AddUserDataRef( plmxml60::IdObject *arg );
     
	//! Add reference to an object pointed to by 'u' to UserData array
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical AddUserDataId( const plmxml_api::String &u );
     
	//! Set i'th reference in UserData array to 'arg'
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical SetUserDataRef( int i, plmxml60::IdObject *arg );
     
	//! Set i'th reference in UserData array to an object pointed to by 'u'
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical SetUserDataId( int i, const plmxml_api::String &u );
     
	//! Resolve i'th reference in UserData array and return an object it points to.
	plmxml60::IdObject *ResolveUserDataRef( int i, plmxml_api::Configuration* config = NULL );
     
	//! Resolve all references in UserData array and return objects they point to.
	void ResolveUserDataRefs( plmxml_api::Array<plmxml60::IdObject *> & array, plmxml_api::Configuration* config = NULL );
     
	//! Get i'th reference in UserData array as plmxml_api::String
	plmxml_api::String GetUserDataId( int i ) const;
     
	//! Get all references in UserData array as an array of plmxml_api::String
	void GetUserDataIds( plmxml_api::Array<plmxml_api::String> &array ) const;
     
	//! Remove i'th reference from the UserData array.
	void RemoveUserDataRef( int i );
     
	//! Remove reference to an object pointed to by 'u' from the UserData array.
	void RemoveUserDataRef( const plmxml_api::String &u );
     
	//! Remove reference to 'arg' from the UserData array.
	void RemoveUserDataRef( plmxml60::IdObject *arg );
     
	//! Remove all references UserData array.
	void RemoveUserDataRefs();
	
	//! Check if UserData is set
	plmxml_api::logical HasUserDataRefs( ) const;

	//! Add EntityRef child element to this EntityUserData. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	EntityRef *AddEntityRef();
     
	//! Add 'arg' as EntityRef child element to this EntityUserData.
	plmxml_api::Result AddEntityRef( EntityRef *arg );

	//! Detach and delete all EntityRef child elements.
	void DeleteEntityRefs();
     
	//! Get number of EntityRef child elements.
	int NumberOfEntityRefs() const;
     
	//! Get i'th EntityRef child element.
	EntityRef *GetEntityRef( int i ) const;
     
	//! Get all EntityRef child element as an array
	void GetEntityRefs( plmxml_api::Array<EntityRef*> &array ) const;
	     
	//! Detach and delete i'th EntityRef child element
	void DeleteEntityRef( int i );
     
	//! Detach and delete 'arg' if it's one of the EntityRef child elements
	void DeleteEntityRef( EntityRef *arg );
 
// <PLMXML_UserCode type="functionHeaderEntityUserData" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassEntityUserData;


////////////////////////////////////////////////////////////////////////////////////
//! XTRep class
/*!
\verbatim

      XT Representation component of the PLMXML Schema
      
\endverbatim
*/
class PLMXML60_API XTRep : public InternalRep
{
public:
     
    //! Default constructor
    XTRep( );
     
    //! Constructs a XTRep with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    XTRep( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~XTRep();

private:

	//! Assignment operator
	XTRep& operator=( const XTRep& iSrc );

	//! Copy constructor
	XTRep( const XTRep& original );
     
public:

	//! Get XTData of this XTRep
	plmxml_api::String GetXTData() const;

	//! Set XTData of this XTRep
	plmxml_api::Result SetXTData( const plmxml_api::String &s );
	
	//! Check if XTData is set
	plmxml_api::logical HasXTData( ) const;
	
	//! Unset XTData
	plmxml_api::Result UnsetXTData( );
 
// <PLMXML_UserCode type="functionHeaderXTRep" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassXTRep;


////////////////////////////////////////////////////////////////////////////////////
//! MassPropertyReal class
/*!
\verbatim

\endverbatim
*/
class PLMXML60_API MassPropertyReal : public plmxml_api::Object
{
public:
     
    //! Default constructor
    MassPropertyReal( );
     
    //! Constructs a MassPropertyReal with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    MassPropertyReal( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~MassPropertyReal();

private:

	//! Assignment operator
	MassPropertyReal& operator=( const MassPropertyReal& iSrc );

	//! Copy constructor
	MassPropertyReal( const MassPropertyReal& original );
     
public:

	//! Set Error
	plmxml_api::Result SetError( double arg );

     //! Get Error
	double GetError() const;

	//! Check if Error is set
	plmxml_api::logical HasError() const;

	//! Unset Error
	plmxml_api::Result UnsetError();
 
// <PLMXML_UserCode type="functionHeaderMassPropertyReal" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassMassPropertyReal;


////////////////////////////////////////////////////////////////////////////////////
//! Length class
/*!
\verbatim

\endverbatim
*/
class PLMXML60_API Length : public MassPropertyReal
{
public:
     
    //! Default constructor
    Length( );
     
    //! Constructs a Length with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Length( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Length();

private:

	//! Assignment operator
	Length& operator=( const Length& iSrc );

	//! Copy constructor
	Length( const Length& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderLength" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassLength;


////////////////////////////////////////////////////////////////////////////////////
//! Area class
/*!
\verbatim

\endverbatim
*/
class PLMXML60_API Area : public MassPropertyReal
{
public:
     
    //! Default constructor
    Area( );
     
    //! Constructs a Area with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Area( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Area();

private:

	//! Assignment operator
	Area& operator=( const Area& iSrc );

	//! Copy constructor
	Area( const Area& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderArea" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassArea;


////////////////////////////////////////////////////////////////////////////////////
//! Mass class
/*!
\verbatim

\endverbatim
*/
class PLMXML60_API Mass : public MassPropertyReal
{
public:
     
    //! Default constructor
    Mass( );
     
    //! Constructs a Mass with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Mass( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Mass();

private:

	//! Assignment operator
	Mass& operator=( const Mass& iSrc );

	//! Copy constructor
	Mass( const Mass& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderMass" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassMass;


////////////////////////////////////////////////////////////////////////////////////
//! MassPropertyVector class
/*!
\verbatim

\endverbatim
*/
class PLMXML60_API MassPropertyVector : public plmxml_api::Object
{
public:
     
    //! Default constructor
    MassPropertyVector( );
     
    //! Constructs a MassPropertyVector with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    MassPropertyVector( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~MassPropertyVector();

private:

	//! Assignment operator
	MassPropertyVector& operator=( const MassPropertyVector& iSrc );

	//! Copy constructor
	MassPropertyVector( const MassPropertyVector& original );
     
public:

	//! Set Error
	plmxml_api::Result SetError( double arg );

     //! Get Error
	double GetError() const;

	//! Check if Error is set
	plmxml_api::logical HasError() const;

	//! Unset Error
	plmxml_api::Result UnsetError();
 
// <PLMXML_UserCode type="functionHeaderMassPropertyVector" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassMassPropertyVector;


////////////////////////////////////////////////////////////////////////////////////
//! MassPropertyArray class
/*!
\verbatim

\endverbatim
*/
class PLMXML60_API MassPropertyArray : public plmxml_api::Object
{
public:
     
    //! Default constructor
    MassPropertyArray( );
     
    //! Constructs a MassPropertyArray with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    MassPropertyArray( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~MassPropertyArray();

private:

	//! Assignment operator
	MassPropertyArray& operator=( const MassPropertyArray& iSrc );

	//! Copy constructor
	MassPropertyArray( const MassPropertyArray& original );
     
public:

	//! Set Error
	plmxml_api::Result SetError( double arg );

     //! Get Error
	double GetError() const;

	//! Check if Error is set
	plmxml_api::logical HasError() const;

	//! Unset Error
	plmxml_api::Result UnsetError();
 
// <PLMXML_UserCode type="functionHeaderMassPropertyArray" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassMassPropertyArray;


////////////////////////////////////////////////////////////////////////////////////
//! MomentsOfInertia class
/*!
\verbatim

\endverbatim
*/
class PLMXML60_API MomentsOfInertia : public MassPropertyArray
{
public:
     
    //! Default constructor
    MomentsOfInertia( );
     
    //! Constructs a MomentsOfInertia with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    MomentsOfInertia( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~MomentsOfInertia();

private:

	//! Assignment operator
	MomentsOfInertia& operator=( const MomentsOfInertia& iSrc );

	//! Copy constructor
	MomentsOfInertia( const MomentsOfInertia& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderMomentsOfInertia" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassMomentsOfInertia;


////////////////////////////////////////////////////////////////////////////////////
//! ProductsOfInertia class
/*!
\verbatim

\endverbatim
*/
class PLMXML60_API ProductsOfInertia : public MassPropertyArray
{
public:
     
    //! Default constructor
    ProductsOfInertia( );
     
    //! Constructs a ProductsOfInertia with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ProductsOfInertia( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ProductsOfInertia();

private:

	//! Assignment operator
	ProductsOfInertia& operator=( const ProductsOfInertia& iSrc );

	//! Copy constructor
	ProductsOfInertia( const ProductsOfInertia& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderProductsOfInertia" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassProductsOfInertia;


//! Forward class declarations
class Volume;
class Density;
class CentreOfMass;

////////////////////////////////////////////////////////////////////////////////////
//! MassProperties class
/*!
\verbatim

      PLMXML Attribute describing mass properties.
      
\endverbatim
*/
class PLMXML60_API MassProperties : public Attribute
{
public:
     
    //! Default constructor
    MassProperties( );
     
    //! Constructs a MassProperties with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    MassProperties( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~MassProperties();

private:

	//! Assignment operator
	MassProperties& operator=( const MassProperties& iSrc );

	//! Copy constructor
	MassProperties( const MassProperties& original );
     
public:

	//! Set Units
	plmxml_api::Result SetUnits( const eMassPropertyUnitType& arg );

	//! Get Units
	eMassPropertyUnitType GetUnits() const;

	//! Add Length child element to this MassProperties. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	Length *AddLength();
     
	//! Set Length child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetLength( Length *arg );
     
	//! Get Length child element of this MassProperties.
	Length *GetLength() const;
     
	//! Detach and delete Length child element tree from this MassProperties.
	void DeleteLength();

	//! Add Area child element to this MassProperties. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	Area *AddArea();
     
	//! Set Area child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetArea( Area *arg );
     
	//! Get Area child element of this MassProperties.
	Area *GetArea() const;
     
	//! Detach and delete Area child element tree from this MassProperties.
	void DeleteArea();

	//! Add Volume child element to this MassProperties. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	Volume *AddVolume();
     
	//! Set Volume child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetVolume( Volume *arg );
     
	//! Get Volume child element of this MassProperties.
	Volume *GetVolume() const;
     
	//! Detach and delete Volume child element tree from this MassProperties.
	void DeleteVolume();

	//! Add Density child element to this MassProperties. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	Density *AddDensity();
     
	//! Set Density child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetDensity( Density *arg );
     
	//! Get Density child element of this MassProperties.
	Density *GetDensity() const;
     
	//! Detach and delete Density child element tree from this MassProperties.
	void DeleteDensity();

	//! Add Mass child element to this MassProperties. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	Mass *AddMass();
     
	//! Set Mass child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetMass( Mass *arg );
     
	//! Get Mass child element of this MassProperties.
	Mass *GetMass() const;
     
	//! Detach and delete Mass child element tree from this MassProperties.
	void DeleteMass();

	//! Add CentreOfMass child element to this MassProperties. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	CentreOfMass *AddCentreOfMass();
     
	//! Set CentreOfMass child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetCentreOfMass( CentreOfMass *arg );
     
	//! Get CentreOfMass child element of this MassProperties.
	CentreOfMass *GetCentreOfMass() const;
     
	//! Detach and delete CentreOfMass child element tree from this MassProperties.
	void DeleteCentreOfMass();

	//! Add MomentsOfInertia child element to this MassProperties. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	MomentsOfInertia *AddMomentsOfInertia();
     
	//! Set MomentsOfInertia child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetMomentsOfInertia( MomentsOfInertia *arg );
     
	//! Get MomentsOfInertia child element of this MassProperties.
	MomentsOfInertia *GetMomentsOfInertia() const;
     
	//! Detach and delete MomentsOfInertia child element tree from this MassProperties.
	void DeleteMomentsOfInertia();

	//! Add ProductsOfInertia child element to this MassProperties. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	ProductsOfInertia *AddProductsOfInertia();
     
	//! Set ProductsOfInertia child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetProductsOfInertia( ProductsOfInertia *arg );
     
	//! Get ProductsOfInertia child element of this MassProperties.
	ProductsOfInertia *GetProductsOfInertia() const;
     
	//! Detach and delete ProductsOfInertia child element tree from this MassProperties.
	void DeleteProductsOfInertia();
 
// <PLMXML_UserCode type="functionHeaderMassProperties" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassMassProperties;


////////////////////////////////////////////////////////////////////////////////////
//! DocumentBase class
/*!
\verbatim

      This class corresponds to a top-level (root) element in a PLMXML file. 

      Attributes:

      author:        Author.
      date:          Date modified.
      time:          Time modified.
      language:      Language used, e.g. in comments.
      schemaVersion: Version of the schema this file was written for, e.g. "3.0".
      
      referenceSearchPaths:   A space-separated sequence of URIs or other strings used
                              by the Application to specify base URIs or other contexts
                              to enable relative URIs in the document to be resolved. The
                              URIs should be processed in sequence.
      languages:        A list of the ISO 639-1 codes for the languages,
                        separated by spaces, that the document contains.
      
\endverbatim
*/
class PLMXML60_API DocumentBase : public AttribOwner
{
public:
     
    //! Default constructor
    DocumentBase( );
     
    //! Constructs a DocumentBase with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    DocumentBase( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~DocumentBase();

private:

	//! Assignment operator
	DocumentBase& operator=( const DocumentBase& iSrc );

	//! Copy constructor
	DocumentBase( const DocumentBase& original );
     
public:

	//! Get Language of this DocumentBase
	plmxml_api::String GetLanguage() const;

	//! Set Language of this DocumentBase
	plmxml_api::Result SetLanguage( const plmxml_api::String &s );
	
	//! Check if Language is set
	plmxml_api::logical HasLanguage( ) const;
	
	//! Unset Language
	plmxml_api::Result UnsetLanguage( );

	//! Get Time of this DocumentBase
	plmxml_api::String GetTime() const;

	//! Set Time of this DocumentBase
	plmxml_api::Result SetTime( const plmxml_api::String &s );
	
	//! Check if Time is set
	plmxml_api::logical HasTime( ) const;
	
	//! Unset Time
	plmxml_api::Result UnsetTime( );

	//! Set SchemaVersion
	plmxml_api::Result SetSchemaVersion( double arg );

     //! Get SchemaVersion
	double GetSchemaVersion() const;

	//! Check if SchemaVersion is set
	plmxml_api::logical HasSchemaVersion() const;

	//! Unset SchemaVersion
	plmxml_api::Result UnsetSchemaVersion();

	//! Get Author of this DocumentBase
	plmxml_api::String GetAuthor() const;

	//! Set Author of this DocumentBase
	plmxml_api::Result SetAuthor( const plmxml_api::String &s );
	
	//! Check if Author is set
	plmxml_api::logical HasAuthor( ) const;
	
	//! Unset Author
	plmxml_api::Result UnsetAuthor( );

	//! Get ReferenceSearchPaths of this DocumentBase
	plmxml_api::String GetReferenceSearchPaths() const;

	//! Set ReferenceSearchPaths of this DocumentBase
	plmxml_api::Result SetReferenceSearchPaths( const plmxml_api::String &s );
	
	//! Check if ReferenceSearchPaths is set
	plmxml_api::logical HasReferenceSearchPaths( ) const;
	
	//! Unset ReferenceSearchPaths
	plmxml_api::Result UnsetReferenceSearchPaths( );

	//! Get Date of this DocumentBase
	plmxml_api::String GetDate() const;

	//! Set Date of this DocumentBase
	plmxml_api::Result SetDate( const plmxml_api::String &s );
	
	//! Check if Date is set
	plmxml_api::logical HasDate( ) const;
	
	//! Unset Date
	plmxml_api::Result UnsetDate( );

	//! Get Languages of this DocumentBase
	plmxml_api::String GetLanguages() const;

	//! Set Languages of this DocumentBase
	plmxml_api::Result SetLanguages( const plmxml_api::String &s );
	
	//! Check if Languages is set
	plmxml_api::logical HasLanguages( ) const;
	
	//! Unset Languages
	plmxml_api::Result UnsetLanguages( );
 
// <PLMXML_UserCode type="functionHeaderDocumentBase" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassDocumentBase;


////////////////////////////////////////////////////////////////////////////////////
//! Schema class
/*!
\verbatim

      This element contains or references an XML Schema used by the document it occurs
      in. The schema may be a full schema, or a 'skeleton' schema only provided to convey
      type hierarchy information.
      
      Attributes:
      
      schemaRef:         URI Reference to schema file
      
      Elements:
      
      The actual schema, in the xsd namespace.
      
\endverbatim
*/
class PLMXML60_API Schema : public IdObject
{
public:
     
    //! Default constructor
    Schema( );
     
    //! Constructs a Schema with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Schema( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Schema();

private:

	//! Assignment operator
	Schema& operator=( const Schema& iSrc );

	//! Copy constructor
	Schema( const Schema& original );
     
public:

	//! Get Schema URI as plmxml_api::String
	plmxml_api::String GetSchemaURI() const;

	//! Set Schema URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetSchemaURI( const plmxml_api::String& );
	
	//! Get the handle of Schema URI. Does not resolve the URI.
	plmxml_api::Result GetSchemaURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Schema URI. URI string is unchanged.
	plmxml_api::Result SetSchemaURI( const plmxml_api::Handle& );
	
	//! Resolve Schema URI and return an object (handle) it points to.
	plmxml_api::Result ResolveSchemaURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Schema URI. Clears URI string and handle.
	plmxml_api::Result DeleteSchemaURI();
	
	//! Check if Schema URI is set
	plmxml_api::logical HasSchemaURI( ) const;
	
 
// <PLMXML_UserCode type="functionHeaderSchema" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassSchema;


////////////////////////////////////////////////////////////////////////////////////
//! SchemaInfo class
/*!
\verbatim

      This element contains information about a PLMXML schema extension. It is embedded
      in the schema file inside an appinfo element.
      
      Attributes:
      
      version:       e.g. "4.1.1"
      status:        e.g. "development", "release".
      skeleton:      true if this is a schema skeleton, i.e. it just defines the type
                     hierarchy but does not specify any attributes or sub-elements.
      
\endverbatim
*/
class PLMXML60_API SchemaInfo : public plmxml_api::Object
{
public:
     
    //! Default constructor
    SchemaInfo( );
     
    //! Constructs a SchemaInfo with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    SchemaInfo( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~SchemaInfo();

private:

	//! Assignment operator
	SchemaInfo& operator=( const SchemaInfo& iSrc );

	//! Copy constructor
	SchemaInfo( const SchemaInfo& original );
     
public:

	//! Get Name of this SchemaInfo
	plmxml_api::String GetName() const;

	//! Set Name of this SchemaInfo
	plmxml_api::Result SetName( const plmxml_api::String &s );
	
	//! Check if Name is set
	plmxml_api::logical HasName( ) const;
	
	//! Unset Name
	plmxml_api::Result UnsetName( );

	//! Get Author of this SchemaInfo
	plmxml_api::String GetAuthor() const;

	//! Set Author of this SchemaInfo
	plmxml_api::Result SetAuthor( const plmxml_api::String &s );
	
	//! Check if Author is set
	plmxml_api::logical HasAuthor( ) const;
	
	//! Unset Author
	plmxml_api::Result UnsetAuthor( );

	//! Get Status of this SchemaInfo
	plmxml_api::String GetStatus() const;

	//! Set Status of this SchemaInfo
	plmxml_api::Result SetStatus( const plmxml_api::String &s );
	
	//! Check if Status is set
	plmxml_api::logical HasStatus( ) const;
	
	//! Unset Status
	plmxml_api::Result UnsetStatus( );

	//! Set Skeleton
	plmxml_api::Result SetSkeleton( plmxml_api::logical arg );

	//! Get Skeleton
	plmxml_api::logical GetSkeleton() const;

	//! Check if Skeleton is set
	plmxml_api::logical HasSkeleton() const;

	//! Unset Skeleton
	plmxml_api::Result UnsetSkeleton();

	//! Get Date of this SchemaInfo
	plmxml_api::String GetDate() const;

	//! Set Date of this SchemaInfo
	plmxml_api::Result SetDate( const plmxml_api::String &s );
	
	//! Check if Date is set
	plmxml_api::logical HasDate( ) const;
	
	//! Unset Date
	plmxml_api::Result UnsetDate( );

	//! Get Version of this SchemaInfo
	plmxml_api::String GetVersion() const;

	//! Set Version of this SchemaInfo
	plmxml_api::Result SetVersion( const plmxml_api::String &s );
	
	//! Check if Version is set
	plmxml_api::logical HasVersion( ) const;
	
	//! Unset Version
	plmxml_api::Result UnsetVersion( );
 
// <PLMXML_UserCode type="functionHeaderSchemaInfo" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassSchemaInfo;


////////////////////////////////////////////////////////////////////////////////////
//! LoadOptionPreferredRepresentation class
/*!
\verbatim

      This element defines an entry in the ordered list of representation names that should be 
      selected.

      Attributes:

      name:             The name of the representation.
      lightweight:      Whether the lightweight version of the representation
                        should be selected.
      
\endverbatim
*/
class PLMXML60_API LoadOptionPreferredRepresentation : public plmxml_api::Object
{
public:
     
    //! Default constructor
    LoadOptionPreferredRepresentation( );
     
    //! Constructs a LoadOptionPreferredRepresentation with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    LoadOptionPreferredRepresentation( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~LoadOptionPreferredRepresentation();

private:

	//! Assignment operator
	LoadOptionPreferredRepresentation& operator=( const LoadOptionPreferredRepresentation& iSrc );

	//! Copy constructor
	LoadOptionPreferredRepresentation( const LoadOptionPreferredRepresentation& original );
     
public:

	//! Get Name of this LoadOptionPreferredRepresentation
	plmxml_api::String GetName() const;

	//! Set Name of this LoadOptionPreferredRepresentation
	plmxml_api::Result SetName( const plmxml_api::String &s );
	
	//! Check if Name is set
	plmxml_api::logical HasName( ) const;
	
	//! Unset Name
	plmxml_api::Result UnsetName( );

	//! Set Lightweight
	plmxml_api::Result SetLightweight( plmxml_api::logical arg );

	//! Get Lightweight
	plmxml_api::logical GetLightweight() const;

	//! Check if Lightweight is set
	plmxml_api::logical HasLightweight() const;

	//! Unset Lightweight
	plmxml_api::Result UnsetLightweight();
 
// <PLMXML_UserCode type="functionHeaderLoadOptionPreferredRepresentation" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassLoadOptionPreferredRepresentation;


////////////////////////////////////////////////////////////////////////////////////
//! LoadOptionPreferredRepresentations class
/*!
\verbatim

      This element defines an ordered list of representation names that should be 
      selected. The order of appearance in the element defines the order 
      of usage. Only the first valid geometric configuration, encountered in the list,
      is applied to any one item.
      
      Also known as 'ReferenceSets' in NX.

      Elements:
       
      PreferredRepresentation: One element per configuration. (At least one).
      
\endverbatim
*/
class PLMXML60_API LoadOptionPreferredRepresentations : public IdObject
{
public:
     
    //! Default constructor
    LoadOptionPreferredRepresentations( );
     
    //! Constructs a LoadOptionPreferredRepresentations with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    LoadOptionPreferredRepresentations( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~LoadOptionPreferredRepresentations();

private:

	//! Assignment operator
	LoadOptionPreferredRepresentations& operator=( const LoadOptionPreferredRepresentations& iSrc );

	//! Copy constructor
	LoadOptionPreferredRepresentations( const LoadOptionPreferredRepresentations& original );
     
public:

	//! Set Scope
	plmxml_api::Result SetScope( const eLoadOptionPreferredRepresentationsScopeType& arg );

	//! Get Scope
	eLoadOptionPreferredRepresentationsScopeType GetScope() const;

	//! Add PreferredRepresentation child element to this LoadOptionPreferredRepresentations. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	LoadOptionPreferredRepresentation *AddPreferredRepresentation();
     
	//! Add 'arg' as PreferredRepresentation child element to this LoadOptionPreferredRepresentations.
	plmxml_api::Result AddPreferredRepresentation( LoadOptionPreferredRepresentation *arg );

	//! Detach and delete all PreferredRepresentation child elements.
	void DeletePreferredRepresentations();
     
	//! Get number of PreferredRepresentation child elements.
	int NumberOfPreferredRepresentations() const;
     
	//! Get i'th PreferredRepresentation child element.
	LoadOptionPreferredRepresentation *GetPreferredRepresentation( int i ) const;
     
	//! Get all PreferredRepresentation child element as an array
	void GetPreferredRepresentations( plmxml_api::Array<LoadOptionPreferredRepresentation*> &array ) const;
	     
	//! Detach and delete i'th PreferredRepresentation child element
	void DeletePreferredRepresentation( int i );
     
	//! Detach and delete 'arg' if it's one of the PreferredRepresentation child elements
	void DeletePreferredRepresentation( LoadOptionPreferredRepresentation *arg );
 
// <PLMXML_UserCode type="functionHeaderLoadOptionPreferredRepresentations" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassLoadOptionPreferredRepresentations;


////////////////////////////////////////////////////////////////////////////////////
//! LoadOptionSearchPath class
/*!
\verbatim

      This element defines a single search path.

      Attributes:
      
      path:       The search path
      recursive:  True if the subdirectories of the search directory must also be searched
      
\endverbatim
*/
class PLMXML60_API LoadOptionSearchPath : public plmxml_api::Object
{
public:
     
    //! Default constructor
    LoadOptionSearchPath( );
     
    //! Constructs a LoadOptionSearchPath with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    LoadOptionSearchPath( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~LoadOptionSearchPath();

private:

	//! Assignment operator
	LoadOptionSearchPath& operator=( const LoadOptionSearchPath& iSrc );

	//! Copy constructor
	LoadOptionSearchPath( const LoadOptionSearchPath& original );
     
public:

	//! Set Recursive
	plmxml_api::Result SetRecursive( plmxml_api::logical arg );

	//! Get Recursive
	plmxml_api::logical GetRecursive() const;

	//! Check if Recursive is set
	plmxml_api::logical HasRecursive() const;

	//! Unset Recursive
	plmxml_api::Result UnsetRecursive();

	//! Get Path of this LoadOptionSearchPath
	plmxml_api::String GetPath() const;

	//! Set Path of this LoadOptionSearchPath
	plmxml_api::Result SetPath( const plmxml_api::String &s );
	
	//! Check if Path is set
	plmxml_api::logical HasPath( ) const;
	
	//! Unset Path
	plmxml_api::Result UnsetPath( );
 
// <PLMXML_UserCode type="functionHeaderLoadOptionSearchPath" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassLoadOptionSearchPath;


////////////////////////////////////////////////////////////////////////////////////
//! LoadOptionSearchPaths class
/*!
\verbatim

      This element defines an ordered list of search.

      Elements:
       
      SearchPath:    One element per search path. (At least one).

      Attributes:      
      
      location:      This is an enum with values:
        local:       From the directory of the parent assembly.
        specified:   By using the explicit filenames stored in the loaded files  
                     (for example a CAD file for an assembly may contain 
                     explicit filenames for the CAD files of the sub-assemblies).
      
      
\endverbatim
*/
class PLMXML60_API LoadOptionSearchPaths : public IdObject
{
public:
     
    //! Default constructor
    LoadOptionSearchPaths( );
     
    //! Constructs a LoadOptionSearchPaths with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    LoadOptionSearchPaths( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~LoadOptionSearchPaths();

private:

	//! Assignment operator
	LoadOptionSearchPaths& operator=( const LoadOptionSearchPaths& iSrc );

	//! Copy constructor
	LoadOptionSearchPaths( const LoadOptionSearchPaths& original );
     
public:

	//! Set Location
	plmxml_api::Result SetLocation( const eLoadOptionSearchPathsLocationType& arg );

	//! Get Location
	eLoadOptionSearchPathsLocationType GetLocation() const;

	//! Add SearchPath child element to this LoadOptionSearchPaths. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	LoadOptionSearchPath *AddSearchPath();
     
	//! Add 'arg' as SearchPath child element to this LoadOptionSearchPaths.
	plmxml_api::Result AddSearchPath( LoadOptionSearchPath *arg );

	//! Detach and delete all SearchPath child elements.
	void DeleteSearchPaths();
     
	//! Get number of SearchPath child elements.
	int NumberOfSearchPaths() const;
     
	//! Get i'th SearchPath child element.
	LoadOptionSearchPath *GetSearchPath( int i ) const;
     
	//! Get all SearchPath child element as an array
	void GetSearchPaths( plmxml_api::Array<LoadOptionSearchPath*> &array ) const;
	     
	//! Detach and delete i'th SearchPath child element
	void DeleteSearchPath( int i );
     
	//! Detach and delete 'arg' if it's one of the SearchPath child elements
	void DeleteSearchPath( LoadOptionSearchPath *arg );
 
// <PLMXML_UserCode type="functionHeaderLoadOptionSearchPaths" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassLoadOptionSearchPaths;


////////////////////////////////////////////////////////////////////////////////////
//! LoadOptions class
/*!
\verbatim

      The purpose of this element is to specify global options or parameters
      which control the precise way in which an application loads a Product 
      Structure. 
      This is to ensure that different applications can load, and visualise, the
      same Product Structure in exactly the same way.
      There is at most one LoadOptions element in a PLM XML file.

      Elements:

      PreferredRepresentations: The list of named representations to be
                        selected.
      SearchPaths:      Optional list of search paths for data

      Attributes:

      mode:             Load items fully or partially.
      errorAction:      Action to take when a component fails to load.
      componentSet:     Load none, all or last-used of the subcomponents
      revision:         Load the specified or latest revision of the components
      componentSubstitution: Determines whether component substitution is permitted
      linkedComponents: Determines how related components are loaded.
      partFamilyComponents: Determines the action to take if a part family member is missing.
      variantRef:       References a multiple language version of variant. If
                        multiple language support is required, variantRef should
                        be used in addition to variant.
      lightweight:      Whether to load the lightweight type of the preferred
                        reference set.
      
\endverbatim
*/
class PLMXML60_API LoadOptions : public plmxml_api::Object
{
public:
     
    //! Default constructor
    LoadOptions( );
     
    //! Constructs a LoadOptions with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    LoadOptions( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~LoadOptions();

private:

	//! Assignment operator
	LoadOptions& operator=( const LoadOptions& iSrc );

	//! Copy constructor
	LoadOptions( const LoadOptions& original );
     
public:

	//! Get Variant of this LoadOptions
	plmxml_api::String GetVariant() const;

	//! Set Variant of this LoadOptions
	plmxml_api::Result SetVariant( const plmxml_api::String &s );
	
	//! Check if Variant is set
	plmxml_api::logical HasVariant( ) const;
	
	//! Unset Variant
	plmxml_api::Result UnsetVariant( );

	//! Set LinkedComponents
	plmxml_api::Result SetLinkedComponents( const eLoadOptionLinkedComponentsType& arg );

	//! Get LinkedComponents
	eLoadOptionLinkedComponentsType GetLinkedComponents() const;

	//! Set ComponentSubstitution
	plmxml_api::Result SetComponentSubstitution( plmxml_api::logical arg );

	//! Get ComponentSubstitution
	plmxml_api::logical GetComponentSubstitution() const;

	//! Check if ComponentSubstitution is set
	plmxml_api::logical HasComponentSubstitution() const;

	//! Unset ComponentSubstitution
	plmxml_api::Result UnsetComponentSubstitution();

	//! Set Lightweight
	plmxml_api::Result SetLightweight( plmxml_api::logical arg );

	//! Get Lightweight
	plmxml_api::logical GetLightweight() const;

	//! Check if Lightweight is set
	plmxml_api::logical HasLightweight() const;

	//! Unset Lightweight
	plmxml_api::Result UnsetLightweight();

	//! Set PartFamilyComponents
	plmxml_api::Result SetPartFamilyComponents( const eLoadOptionPartFamilyComponentsType& arg );

	//! Get PartFamilyComponents
	eLoadOptionPartFamilyComponentsType GetPartFamilyComponents() const;

	//! Set Revision
	plmxml_api::Result SetRevision( const eLoadOptionRevisionType& arg );

	//! Get Revision
	eLoadOptionRevisionType GetRevision() const;

	//! Set Mode
	plmxml_api::Result SetMode( const eLoadOptionModeType& arg );

	//! Get Mode
	eLoadOptionModeType GetMode() const;

	//! Set ComponentSet
	plmxml_api::Result SetComponentSet( const eLoadOptionComponentSetType& arg );

	//! Get ComponentSet
	eLoadOptionComponentSetType GetComponentSet() const;

	//! Set ErrorAction
	plmxml_api::Result SetErrorAction( const eLoadOptionErrorActionType& arg );

	//! Get ErrorAction
	eLoadOptionErrorActionType GetErrorAction() const;

	//! Get Variant URI as plmxml_api::String
	plmxml_api::String GetVariantURI() const;

	//! Set Variant URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetVariantURI( const plmxml_api::String& );
	
	//! Get the handle of Variant URI. Does not resolve the URI.
	plmxml_api::Result GetVariantURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Variant URI. URI string is unchanged.
	plmxml_api::Result SetVariantURI( const plmxml_api::Handle& );
	
	//! Resolve Variant URI and return an object (handle) it points to.
	plmxml_api::Result ResolveVariantURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Variant URI. Clears URI string and handle.
	plmxml_api::Result DeleteVariantURI();
	
	//! Check if Variant URI is set
	plmxml_api::logical HasVariantURI( ) const;
	

	//! Add PreferredRepresentations child element to this LoadOptions. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	LoadOptionPreferredRepresentations *AddPreferredRepresentations();
     
	//! Set PreferredRepresentations child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetPreferredRepresentations( LoadOptionPreferredRepresentations *arg );
     
	//! Get PreferredRepresentations child element of this LoadOptions.
	LoadOptionPreferredRepresentations *GetPreferredRepresentations() const;
     
	//! Detach and delete PreferredRepresentations child element tree from this LoadOptions.
	void DeletePreferredRepresentations();

	//! Add SearchPaths child element to this LoadOptions. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	LoadOptionSearchPaths *AddSearchPaths();
     
	//! Set SearchPaths child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetSearchPaths( LoadOptionSearchPaths *arg );
     
	//! Get SearchPaths child element of this LoadOptions.
	LoadOptionSearchPaths *GetSearchPaths() const;
     
	//! Detach and delete SearchPaths child element tree from this LoadOptions.
	void DeleteSearchPaths();
 
// <PLMXML_UserCode type="functionHeaderLoadOptions" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassLoadOptions;


////////////////////////////////////////////////////////////////////////////////////
//! Application class
/*!
\verbatim

      This element contains information to identify a particular application. 
      
      Attributes:
    
      name:       Name of the application. 
                          
      version:    The version of the application. No specific format is defined for this 
                  and in general it will depend on the value of the 'name' attribute.      
      
\endverbatim
*/
class PLMXML60_API Application : public IdObject
{
public:
     
    //! Default constructor
    Application( );
     
    //! Constructs a Application with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Application( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Application();

private:

	//! Assignment operator
	Application& operator=( const Application& iSrc );

	//! Copy constructor
	Application( const Application& original );
     
public:

	//! Get Version of this Application
	plmxml_api::String GetVersion() const;

	//! Set Version of this Application
	plmxml_api::Result SetVersion( const plmxml_api::String &s );
	
	//! Check if Version is set
	plmxml_api::logical HasVersion( ) const;
	
	//! Unset Version
	plmxml_api::Result UnsetVersion( );

	//! Get Name of this Application
	plmxml_api::String GetName() const;

	//! Set Name of this Application
	plmxml_api::Result SetName( const plmxml_api::String &s );
	
	//! Check if Name is set
	plmxml_api::logical HasName( ) const;
	
	//! Unset Name
	plmxml_api::Result UnsetName( );
 
// <PLMXML_UserCode type="functionHeaderApplication" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassApplication;


////////////////////////////////////////////////////////////////////////////////////
//! DocumentHeader class
/*!
\verbatim

      This element contains header information for the PLMXML document. 
      
      Attributes:
    
      traverseRootRefs:   a collection of elements to start from, if traversing
                          the PLM XML elements according to some rule.
      transferContext:    a string which can be used to indicate the context in
                          which this PLMXML file is being transferred.
      
      Elements:
      
      Schema:             a collection of schema elements.
      LoadOptions:        Global options for the loading of the associated document.
      Application:        Defines the set of applications (or components) that were used to 
                          author this document.
      
\endverbatim
*/
class PLMXML60_API DocumentHeader : public IdObject
{
public:
     
    //! Default constructor
    DocumentHeader( );
     
    //! Constructs a DocumentHeader with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    DocumentHeader( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~DocumentHeader();

private:

	//! Assignment operator
	DocumentHeader& operator=( const DocumentHeader& iSrc );

	//! Copy constructor
	DocumentHeader( const DocumentHeader& original );
     
public:

	//! Get number of URIs in TraverseRoot
	int NumberOfTraverseRootURIs() const;

	//! Get i'th URI in TraverseRoot
	plmxml_api::String GetTraverseRootURI( int i ) const;

	//! Add a URI to TraverseRoot array. Call ResolveTraverseRootURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddTraverseRootURI( const plmxml_api::String& u );

	//! Set i'th URI in TraverseRoot array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetTraverseRootURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of TraverseRoot URI. Does not resolve the URI.
	plmxml_api::Result GetTraverseRootURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to TraverseRoot array.
	plmxml_api::Result AddTraverseRootURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in TraverseRoot array to point to 'handle'.
	plmxml_api::Result SetTraverseRootURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in TraverseRoot points to.
	plmxml_api::Result ResolveTraverseRootURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from TraverseRoot array.
	plmxml_api::Result DeleteTraverseRootURI( int i );

	//! Remove all URIs from TraverseRoot array.
	plmxml_api::Result DeleteTraverseRootURIs( );
	
	//! Check if TraverseRoot is set
	plmxml_api::logical HasTraverseRootURIs( ) const;

	//! Get TransferContext of this DocumentHeader
	plmxml_api::String GetTransferContext() const;

	//! Set TransferContext of this DocumentHeader
	plmxml_api::Result SetTransferContext( const plmxml_api::String &s );
	
	//! Check if TransferContext is set
	plmxml_api::logical HasTransferContext( ) const;
	
	//! Unset TransferContext
	plmxml_api::Result UnsetTransferContext( );

	//! Add Schema child element to this DocumentHeader. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Schema *AddSchema();
     
	//! Add 'arg' as Schema child element to this DocumentHeader.
	plmxml_api::Result AddSchema( Schema *arg );

	//! Detach and delete all Schema child elements.
	void DeleteSchemas();
     
	//! Get number of Schema child elements.
	int NumberOfSchemas() const;
     
	//! Get i'th Schema child element.
	Schema *GetSchema( int i ) const;
     
	//! Get all Schema child element as an array
	void GetSchemas( plmxml_api::Array<Schema*> &array ) const;
	     
	//! Detach and delete i'th Schema child element
	void DeleteSchema( int i );
     
	//! Detach and delete 'arg' if it's one of the Schema child elements
	void DeleteSchema( Schema *arg );

	//! Add LoadOptions child element to this DocumentHeader. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	LoadOptions *AddLoadOptions();
     
	//! Set LoadOptions child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetLoadOptions( LoadOptions *arg );
     
	//! Get LoadOptions child element of this DocumentHeader.
	LoadOptions *GetLoadOptions() const;
     
	//! Detach and delete LoadOptions child element tree from this DocumentHeader.
	void DeleteLoadOptions();

	//! Add Application child element to this DocumentHeader. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Application *AddApplication();
     
	//! Add 'arg' as Application child element to this DocumentHeader.
	plmxml_api::Result AddApplication( Application *arg );

	//! Detach and delete all Application child elements.
	void DeleteApplications();
     
	//! Get number of Application child elements.
	int NumberOfApplications() const;
     
	//! Get i'th Application child element.
	Application *GetApplication( int i ) const;
     
	//! Get all Application child element as an array
	void GetApplications( plmxml_api::Array<Application*> &array ) const;
	     
	//! Detach and delete i'th Application child element
	void DeleteApplication( int i );
     
	//! Detach and delete 'arg' if it's one of the Application child elements
	void DeleteApplication( Application *arg );
 
// <PLMXML_UserCode type="functionHeaderDocumentHeader" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassDocumentHeader;


//! Forward class declarations
class Structure;
class StructureRevision;
class MultipleLanguageText;

////////////////////////////////////////////////////////////////////////////////////
//! Document class
/*!
\verbatim

      This defines the type of the outermost element in a PLMXML file.
      
      Elements:
      
      Header:         Document header
      AttribOwner:    Any elements derived from AttribOwner are allowed under
                      this element, except as described below.
      ViewControl:    Represents a camera or view point in the Motion schema,
                      where a ViewControl does not already exist under a ProductDef.
      Text:           Represents text in multiple languages.
      
\endverbatim
*/
class PLMXML60_API Document : public DocumentBase
{
public:
     
    //! Default constructor
    Document( );
     
    //! Constructs a Document with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Document( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Document();

private:

	//! Assignment operator
	Document& operator=( const Document& iSrc );

	//! Copy constructor
	Document( const Document& original );
     
public:

	//! Add ProductDef child element to this Document. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	ProductDef *AddProductDef();
     
	//! Add 'arg' as ProductDef child element to this Document.
	plmxml_api::Result AddProductDef( ProductDef *arg );

	//! Detach and delete all ProductDef child elements.
	void DeleteProductDefs();
     
	//! Get number of ProductDef child elements.
	int NumberOfProductDefs() const;
     
	//! Get i'th ProductDef child element.
	ProductDef *GetProductDef( int i ) const;
     
	//! Get all ProductDef child element as an array
	void GetProductDefs( plmxml_api::Array<ProductDef*> &array ) const;
	     
	//! Detach and delete i'th ProductDef child element
	void DeleteProductDef( int i );
     
	//! Detach and delete 'arg' if it's one of the ProductDef child elements
	void DeleteProductDef( ProductDef *arg );

	//! Add ConstructionGeometry child element to this Document. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	ConstructionGeometry *AddConstructionGeometry();
     
	//! Add 'arg' as ConstructionGeometry child element to this Document.
	plmxml_api::Result AddConstructionGeometry( ConstructionGeometry *arg );

	//! Detach and delete all ConstructionGeometry child elements.
	void DeleteConstructionGeometries();
     
	//! Get number of ConstructionGeometry child elements.
	int NumberOfConstructionGeometries() const;
     
	//! Get i'th ConstructionGeometry child element.
	ConstructionGeometry *GetConstructionGeometry( int i ) const;
     
	//! Get all ConstructionGeometry child element as an array
	void GetConstructionGeometries( plmxml_api::Array<ConstructionGeometry*> &array ) const;
	     
	//! Detach and delete i'th ConstructionGeometry child element
	void DeleteConstructionGeometry( int i );
     
	//! Detach and delete 'arg' if it's one of the ConstructionGeometry child elements
	void DeleteConstructionGeometry( ConstructionGeometry *arg );

	//! Add Representation child element to this Document. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Representation *AddRepresentation();
     
	//! Add 'arg' as Representation child element to this Document.
	plmxml_api::Result AddRepresentation( Representation *arg );

	//! Detach and delete all Representation child elements.
	void DeleteRepresentations();
     
	//! Get number of Representation child elements.
	int NumberOfRepresentations() const;
     
	//! Get i'th Representation child element.
	Representation *GetRepresentation( int i ) const;
     
	//! Get all Representation child element as an array
	void GetRepresentations( plmxml_api::Array<Representation*> &array ) const;
	     
	//! Detach and delete i'th Representation child element
	void DeleteRepresentation( int i );
     
	//! Detach and delete 'arg' if it's one of the Representation child elements
	void DeleteRepresentation( Representation *arg );

	//! Add StructureDef child element to this Document. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	StructureDef *AddStructureDef();
     
	//! Add 'arg' as StructureDef child element to this Document.
	plmxml_api::Result AddStructureDef( StructureDef *arg );

	//! Detach and delete all StructureDef child elements.
	void DeleteStructureDefs();
     
	//! Get number of StructureDef child elements.
	int NumberOfStructureDefs() const;
     
	//! Get i'th StructureDef child element.
	StructureDef *GetStructureDef( int i ) const;
     
	//! Get all StructureDef child element as an array
	void GetStructureDefs( plmxml_api::Array<StructureDef*> &array ) const;
	     
	//! Detach and delete i'th StructureDef child element
	void DeleteStructureDef( int i );
     
	//! Detach and delete 'arg' if it's one of the StructureDef child elements
	void DeleteStructureDef( StructureDef *arg );

	//! Add Structure child element to this Document. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Structure *AddStructure();
     
	//! Add 'arg' as Structure child element to this Document.
	plmxml_api::Result AddStructure( Structure *arg );

	//! Detach and delete all Structure child elements.
	void DeleteStructures();
     
	//! Get number of Structure child elements.
	int NumberOfStructures() const;
     
	//! Get i'th Structure child element.
	Structure *GetStructure( int i ) const;
     
	//! Get all Structure child element as an array
	void GetStructures( plmxml_api::Array<Structure*> &array ) const;
	     
	//! Detach and delete i'th Structure child element
	void DeleteStructure( int i );
     
	//! Detach and delete 'arg' if it's one of the Structure child elements
	void DeleteStructure( Structure *arg );

	//! Add StructureRevision child element to this Document. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	StructureRevision *AddStructureRevision();
     
	//! Add 'arg' as StructureRevision child element to this Document.
	plmxml_api::Result AddStructureRevision( StructureRevision *arg );

	//! Detach and delete all StructureRevision child elements.
	void DeleteStructureRevisions();
     
	//! Get number of StructureRevision child elements.
	int NumberOfStructureRevisions() const;
     
	//! Get i'th StructureRevision child element.
	StructureRevision *GetStructureRevision( int i ) const;
     
	//! Get all StructureRevision child element as an array
	void GetStructureRevisions( plmxml_api::Array<StructureRevision*> &array ) const;
	     
	//! Detach and delete i'th StructureRevision child element
	void DeleteStructureRevision( int i );
     
	//! Detach and delete 'arg' if it's one of the StructureRevision child elements
	void DeleteStructureRevision( StructureRevision *arg );

	//! Add Header child element to this Document. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	DocumentHeader *AddHeader();
     
	//! Add 'arg' as Header child element to this Document.
	plmxml_api::Result AddHeader( DocumentHeader *arg );

	//! Detach and delete all Header child elements.
	void DeleteHeaders();
     
	//! Get number of Header child elements.
	int NumberOfHeaders() const;
     
	//! Get i'th Header child element.
	DocumentHeader *GetHeader( int i ) const;
     
	//! Get all Header child element as an array
	void GetHeaders( plmxml_api::Array<DocumentHeader*> &array ) const;
	     
	//! Detach and delete i'th Header child element
	void DeleteHeader( int i );
     
	//! Detach and delete 'arg' if it's one of the Header child elements
	void DeleteHeader( DocumentHeader *arg );

	//! Add AttribOwner child element to this Document. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	AttribOwner *AddAttribOwner();
     
	//! Add 'arg' as AttribOwner child element to this Document.
	plmxml_api::Result AddAttribOwner( AttribOwner *arg );

	//! Detach and delete all AttribOwner child elements.
	void DeleteAttribOwners();
     
	//! Get number of AttribOwner child elements.
	int NumberOfAttribOwners() const;
     
	//! Get i'th AttribOwner child element.
	AttribOwner *GetAttribOwner( int i ) const;
     
	//! Get all AttribOwner child element as an array
	void GetAttribOwners( plmxml_api::Array<AttribOwner*> &array ) const;
	     
	//! Detach and delete i'th AttribOwner child element
	void DeleteAttribOwner( int i );
     
	//! Detach and delete 'arg' if it's one of the AttribOwner child elements
	void DeleteAttribOwner( AttribOwner *arg );

	//! Add ViewControl child element to this Document. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	ViewControl *AddViewControl();
     
	//! Add 'arg' as ViewControl child element to this Document.
	plmxml_api::Result AddViewControl( ViewControl *arg );

	//! Detach and delete all ViewControl child elements.
	void DeleteViewControls();
     
	//! Get number of ViewControl child elements.
	int NumberOfViewControls() const;
     
	//! Get i'th ViewControl child element.
	ViewControl *GetViewControl( int i ) const;
     
	//! Get all ViewControl child element as an array
	void GetViewControls( plmxml_api::Array<ViewControl*> &array ) const;
	     
	//! Detach and delete i'th ViewControl child element
	void DeleteViewControl( int i );
     
	//! Detach and delete 'arg' if it's one of the ViewControl child elements
	void DeleteViewControl( ViewControl *arg );

	//! Add Text child element to this Document. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	MultipleLanguageText *AddText();
     
	//! Add 'arg' as Text child element to this Document.
	plmxml_api::Result AddText( MultipleLanguageText *arg );

	//! Detach and delete all Text child elements.
	void DeleteTexts();
     
	//! Get number of Text child elements.
	int NumberOfTexts() const;
     
	//! Get i'th Text child element.
	MultipleLanguageText *GetText( int i ) const;
     
	//! Get all Text child element as an array
	void GetTexts( plmxml_api::Array<MultipleLanguageText*> &array ) const;
	     
	//! Detach and delete i'th Text child element
	void DeleteText( int i );
     
	//! Detach and delete 'arg' if it's one of the Text child elements
	void DeleteText( MultipleLanguageText *arg );
 
// <PLMXML_UserCode type="functionHeaderDocument" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassDocument;


//! Forward class declarations
class PropertyGroup;
class DeterminedPropertyGroup;

////////////////////////////////////////////////////////////////////////////////////
//! Structure class
/*!
\verbatim

      This is a base type for objects which can be revisioned and support hierarchical, 
      configurable structure.

      Attributes:

      catalogueId: The identifier of the Structure, unique in some context, e.g. an 
                   Organisation.

      optionRefs:  Options. Each Option gives the full set of allowed values for this
                   product. ProductRevisions may specify an Option with a sub-set of
                   allowed values.
      propertyRefs: reference to Properties
      monolithic:  Whether the structure node is treated without sub-structure.

      Elements:

      PropertyGroup
      DeterminedPropertyGroup: The Marker Properties determined by a specific
                        method.
      
\endverbatim
*/
class PLMXML60_API Structure : public Managed
{
public:
     
    //! Default constructor
    Structure( );
     
    //! Constructs a Structure with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Structure( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Structure();

private:

	//! Assignment operator
	Structure& operator=( const Structure& iSrc );

	//! Copy constructor
	Structure( const Structure& original );
     
public:

	//! Get number of URIs in Option
	int NumberOfOptionURIs() const;

	//! Get i'th URI in Option
	plmxml_api::String GetOptionURI( int i ) const;

	//! Add a URI to Option array. Call ResolveOptionURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddOptionURI( const plmxml_api::String& u );

	//! Set i'th URI in Option array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetOptionURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Option URI. Does not resolve the URI.
	plmxml_api::Result GetOptionURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Option array.
	plmxml_api::Result AddOptionURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Option array to point to 'handle'.
	plmxml_api::Result SetOptionURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Option points to.
	plmxml_api::Result ResolveOptionURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Option array.
	plmxml_api::Result DeleteOptionURI( int i );

	//! Remove all URIs from Option array.
	plmxml_api::Result DeleteOptionURIs( );
	
	//! Check if Option is set
	plmxml_api::logical HasOptionURIs( ) const;

	//! Get number of URIs in Property
	int NumberOfPropertyURIs() const;

	//! Get i'th URI in Property
	plmxml_api::String GetPropertyURI( int i ) const;

	//! Add a URI to Property array. Call ResolvePropertyURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddPropertyURI( const plmxml_api::String& u );

	//! Set i'th URI in Property array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetPropertyURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Property URI. Does not resolve the URI.
	plmxml_api::Result GetPropertyURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Property array.
	plmxml_api::Result AddPropertyURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Property array to point to 'handle'.
	plmxml_api::Result SetPropertyURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Property points to.
	plmxml_api::Result ResolvePropertyURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Property array.
	plmxml_api::Result DeletePropertyURI( int i );

	//! Remove all URIs from Property array.
	plmxml_api::Result DeletePropertyURIs( );
	
	//! Check if Property is set
	plmxml_api::logical HasPropertyURIs( ) const;

	//! Get CatalogueId of this Structure
	plmxml_api::String GetCatalogueId() const;

	//! Set CatalogueId of this Structure
	plmxml_api::Result SetCatalogueId( const plmxml_api::String &s );
	
	//! Check if CatalogueId is set
	plmxml_api::logical HasCatalogueId( ) const;
	
	//! Unset CatalogueId
	plmxml_api::Result UnsetCatalogueId( );

	//! Set Monolithic
	plmxml_api::Result SetMonolithic( plmxml_api::logical arg );

	//! Get Monolithic
	plmxml_api::logical GetMonolithic() const;

	//! Check if Monolithic is set
	plmxml_api::logical HasMonolithic() const;

	//! Unset Monolithic
	plmxml_api::Result UnsetMonolithic();

	//! Add PropertyGroup child element to this Structure. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	PropertyGroup *AddPropertyGroup();
     
	//! Set PropertyGroup child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetPropertyGroup( PropertyGroup *arg );
     
	//! Get PropertyGroup child element of this Structure.
	PropertyGroup *GetPropertyGroup() const;
     
	//! Detach and delete PropertyGroup child element tree from this Structure.
	void DeletePropertyGroup();

	//! Add DeterminedPropertyGroup child element to this Structure. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	DeterminedPropertyGroup *AddDeterminedPropertyGroup();
     
	//! Set DeterminedPropertyGroup child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetDeterminedPropertyGroup( DeterminedPropertyGroup *arg );
     
	//! Get DeterminedPropertyGroup child element of this Structure.
	DeterminedPropertyGroup *GetDeterminedPropertyGroup() const;
     
	//! Detach and delete DeterminedPropertyGroup child element tree from this Structure.
	void DeleteDeterminedPropertyGroup();
 
// <PLMXML_UserCode type="functionHeaderStructure" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassStructure;


//! Forward class declarations
class VariantDefault;
class VariantRuleCheck;
class PropertyGroup;
class DeterminedPropertyGroup;

////////////////////////////////////////////////////////////////////////////////////
//! StructureRevision class
/*!
\verbatim

      This is a revision of a Structure.

      Attributes:

      revision:      Identifies the revision. Could be numeric, alphabetic, or a mixture.
      version:       Gives the current 'version' of this revision. The version captures
                     changes en route to the next revision of this Product.
      masterRef:     Reference to the Structure of which this is a version.
      optionRefs:    Options. Each Option gives the set of allowed values for this
                     StructureRevision.
      instanceRefs:  Reference to elements derived from Instance, which define the
                     hierarchical structure. Both StructureRevision and
                     StructureRevisionView can have instanceRefs. In the case of
                     StructureRevision, the element is then representing a 'default' or
                     'unspecified' view. These Instances should not be GDEInstances.

      gdeInstanceRefs: Referenced GDEInstance or GDEInstanceGroup elements.

      simplifiedRepRefs: If an assembly has replacement representations (that is, in case
                     the assembly structure is not important in some context, then the
                     replacement representations can be used).
      propertyRefs:  reference to Properties

      Elements:

      VariantDefault
      VariantRuleCheck
      PropertyGroup
      DeterminedPropertyGroup: The Properties determined by a specific method.
      
\endverbatim
*/
class PLMXML60_API StructureRevision : public Managed
{
public:
     
    //! Default constructor
    StructureRevision( );
     
    //! Constructs a StructureRevision with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    StructureRevision( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~StructureRevision();

private:

	//! Assignment operator
	StructureRevision& operator=( const StructureRevision& iSrc );

	//! Copy constructor
	StructureRevision( const StructureRevision& original );
     
public:

	//! Get number of URIs in Instance
	int NumberOfInstanceURIs() const;

	//! Get i'th URI in Instance
	plmxml_api::String GetInstanceURI( int i ) const;

	//! Add a URI to Instance array. Call ResolveInstanceURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddInstanceURI( const plmxml_api::String& u );

	//! Set i'th URI in Instance array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetInstanceURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Instance URI. Does not resolve the URI.
	plmxml_api::Result GetInstanceURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Instance array.
	plmxml_api::Result AddInstanceURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Instance array to point to 'handle'.
	plmxml_api::Result SetInstanceURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Instance points to.
	plmxml_api::Result ResolveInstanceURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Instance array.
	plmxml_api::Result DeleteInstanceURI( int i );

	//! Remove all URIs from Instance array.
	plmxml_api::Result DeleteInstanceURIs( );
	
	//! Check if Instance is set
	plmxml_api::logical HasInstanceURIs( ) const;

	//! Get number of URIs in Option
	int NumberOfOptionURIs() const;

	//! Get i'th URI in Option
	plmxml_api::String GetOptionURI( int i ) const;

	//! Add a URI to Option array. Call ResolveOptionURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddOptionURI( const plmxml_api::String& u );

	//! Set i'th URI in Option array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetOptionURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Option URI. Does not resolve the URI.
	plmxml_api::Result GetOptionURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Option array.
	plmxml_api::Result AddOptionURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Option array to point to 'handle'.
	plmxml_api::Result SetOptionURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Option points to.
	plmxml_api::Result ResolveOptionURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Option array.
	plmxml_api::Result DeleteOptionURI( int i );

	//! Remove all URIs from Option array.
	plmxml_api::Result DeleteOptionURIs( );
	
	//! Check if Option is set
	plmxml_api::logical HasOptionURIs( ) const;

	//! Get Master URI as plmxml_api::String
	plmxml_api::String GetMasterURI() const;

	//! Set Master URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetMasterURI( const plmxml_api::String& );
	
	//! Get the handle of Master URI. Does not resolve the URI.
	plmxml_api::Result GetMasterURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Master URI. URI string is unchanged.
	plmxml_api::Result SetMasterURI( const plmxml_api::Handle& );
	
	//! Resolve Master URI and return an object (handle) it points to.
	plmxml_api::Result ResolveMasterURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Master URI. Clears URI string and handle.
	plmxml_api::Result DeleteMasterURI();
	
	//! Check if Master URI is set
	plmxml_api::logical HasMasterURI( ) const;
	

	//! Get Revision of this StructureRevision
	plmxml_api::String GetRevision() const;

	//! Set Revision of this StructureRevision
	plmxml_api::Result SetRevision( const plmxml_api::String &s );
	
	//! Check if Revision is set
	plmxml_api::logical HasRevision( ) const;
	
	//! Unset Revision
	plmxml_api::Result UnsetRevision( );

	//! Get number of URIs in GdeInstance
	int NumberOfGdeInstanceURIs() const;

	//! Get i'th URI in GdeInstance
	plmxml_api::String GetGdeInstanceURI( int i ) const;

	//! Add a URI to GdeInstance array. Call ResolveGdeInstanceURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddGdeInstanceURI( const plmxml_api::String& u );

	//! Set i'th URI in GdeInstance array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetGdeInstanceURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of GdeInstance URI. Does not resolve the URI.
	plmxml_api::Result GetGdeInstanceURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to GdeInstance array.
	plmxml_api::Result AddGdeInstanceURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in GdeInstance array to point to 'handle'.
	plmxml_api::Result SetGdeInstanceURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in GdeInstance points to.
	plmxml_api::Result ResolveGdeInstanceURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from GdeInstance array.
	plmxml_api::Result DeleteGdeInstanceURI( int i );

	//! Remove all URIs from GdeInstance array.
	plmxml_api::Result DeleteGdeInstanceURIs( );
	
	//! Check if GdeInstance is set
	plmxml_api::logical HasGdeInstanceURIs( ) const;

	//! Get number of URIs in SimplifiedRep
	int NumberOfSimplifiedRepURIs() const;

	//! Get i'th URI in SimplifiedRep
	plmxml_api::String GetSimplifiedRepURI( int i ) const;

	//! Add a URI to SimplifiedRep array. Call ResolveSimplifiedRepURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddSimplifiedRepURI( const plmxml_api::String& u );

	//! Set i'th URI in SimplifiedRep array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetSimplifiedRepURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of SimplifiedRep URI. Does not resolve the URI.
	plmxml_api::Result GetSimplifiedRepURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to SimplifiedRep array.
	plmxml_api::Result AddSimplifiedRepURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in SimplifiedRep array to point to 'handle'.
	plmxml_api::Result SetSimplifiedRepURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in SimplifiedRep points to.
	plmxml_api::Result ResolveSimplifiedRepURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from SimplifiedRep array.
	plmxml_api::Result DeleteSimplifiedRepURI( int i );

	//! Remove all URIs from SimplifiedRep array.
	plmxml_api::Result DeleteSimplifiedRepURIs( );
	
	//! Check if SimplifiedRep is set
	plmxml_api::logical HasSimplifiedRepURIs( ) const;

	//! Get number of URIs in Property
	int NumberOfPropertyURIs() const;

	//! Get i'th URI in Property
	plmxml_api::String GetPropertyURI( int i ) const;

	//! Add a URI to Property array. Call ResolvePropertyURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddPropertyURI( const plmxml_api::String& u );

	//! Set i'th URI in Property array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetPropertyURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Property URI. Does not resolve the URI.
	plmxml_api::Result GetPropertyURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Property array.
	plmxml_api::Result AddPropertyURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Property array to point to 'handle'.
	plmxml_api::Result SetPropertyURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Property points to.
	plmxml_api::Result ResolvePropertyURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Property array.
	plmxml_api::Result DeletePropertyURI( int i );

	//! Remove all URIs from Property array.
	plmxml_api::Result DeletePropertyURIs( );
	
	//! Check if Property is set
	plmxml_api::logical HasPropertyURIs( ) const;

	//! Set Version
	plmxml_api::Result SetVersion( int arg );
     
	//! Get Version
	int GetVersion() const;
     
	//! Check if Version is set
	plmxml_api::logical HasVersion() const;
     
	//! Unset Version
	plmxml_api::Result UnsetVersion();

	//! Add VariantDefault child element to this StructureRevision. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	VariantDefault *AddVariantDefault();
     
	//! Add 'arg' as VariantDefault child element to this StructureRevision.
	plmxml_api::Result AddVariantDefault( VariantDefault *arg );

	//! Detach and delete all VariantDefault child elements.
	void DeleteVariantDefaults();
     
	//! Get number of VariantDefault child elements.
	int NumberOfVariantDefaults() const;
     
	//! Get i'th VariantDefault child element.
	VariantDefault *GetVariantDefault( int i ) const;
     
	//! Get all VariantDefault child element as an array
	void GetVariantDefaults( plmxml_api::Array<VariantDefault*> &array ) const;
	     
	//! Detach and delete i'th VariantDefault child element
	void DeleteVariantDefault( int i );
     
	//! Detach and delete 'arg' if it's one of the VariantDefault child elements
	void DeleteVariantDefault( VariantDefault *arg );

	//! Add VariantRuleCheck child element to this StructureRevision. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	VariantRuleCheck *AddVariantRuleCheck();
     
	//! Add 'arg' as VariantRuleCheck child element to this StructureRevision.
	plmxml_api::Result AddVariantRuleCheck( VariantRuleCheck *arg );

	//! Detach and delete all VariantRuleCheck child elements.
	void DeleteVariantRuleChecks();
     
	//! Get number of VariantRuleCheck child elements.
	int NumberOfVariantRuleChecks() const;
     
	//! Get i'th VariantRuleCheck child element.
	VariantRuleCheck *GetVariantRuleCheck( int i ) const;
     
	//! Get all VariantRuleCheck child element as an array
	void GetVariantRuleChecks( plmxml_api::Array<VariantRuleCheck*> &array ) const;
	     
	//! Detach and delete i'th VariantRuleCheck child element
	void DeleteVariantRuleCheck( int i );
     
	//! Detach and delete 'arg' if it's one of the VariantRuleCheck child elements
	void DeleteVariantRuleCheck( VariantRuleCheck *arg );

	//! Add PropertyGroup child element to this StructureRevision. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	PropertyGroup *AddPropertyGroup();
     
	//! Add 'arg' as PropertyGroup child element to this StructureRevision.
	plmxml_api::Result AddPropertyGroup( PropertyGroup *arg );

	//! Detach and delete all PropertyGroup child elements.
	void DeletePropertyGroups();
     
	//! Get number of PropertyGroup child elements.
	int NumberOfPropertyGroups() const;
     
	//! Get i'th PropertyGroup child element.
	PropertyGroup *GetPropertyGroup( int i ) const;
     
	//! Get all PropertyGroup child element as an array
	void GetPropertyGroups( plmxml_api::Array<PropertyGroup*> &array ) const;
	     
	//! Detach and delete i'th PropertyGroup child element
	void DeletePropertyGroup( int i );
     
	//! Detach and delete 'arg' if it's one of the PropertyGroup child elements
	void DeletePropertyGroup( PropertyGroup *arg );

	//! Add DeterminedPropertyGroup child element to this StructureRevision. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	DeterminedPropertyGroup *AddDeterminedPropertyGroup();
     
	//! Add 'arg' as DeterminedPropertyGroup child element to this StructureRevision.
	plmxml_api::Result AddDeterminedPropertyGroup( DeterminedPropertyGroup *arg );

	//! Detach and delete all DeterminedPropertyGroup child elements.
	void DeleteDeterminedPropertyGroups();
     
	//! Get number of DeterminedPropertyGroup child elements.
	int NumberOfDeterminedPropertyGroups() const;
     
	//! Get i'th DeterminedPropertyGroup child element.
	DeterminedPropertyGroup *GetDeterminedPropertyGroup( int i ) const;
     
	//! Get all DeterminedPropertyGroup child element as an array
	void GetDeterminedPropertyGroups( plmxml_api::Array<DeterminedPropertyGroup*> &array ) const;
	     
	//! Detach and delete i'th DeterminedPropertyGroup child element
	void DeleteDeterminedPropertyGroup( int i );
     
	//! Detach and delete 'arg' if it's one of the DeterminedPropertyGroup child elements
	void DeleteDeterminedPropertyGroup( DeterminedPropertyGroup *arg );
 
// <PLMXML_UserCode type="functionHeaderStructureRevision" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassStructureRevision;


//! Forward class declarations
class Occurrence;
class PropertyGroup;
class RepresentationEntity;
class EntityPropertyGroup;
class SymbolicOccurrence;
class DeterminedPropertyGroup;

////////////////////////////////////////////////////////////////////////////////////
//! StructureRevisionView class
/*!
\verbatim

      This is a base type for elements representing a 'view' (design,
      manufacturing, etc) of a StructureRevision.

      Attributes:

      revisionRef:      Specifies the StructureRevision of which this is a view.
      viewRef:          A reference to a view element (e.g. 'design')
      structureViewRef: A reference to the corresponding element derived from
                        StructureView (e.g. ProductStructureView), of which this
                        is a revision.

      instanceRefs:     Referenced Instances which define the hierarchical structure.

      gdeInstanceRefs:  Referenced GDEInstance or GDEInstanceGroup elements.

      connectionInstanceRefs: Referenced ConnectionInstance elements.

      signalInstanceRefs: Reference to Instance elements which reference SignalRevision
                        elements.

      routeInstanceRefs: Reference to Instance elements which reference Route
                        elements.

      occurrenceRefs:   if an assembly, this element may have certain Occurrences singled
                        out, so that, for example, they can have different Materials
                        associated, or can be repositioned.

      locationInstanceRefs: Reference to LocationInstance elements.
      propertyRefs:     reference to properties
      ruleRefs:         reference to configuration rules (derived from ConfigRuleBase), which
                        specify how this structure was configured.

      occurrenceControlState: "explicit", "implicit", or "mixed"

      Elements:

      Occurrence:       These Occurrences play the same role as occurrenceRefs, above.
      PropertyGroup     a group of Properties of the StructureRevisionView
      RepresentationEntity: 'logical entities' in the StructureRevisionView, which
                        correspond to a number of equivalent objects in Representation files
      EntityPropertyGroup: used to specify Properties of logical entities in the
                        StructureRevisionView
      SymbolicOccurrence: SymbolicOccurrences in the context of this StructureRevisionView
      DeterminedPropertyGroup: The StructureRevisionView Properties determined
                        by a specific method.
      
\endverbatim
*/
class PLMXML60_API StructureRevisionView : public Managed
{
public:
     
    //! Default constructor
    StructureRevisionView( );
     
    //! Constructs a StructureRevisionView with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    StructureRevisionView( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~StructureRevisionView();

private:

	//! Assignment operator
	StructureRevisionView& operator=( const StructureRevisionView& iSrc );

	//! Copy constructor
	StructureRevisionView( const StructureRevisionView& original );
     
public:

	//! Get number of URIs in Property
	int NumberOfPropertyURIs() const;

	//! Get i'th URI in Property
	plmxml_api::String GetPropertyURI( int i ) const;

	//! Add a URI to Property array. Call ResolvePropertyURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddPropertyURI( const plmxml_api::String& u );

	//! Set i'th URI in Property array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetPropertyURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Property URI. Does not resolve the URI.
	plmxml_api::Result GetPropertyURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Property array.
	plmxml_api::Result AddPropertyURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Property array to point to 'handle'.
	plmxml_api::Result SetPropertyURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Property points to.
	plmxml_api::Result ResolvePropertyURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Property array.
	plmxml_api::Result DeletePropertyURI( int i );

	//! Remove all URIs from Property array.
	plmxml_api::Result DeletePropertyURIs( );
	
	//! Check if Property is set
	plmxml_api::logical HasPropertyURIs( ) const;

	//! Get number of URIs in LocationInstance
	int NumberOfLocationInstanceURIs() const;

	//! Get i'th URI in LocationInstance
	plmxml_api::String GetLocationInstanceURI( int i ) const;

	//! Add a URI to LocationInstance array. Call ResolveLocationInstanceURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddLocationInstanceURI( const plmxml_api::String& u );

	//! Set i'th URI in LocationInstance array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetLocationInstanceURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of LocationInstance URI. Does not resolve the URI.
	plmxml_api::Result GetLocationInstanceURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to LocationInstance array.
	plmxml_api::Result AddLocationInstanceURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in LocationInstance array to point to 'handle'.
	plmxml_api::Result SetLocationInstanceURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in LocationInstance points to.
	plmxml_api::Result ResolveLocationInstanceURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from LocationInstance array.
	plmxml_api::Result DeleteLocationInstanceURI( int i );

	//! Remove all URIs from LocationInstance array.
	plmxml_api::Result DeleteLocationInstanceURIs( );
	
	//! Check if LocationInstance is set
	plmxml_api::logical HasLocationInstanceURIs( ) const;

	//! Get StructureView URI as plmxml_api::String
	plmxml_api::String GetStructureViewURI() const;

	//! Set StructureView URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetStructureViewURI( const plmxml_api::String& );
	
	//! Get the handle of StructureView URI. Does not resolve the URI.
	plmxml_api::Result GetStructureViewURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of StructureView URI. URI string is unchanged.
	plmxml_api::Result SetStructureViewURI( const plmxml_api::Handle& );
	
	//! Resolve StructureView URI and return an object (handle) it points to.
	plmxml_api::Result ResolveStructureViewURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset StructureView URI. Clears URI string and handle.
	plmxml_api::Result DeleteStructureViewURI();
	
	//! Check if StructureView URI is set
	plmxml_api::logical HasStructureViewURI( ) const;
	

	//! Get number of references in Instance array
	int NumberOfInstanceRefs() const;
     
	//! Add reference to 'arg' to Instance array
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical AddInstanceRef( plmxml60::IdObject *arg );
     
	//! Add reference to an object pointed to by 'u' to Instance array
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical AddInstanceId( const plmxml_api::String &u );
     
	//! Set i'th reference in Instance array to 'arg'
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical SetInstanceRef( int i, plmxml60::IdObject *arg );
     
	//! Set i'th reference in Instance array to an object pointed to by 'u'
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical SetInstanceId( int i, const plmxml_api::String &u );
     
	//! Resolve i'th reference in Instance array and return an object it points to.
	plmxml60::IdObject *ResolveInstanceRef( int i, plmxml_api::Configuration* config = NULL );
     
	//! Resolve all references in Instance array and return objects they point to.
	void ResolveInstanceRefs( plmxml_api::Array<plmxml60::IdObject *> & array, plmxml_api::Configuration* config = NULL );
     
	//! Get i'th reference in Instance array as plmxml_api::String
	plmxml_api::String GetInstanceId( int i ) const;
     
	//! Get all references in Instance array as an array of plmxml_api::String
	void GetInstanceIds( plmxml_api::Array<plmxml_api::String> &array ) const;
     
	//! Remove i'th reference from the Instance array.
	void RemoveInstanceRef( int i );
     
	//! Remove reference to an object pointed to by 'u' from the Instance array.
	void RemoveInstanceRef( const plmxml_api::String &u );
     
	//! Remove reference to 'arg' from the Instance array.
	void RemoveInstanceRef( plmxml60::IdObject *arg );
     
	//! Remove all references Instance array.
	void RemoveInstanceRefs();
	
	//! Check if Instance is set
	plmxml_api::logical HasInstanceRefs( ) const;

	//! Get number of URIs in Occurrence
	int NumberOfOccurrenceURIs() const;

	//! Get i'th URI in Occurrence
	plmxml_api::String GetOccurrenceURI( int i ) const;

	//! Add a URI to Occurrence array. Call ResolveOccurrenceURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddOccurrenceURI( const plmxml_api::String& u );

	//! Set i'th URI in Occurrence array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetOccurrenceURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Occurrence URI. Does not resolve the URI.
	plmxml_api::Result GetOccurrenceURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Occurrence array.
	plmxml_api::Result AddOccurrenceURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Occurrence array to point to 'handle'.
	plmxml_api::Result SetOccurrenceURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Occurrence points to.
	plmxml_api::Result ResolveOccurrenceURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Occurrence array.
	plmxml_api::Result DeleteOccurrenceURI( int i );

	//! Remove all URIs from Occurrence array.
	plmxml_api::Result DeleteOccurrenceURIs( );
	
	//! Check if Occurrence is set
	plmxml_api::logical HasOccurrenceURIs( ) const;

	//! Get Revision URI as plmxml_api::String
	plmxml_api::String GetRevisionURI() const;

	//! Set Revision URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetRevisionURI( const plmxml_api::String& );
	
	//! Get the handle of Revision URI. Does not resolve the URI.
	plmxml_api::Result GetRevisionURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Revision URI. URI string is unchanged.
	plmxml_api::Result SetRevisionURI( const plmxml_api::Handle& );
	
	//! Resolve Revision URI and return an object (handle) it points to.
	plmxml_api::Result ResolveRevisionURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Revision URI. Clears URI string and handle.
	plmxml_api::Result DeleteRevisionURI();
	
	//! Check if Revision URI is set
	plmxml_api::logical HasRevisionURI( ) const;
	

	//! Get number of URIs in SignalInstance
	int NumberOfSignalInstanceURIs() const;

	//! Get i'th URI in SignalInstance
	plmxml_api::String GetSignalInstanceURI( int i ) const;

	//! Add a URI to SignalInstance array. Call ResolveSignalInstanceURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddSignalInstanceURI( const plmxml_api::String& u );

	//! Set i'th URI in SignalInstance array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetSignalInstanceURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of SignalInstance URI. Does not resolve the URI.
	plmxml_api::Result GetSignalInstanceURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to SignalInstance array.
	plmxml_api::Result AddSignalInstanceURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in SignalInstance array to point to 'handle'.
	plmxml_api::Result SetSignalInstanceURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in SignalInstance points to.
	plmxml_api::Result ResolveSignalInstanceURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from SignalInstance array.
	plmxml_api::Result DeleteSignalInstanceURI( int i );

	//! Remove all URIs from SignalInstance array.
	plmxml_api::Result DeleteSignalInstanceURIs( );
	
	//! Check if SignalInstance is set
	plmxml_api::logical HasSignalInstanceURIs( ) const;

	//! Get number of URIs in RouteInstance
	int NumberOfRouteInstanceURIs() const;

	//! Get i'th URI in RouteInstance
	plmxml_api::String GetRouteInstanceURI( int i ) const;

	//! Add a URI to RouteInstance array. Call ResolveRouteInstanceURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddRouteInstanceURI( const plmxml_api::String& u );

	//! Set i'th URI in RouteInstance array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetRouteInstanceURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of RouteInstance URI. Does not resolve the URI.
	plmxml_api::Result GetRouteInstanceURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to RouteInstance array.
	plmxml_api::Result AddRouteInstanceURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in RouteInstance array to point to 'handle'.
	plmxml_api::Result SetRouteInstanceURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in RouteInstance points to.
	plmxml_api::Result ResolveRouteInstanceURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from RouteInstance array.
	plmxml_api::Result DeleteRouteInstanceURI( int i );

	//! Remove all URIs from RouteInstance array.
	plmxml_api::Result DeleteRouteInstanceURIs( );
	
	//! Check if RouteInstance is set
	plmxml_api::logical HasRouteInstanceURIs( ) const;

	//! Set OccurrenceControlState
	plmxml_api::Result SetOccurrenceControlState( const eOccurrenceControlEnum& arg );

	//! Get OccurrenceControlState
	eOccurrenceControlEnum GetOccurrenceControlState() const;

	//! Get number of URIs in ConnectionInstance
	int NumberOfConnectionInstanceURIs() const;

	//! Get i'th URI in ConnectionInstance
	plmxml_api::String GetConnectionInstanceURI( int i ) const;

	//! Add a URI to ConnectionInstance array. Call ResolveConnectionInstanceURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddConnectionInstanceURI( const plmxml_api::String& u );

	//! Set i'th URI in ConnectionInstance array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetConnectionInstanceURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of ConnectionInstance URI. Does not resolve the URI.
	plmxml_api::Result GetConnectionInstanceURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to ConnectionInstance array.
	plmxml_api::Result AddConnectionInstanceURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in ConnectionInstance array to point to 'handle'.
	plmxml_api::Result SetConnectionInstanceURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in ConnectionInstance points to.
	plmxml_api::Result ResolveConnectionInstanceURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from ConnectionInstance array.
	plmxml_api::Result DeleteConnectionInstanceURI( int i );

	//! Remove all URIs from ConnectionInstance array.
	plmxml_api::Result DeleteConnectionInstanceURIs( );
	
	//! Check if ConnectionInstance is set
	plmxml_api::logical HasConnectionInstanceURIs( ) const;

	//! Get View URI as plmxml_api::String
	plmxml_api::String GetViewURI() const;

	//! Set View URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetViewURI( const plmxml_api::String& );
	
	//! Get the handle of View URI. Does not resolve the URI.
	plmxml_api::Result GetViewURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of View URI. URI string is unchanged.
	plmxml_api::Result SetViewURI( const plmxml_api::Handle& );
	
	//! Resolve View URI and return an object (handle) it points to.
	plmxml_api::Result ResolveViewURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset View URI. Clears URI string and handle.
	plmxml_api::Result DeleteViewURI();
	
	//! Check if View URI is set
	plmxml_api::logical HasViewURI( ) const;
	

	//! Get number of URIs in GdeInstance
	int NumberOfGdeInstanceURIs() const;

	//! Get i'th URI in GdeInstance
	plmxml_api::String GetGdeInstanceURI( int i ) const;

	//! Add a URI to GdeInstance array. Call ResolveGdeInstanceURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddGdeInstanceURI( const plmxml_api::String& u );

	//! Set i'th URI in GdeInstance array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetGdeInstanceURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of GdeInstance URI. Does not resolve the URI.
	plmxml_api::Result GetGdeInstanceURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to GdeInstance array.
	plmxml_api::Result AddGdeInstanceURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in GdeInstance array to point to 'handle'.
	plmxml_api::Result SetGdeInstanceURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in GdeInstance points to.
	plmxml_api::Result ResolveGdeInstanceURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from GdeInstance array.
	plmxml_api::Result DeleteGdeInstanceURI( int i );

	//! Remove all URIs from GdeInstance array.
	plmxml_api::Result DeleteGdeInstanceURIs( );
	
	//! Check if GdeInstance is set
	plmxml_api::logical HasGdeInstanceURIs( ) const;

	//! Get number of URIs in Rule
	int NumberOfRuleURIs() const;

	//! Get i'th URI in Rule
	plmxml_api::String GetRuleURI( int i ) const;

	//! Add a URI to Rule array. Call ResolveRuleURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddRuleURI( const plmxml_api::String& u );

	//! Set i'th URI in Rule array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetRuleURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Rule URI. Does not resolve the URI.
	plmxml_api::Result GetRuleURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Rule array.
	plmxml_api::Result AddRuleURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Rule array to point to 'handle'.
	plmxml_api::Result SetRuleURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Rule points to.
	plmxml_api::Result ResolveRuleURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Rule array.
	plmxml_api::Result DeleteRuleURI( int i );

	//! Remove all URIs from Rule array.
	plmxml_api::Result DeleteRuleURIs( );
	
	//! Check if Rule is set
	plmxml_api::logical HasRuleURIs( ) const;

	//! Add Occurrence child element to this StructureRevisionView. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Occurrence *AddOccurrence();
     
	//! Add 'arg' as Occurrence child element to this StructureRevisionView.
	plmxml_api::Result AddOccurrence( Occurrence *arg );

	//! Detach and delete all Occurrence child elements.
	void DeleteOccurrences();
     
	//! Get number of Occurrence child elements.
	int NumberOfOccurrences() const;
     
	//! Get i'th Occurrence child element.
	Occurrence *GetOccurrence( int i ) const;
     
	//! Get all Occurrence child element as an array
	void GetOccurrences( plmxml_api::Array<Occurrence*> &array ) const;
	     
	//! Detach and delete i'th Occurrence child element
	void DeleteOccurrence( int i );
     
	//! Detach and delete 'arg' if it's one of the Occurrence child elements
	void DeleteOccurrence( Occurrence *arg );

	//! Add PropertyGroup child element to this StructureRevisionView. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	PropertyGroup *AddPropertyGroup();
     
	//! Set PropertyGroup child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetPropertyGroup( PropertyGroup *arg );
     
	//! Get PropertyGroup child element of this StructureRevisionView.
	PropertyGroup *GetPropertyGroup() const;
     
	//! Detach and delete PropertyGroup child element tree from this StructureRevisionView.
	void DeletePropertyGroup();

	//! Add RepresentationEntity child element to this StructureRevisionView. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	RepresentationEntity *AddRepresentationEntity();
     
	//! Add 'arg' as RepresentationEntity child element to this StructureRevisionView.
	plmxml_api::Result AddRepresentationEntity( RepresentationEntity *arg );

	//! Detach and delete all RepresentationEntity child elements.
	void DeleteRepresentationEntities();
     
	//! Get number of RepresentationEntity child elements.
	int NumberOfRepresentationEntities() const;
     
	//! Get i'th RepresentationEntity child element.
	RepresentationEntity *GetRepresentationEntity( int i ) const;
     
	//! Get all RepresentationEntity child element as an array
	void GetRepresentationEntities( plmxml_api::Array<RepresentationEntity*> &array ) const;
	     
	//! Detach and delete i'th RepresentationEntity child element
	void DeleteRepresentationEntity( int i );
     
	//! Detach and delete 'arg' if it's one of the RepresentationEntity child elements
	void DeleteRepresentationEntity( RepresentationEntity *arg );

	//! Add EntityPropertyGroup child element to this StructureRevisionView. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	EntityPropertyGroup *AddEntityPropertyGroup();
     
	//! Add 'arg' as EntityPropertyGroup child element to this StructureRevisionView.
	plmxml_api::Result AddEntityPropertyGroup( EntityPropertyGroup *arg );

	//! Detach and delete all EntityPropertyGroup child elements.
	void DeleteEntityPropertyGroups();
     
	//! Get number of EntityPropertyGroup child elements.
	int NumberOfEntityPropertyGroups() const;
     
	//! Get i'th EntityPropertyGroup child element.
	EntityPropertyGroup *GetEntityPropertyGroup( int i ) const;
     
	//! Get all EntityPropertyGroup child element as an array
	void GetEntityPropertyGroups( plmxml_api::Array<EntityPropertyGroup*> &array ) const;
	     
	//! Detach and delete i'th EntityPropertyGroup child element
	void DeleteEntityPropertyGroup( int i );
     
	//! Detach and delete 'arg' if it's one of the EntityPropertyGroup child elements
	void DeleteEntityPropertyGroup( EntityPropertyGroup *arg );

	//! Add SymbolicOccurrence child element to this StructureRevisionView. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	SymbolicOccurrence *AddSymbolicOccurrence();
     
	//! Add 'arg' as SymbolicOccurrence child element to this StructureRevisionView.
	plmxml_api::Result AddSymbolicOccurrence( SymbolicOccurrence *arg );

	//! Detach and delete all SymbolicOccurrence child elements.
	void DeleteSymbolicOccurrences();
     
	//! Get number of SymbolicOccurrence child elements.
	int NumberOfSymbolicOccurrences() const;
     
	//! Get i'th SymbolicOccurrence child element.
	SymbolicOccurrence *GetSymbolicOccurrence( int i ) const;
     
	//! Get all SymbolicOccurrence child element as an array
	void GetSymbolicOccurrences( plmxml_api::Array<SymbolicOccurrence*> &array ) const;
	     
	//! Detach and delete i'th SymbolicOccurrence child element
	void DeleteSymbolicOccurrence( int i );
     
	//! Detach and delete 'arg' if it's one of the SymbolicOccurrence child elements
	void DeleteSymbolicOccurrence( SymbolicOccurrence *arg );

	//! Add DeterminedPropertyGroup child element to this StructureRevisionView. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	DeterminedPropertyGroup *AddDeterminedPropertyGroup();
     
	//! Set DeterminedPropertyGroup child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetDeterminedPropertyGroup( DeterminedPropertyGroup *arg );
     
	//! Get DeterminedPropertyGroup child element of this StructureRevisionView.
	DeterminedPropertyGroup *GetDeterminedPropertyGroup() const;
     
	//! Detach and delete DeterminedPropertyGroup child element tree from this StructureRevisionView.
	void DeleteDeterminedPropertyGroup();
 
// <PLMXML_UserCode type="functionHeaderStructureRevisionView" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassStructureRevisionView;


////////////////////////////////////////////////////////////////////////////////////
//! Product class
/*!
\verbatim

      This is the revision-independent Product, derived from Structure.
      It corresponds to the STEP 'product'.
      
      Attributes:
      
      productId:        The identifier of the Product, unique in some context, e.g. an 
                        Organisation.
      alternateForRef:  An 'alternate' Product is one which is substitutable, in all 
                        contexts, for a particular Product. If this is an 'alternate'
                        Product, then this attribute references the Product for which
                        this is an alternate.
      unitRef:          The default Unit for the 'quantity' attribute of any referencing
                        ProductInstance elements.
      designRequired:   true if all the revisions of this Product must have
                        at least one associated DesignRevision
      source:           whether the Product is manufactured or bought-in
      vendorRef:        References the Vendor when the Product represents a
                        vendor part.
      
\endverbatim
*/
class PLMXML60_API Product : public Structure
{
public:
     
    //! Default constructor
    Product( );
     
    //! Constructs a Product with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Product( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Product();

private:

	//! Assignment operator
	Product& operator=( const Product& iSrc );

	//! Copy constructor
	Product( const Product& original );
     
public:

	//! Get Unit URI as plmxml_api::String
	plmxml_api::String GetUnitURI() const;

	//! Set Unit URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetUnitURI( const plmxml_api::String& );
	
	//! Get the handle of Unit URI. Does not resolve the URI.
	plmxml_api::Result GetUnitURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Unit URI. URI string is unchanged.
	plmxml_api::Result SetUnitURI( const plmxml_api::Handle& );
	
	//! Resolve Unit URI and return an object (handle) it points to.
	plmxml_api::Result ResolveUnitURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Unit URI. Clears URI string and handle.
	plmxml_api::Result DeleteUnitURI();
	
	//! Check if Unit URI is set
	plmxml_api::logical HasUnitURI( ) const;
	

	//! Get AlternateFor URI as plmxml_api::String
	plmxml_api::String GetAlternateForURI() const;

	//! Set AlternateFor URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetAlternateForURI( const plmxml_api::String& );
	
	//! Get the handle of AlternateFor URI. Does not resolve the URI.
	plmxml_api::Result GetAlternateForURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of AlternateFor URI. URI string is unchanged.
	plmxml_api::Result SetAlternateForURI( const plmxml_api::Handle& );
	
	//! Resolve AlternateFor URI and return an object (handle) it points to.
	plmxml_api::Result ResolveAlternateForURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset AlternateFor URI. Clears URI string and handle.
	plmxml_api::Result DeleteAlternateForURI();
	
	//! Check if AlternateFor URI is set
	plmxml_api::logical HasAlternateForURI( ) const;
	

	//! Set DesignRequired
	plmxml_api::Result SetDesignRequired( plmxml_api::logical arg );

	//! Get DesignRequired
	plmxml_api::logical GetDesignRequired() const;

	//! Check if DesignRequired is set
	plmxml_api::logical HasDesignRequired() const;

	//! Unset DesignRequired
	plmxml_api::Result UnsetDesignRequired();

	//! Set Source
	plmxml_api::Result SetSource( const eProductSourceEnum& arg );

	//! Get Source
	eProductSourceEnum GetSource() const;

	//! Get Vendor URI as plmxml_api::String
	plmxml_api::String GetVendorURI() const;

	//! Set Vendor URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetVendorURI( const plmxml_api::String& );
	
	//! Get the handle of Vendor URI. Does not resolve the URI.
	plmxml_api::Result GetVendorURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Vendor URI. URI string is unchanged.
	plmxml_api::Result SetVendorURI( const plmxml_api::Handle& );
	
	//! Resolve Vendor URI and return an object (handle) it points to.
	plmxml_api::Result ResolveVendorURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Vendor URI. Clears URI string and handle.
	plmxml_api::Result DeleteVendorURI();
	
	//! Check if Vendor URI is set
	plmxml_api::logical HasVendorURI( ) const;
	

	//! Get ProductId of this Product
	plmxml_api::String GetProductId() const;

	//! Set ProductId of this Product
	plmxml_api::Result SetProductId( const plmxml_api::String &s );
	
	//! Check if ProductId is set
	plmxml_api::logical HasProductId( ) const;
	
	//! Unset ProductId
	plmxml_api::Result UnsetProductId( );
 
// <PLMXML_UserCode type="functionHeaderProduct" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassProduct;


////////////////////////////////////////////////////////////////////////////////////
//! ProductRevision class
/*!
\verbatim

      This is a revision of a Product. It corresponds to STEP 'product_definition_formation'.
      
      Attributes:
      
      primaryDesignRef: The primary DesignRevision, if any. This attribute is
                        deprecated. Use primaryDesign on RepresentedByRelation
                        instead.
      source:           Whether the Product is manufactured or bought-in.
      designRequired:   true if the ProductRevision must have at least one
                        associated DesignRevision.
      
\endverbatim
*/
class PLMXML60_API ProductRevision : public StructureRevision
{
public:
     
    //! Default constructor
    ProductRevision( );
     
    //! Constructs a ProductRevision with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ProductRevision( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ProductRevision();

private:

	//! Assignment operator
	ProductRevision& operator=( const ProductRevision& iSrc );

	//! Copy constructor
	ProductRevision( const ProductRevision& original );
     
public:

	//! Set Source
	plmxml_api::Result SetSource( const eProductSourceEnum& arg );

	//! Get Source
	eProductSourceEnum GetSource() const;

	//! Get PrimaryDesign URI as plmxml_api::String
	plmxml_api::String GetPrimaryDesignURI() const;

	//! Set PrimaryDesign URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetPrimaryDesignURI( const plmxml_api::String& );
	
	//! Get the handle of PrimaryDesign URI. Does not resolve the URI.
	plmxml_api::Result GetPrimaryDesignURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of PrimaryDesign URI. URI string is unchanged.
	plmxml_api::Result SetPrimaryDesignURI( const plmxml_api::Handle& );
	
	//! Resolve PrimaryDesign URI and return an object (handle) it points to.
	plmxml_api::Result ResolvePrimaryDesignURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset PrimaryDesign URI. Clears URI string and handle.
	plmxml_api::Result DeletePrimaryDesignURI();
	
	//! Check if PrimaryDesign URI is set
	plmxml_api::logical HasPrimaryDesignURI( ) const;
	

	//! Set DesignRequired
	plmxml_api::Result SetDesignRequired( plmxml_api::logical arg );

	//! Get DesignRequired
	plmxml_api::logical GetDesignRequired() const;

	//! Check if DesignRequired is set
	plmxml_api::logical HasDesignRequired() const;

	//! Unset DesignRequired
	plmxml_api::Result UnsetDesignRequired();
 
// <PLMXML_UserCode type="functionHeaderProductRevision" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassProductRevision;


////////////////////////////////////////////////////////////////////////////////////
//! ProductRevisionView class
/*!
\verbatim

      This is a 'view' (e.g. 'design', 'manufacturing', 'maintenance') of a revision of a 
      Product.
      
      Attributes:
      
      representationRefs: Representations of the ProductRevisionView.
      materialRef:        an optional Material for use when displaying the
                          ProductRevisionView.
      preferredUnits:     (deprecated) The units preferred when presenting this element to the user.
                          Note that this does NOT affect any numerical values
                          representing lengths in the PLMXML file - these are always in
                          metres. This attribute is deprecated - use a DisplayPreferences
                          Property instead.
      geometryRefs:       geometry elements referenced by the ProductRevisionView.
      type:               assembly, minimal, wire, solid, sheet or general.
      
      annotation3DGroupRefs: (deprecated) reference to any 3D Annotation groups
                          associated with the ProductRevisionView.
                          (note: these are not defined within this schema).
                          
      partRefs:           (deprecated). If an assembly, it is also possible to 'instance' 
                          other Parts directly without the need for an actual Instance 
                          element. However this is limited to cases where information 
                          stored on the Instance (such as Transform) is not required.
      designRequired:     true if the ProductRevisionView must have at least one
                          associated DesignRevisionView.
      
      Elements:

      Representation:     see representationRefs.
      
\endverbatim
*/
class PLMXML60_API ProductRevisionView : public StructureRevisionView
{
public:
     
    //! Default constructor
    ProductRevisionView( );
     
    //! Constructs a ProductRevisionView with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ProductRevisionView( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ProductRevisionView();

private:

	//! Assignment operator
	ProductRevisionView& operator=( const ProductRevisionView& iSrc );

	//! Copy constructor
	ProductRevisionView( const ProductRevisionView& original );
     
public:

	//! Set PreferredUnits
	plmxml_api::Result SetPreferredUnits( const ePreferredPartUnitsType& arg );

	//! Get PreferredUnits
	ePreferredPartUnitsType GetPreferredUnits() const;

	//! Get number of URIs in Geometry
	int NumberOfGeometryURIs() const;

	//! Get i'th URI in Geometry
	plmxml_api::String GetGeometryURI( int i ) const;

	//! Add a URI to Geometry array. Call ResolveGeometryURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddGeometryURI( const plmxml_api::String& u );

	//! Set i'th URI in Geometry array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetGeometryURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Geometry URI. Does not resolve the URI.
	plmxml_api::Result GetGeometryURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Geometry array.
	plmxml_api::Result AddGeometryURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Geometry array to point to 'handle'.
	plmxml_api::Result SetGeometryURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Geometry points to.
	plmxml_api::Result ResolveGeometryURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Geometry array.
	plmxml_api::Result DeleteGeometryURI( int i );

	//! Remove all URIs from Geometry array.
	plmxml_api::Result DeleteGeometryURIs( );
	
	//! Check if Geometry is set
	plmxml_api::logical HasGeometryURIs( ) const;

	//! Get number of references in Representation array
	int NumberOfRepresentationRefs() const;
     
	//! Add reference to 'arg' to Representation array
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical AddRepresentationRef( plmxml60::IdObject *arg );
     
	//! Add reference to an object pointed to by 'u' to Representation array
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical AddRepresentationId( const plmxml_api::String &u );
     
	//! Set i'th reference in Representation array to 'arg'
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical SetRepresentationRef( int i, plmxml60::IdObject *arg );
     
	//! Set i'th reference in Representation array to an object pointed to by 'u'
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical SetRepresentationId( int i, const plmxml_api::String &u );
     
	//! Resolve i'th reference in Representation array and return an object it points to.
	plmxml60::IdObject *ResolveRepresentationRef( int i, plmxml_api::Configuration* config = NULL );
     
	//! Resolve all references in Representation array and return objects they point to.
	void ResolveRepresentationRefs( plmxml_api::Array<plmxml60::IdObject *> & array, plmxml_api::Configuration* config = NULL );
     
	//! Get i'th reference in Representation array as plmxml_api::String
	plmxml_api::String GetRepresentationId( int i ) const;
     
	//! Get all references in Representation array as an array of plmxml_api::String
	void GetRepresentationIds( plmxml_api::Array<plmxml_api::String> &array ) const;
     
	//! Remove i'th reference from the Representation array.
	void RemoveRepresentationRef( int i );
     
	//! Remove reference to an object pointed to by 'u' from the Representation array.
	void RemoveRepresentationRef( const plmxml_api::String &u );
     
	//! Remove reference to 'arg' from the Representation array.
	void RemoveRepresentationRef( plmxml60::IdObject *arg );
     
	//! Remove all references Representation array.
	void RemoveRepresentationRefs();
	
	//! Check if Representation is set
	plmxml_api::logical HasRepresentationRefs( ) const;

	//! Get number of references in Part array
	int NumberOfPartRefs() const;
     
	//! Add reference to 'arg' to Part array
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical AddPartRef( plmxml60::IdObject *arg );
     
	//! Add reference to an object pointed to by 'u' to Part array
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical AddPartId( const plmxml_api::String &u );
     
	//! Set i'th reference in Part array to 'arg'
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical SetPartRef( int i, plmxml60::IdObject *arg );
     
	//! Set i'th reference in Part array to an object pointed to by 'u'
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical SetPartId( int i, const plmxml_api::String &u );
     
	//! Resolve i'th reference in Part array and return an object it points to.
	plmxml60::IdObject *ResolvePartRef( int i, plmxml_api::Configuration* config = NULL );
     
	//! Resolve all references in Part array and return objects they point to.
	void ResolvePartRefs( plmxml_api::Array<plmxml60::IdObject *> & array, plmxml_api::Configuration* config = NULL );
     
	//! Get i'th reference in Part array as plmxml_api::String
	plmxml_api::String GetPartId( int i ) const;
     
	//! Get all references in Part array as an array of plmxml_api::String
	void GetPartIds( plmxml_api::Array<plmxml_api::String> &array ) const;
     
	//! Remove i'th reference from the Part array.
	void RemovePartRef( int i );
     
	//! Remove reference to an object pointed to by 'u' from the Part array.
	void RemovePartRef( const plmxml_api::String &u );
     
	//! Remove reference to 'arg' from the Part array.
	void RemovePartRef( plmxml60::IdObject *arg );
     
	//! Remove all references Part array.
	void RemovePartRefs();
	
	//! Check if Part is set
	plmxml_api::logical HasPartRefs( ) const;

	//! Set DesignRequired
	plmxml_api::Result SetDesignRequired( plmxml_api::logical arg );

	//! Get DesignRequired
	plmxml_api::logical GetDesignRequired() const;

	//! Check if DesignRequired is set
	plmxml_api::logical HasDesignRequired() const;

	//! Unset DesignRequired
	plmxml_api::Result UnsetDesignRequired();

	//! Set Type
	plmxml_api::Result SetType( const ePartType& arg );

	//! Get Type
	ePartType GetType() const;

	//! Get number of URIs in Annotation3DGroup
	int NumberOfAnnotation3DGroupURIs() const;

	//! Get i'th URI in Annotation3DGroup
	plmxml_api::String GetAnnotation3DGroupURI( int i ) const;

	//! Add a URI to Annotation3DGroup array. Call ResolveAnnotation3DGroupURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddAnnotation3DGroupURI( const plmxml_api::String& u );

	//! Set i'th URI in Annotation3DGroup array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetAnnotation3DGroupURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Annotation3DGroup URI. Does not resolve the URI.
	plmxml_api::Result GetAnnotation3DGroupURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Annotation3DGroup array.
	plmxml_api::Result AddAnnotation3DGroupURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Annotation3DGroup array to point to 'handle'.
	plmxml_api::Result SetAnnotation3DGroupURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Annotation3DGroup points to.
	plmxml_api::Result ResolveAnnotation3DGroupURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Annotation3DGroup array.
	plmxml_api::Result DeleteAnnotation3DGroupURI( int i );

	//! Remove all URIs from Annotation3DGroup array.
	plmxml_api::Result DeleteAnnotation3DGroupURIs( );
	
	//! Check if Annotation3DGroup is set
	plmxml_api::logical HasAnnotation3DGroupURIs( ) const;

	//! Set reference to Material using 'arg's plmxml_api::Id.
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical SetMaterialRef( plmxml60::IdObject *arg );

	//! Clear reference to Material
	void RemoveMaterialRef( );

	//! Find a plmxml60::IdObject referenced by Material
	plmxml60::IdObject *ResolveMaterialRef( plmxml_api::Configuration* config = NULL );

	//! Get Material reference
	plmxml_api::String GetMaterialId() const;

	//! Set Material reference.
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical SetMaterialId( const plmxml_api::String& u );
	
	//! Check if Material is set
	plmxml_api::logical HasMaterialRef( ) const;

	//! Add Representation child element to this ProductRevisionView. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Representation *AddRepresentation();
     
	//! Add 'arg' as Representation child element to this ProductRevisionView.
	plmxml_api::Result AddRepresentation( Representation *arg );

	//! Detach and delete all Representation child elements.
	void DeleteRepresentations();
     
	//! Get number of Representation child elements.
	int NumberOfRepresentations() const;
     
	//! Get i'th Representation child element.
	Representation *GetRepresentation( int i ) const;
     
	//! Get all Representation child element as an array
	void GetRepresentations( plmxml_api::Array<Representation*> &array ) const;
	     
	//! Detach and delete i'th Representation child element
	void DeleteRepresentation( int i );
     
	//! Detach and delete 'arg' if it's one of the Representation child elements
	void DeleteRepresentation( Representation *arg );
 
// <PLMXML_UserCode type="functionHeaderProductRevisionView" >
    //! Returns true if the ProductRevisionView type is Assembly
	plmxml_api::logical IsAssembly( void ) const;

	//! Returns true if the ProductRevisionView is a Body, i.e. not an Assembly
	plmxml_api::logical IsBody( void ) const;
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassProductRevisionView;


////////////////////////////////////////////////////////////////////////////////////
//! View class
/*!
\verbatim

      This is a 'view' (e.g. 'design', 'manufacturing', 'maintenance'). Referenced by a 
      ProductRevisionView.
      
      Attributes:
      
      (the 'name' attribute of the View is inherited from AttribOwnerBase)
      
\endverbatim
*/
class PLMXML60_API View : public AttribOwner
{
public:
     
    //! Default constructor
    View( );
     
    //! Constructs a View with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    View( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~View();

private:

	//! Assignment operator
	View& operator=( const View& iSrc );

	//! Copy constructor
	View( const View& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderView" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassView;


////////////////////////////////////////////////////////////////////////////////////
//! GDEReference class
/*!
\verbatim

      A reference from a GDEInstance to an Occurrence or InstancePath.

      An entity in a Representation can also be specified.

      Attributes:

      type:           type of the Reference.
      occurrenceRef:  reference to an Occurrence or InstancePath.
      pathRefs:       a list of Instance elements defining a path through the
                      Structure. pathRefs and occurrenceRef should not both be
                      present.
      targetRef:      reference to a RepresentationEntity.
      origin:         Whether the reference reprepresents the origin for other
                      references.

      Sub-elements:

      EntityRef:      (deprecated) reference to an Entity in a Representation. This must 
                      be a Representation of the 'bottom Structure' of the Occurrence
                      or InstancePath.
      
\endverbatim
*/
class PLMXML60_API GDEReference : public AttribOwner
{
public:
     
    //! Default constructor
    GDEReference( );
     
    //! Constructs a GDEReference with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    GDEReference( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~GDEReference();

private:

	//! Assignment operator
	GDEReference& operator=( const GDEReference& iSrc );

	//! Copy constructor
	GDEReference( const GDEReference& original );
     
public:

	//! Get Occurrence URI as plmxml_api::String
	plmxml_api::String GetOccurrenceURI() const;

	//! Set Occurrence URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetOccurrenceURI( const plmxml_api::String& );
	
	//! Get the handle of Occurrence URI. Does not resolve the URI.
	plmxml_api::Result GetOccurrenceURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Occurrence URI. URI string is unchanged.
	plmxml_api::Result SetOccurrenceURI( const plmxml_api::Handle& );
	
	//! Resolve Occurrence URI and return an object (handle) it points to.
	plmxml_api::Result ResolveOccurrenceURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Occurrence URI. Clears URI string and handle.
	plmxml_api::Result DeleteOccurrenceURI();
	
	//! Check if Occurrence URI is set
	plmxml_api::logical HasOccurrenceURI( ) const;
	

	//! Set Origin
	plmxml_api::Result SetOrigin( plmxml_api::logical arg );

	//! Get Origin
	plmxml_api::logical GetOrigin() const;

	//! Check if Origin is set
	plmxml_api::logical HasOrigin() const;

	//! Unset Origin
	plmxml_api::Result UnsetOrigin();

	//! Set Type
	plmxml_api::Result SetType( const eGDERelationshipType& arg );

	//! Get Type
	eGDERelationshipType GetType() const;

	//! Get Target URI as plmxml_api::String
	plmxml_api::String GetTargetURI() const;

	//! Set Target URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetTargetURI( const plmxml_api::String& );
	
	//! Get the handle of Target URI. Does not resolve the URI.
	plmxml_api::Result GetTargetURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Target URI. URI string is unchanged.
	plmxml_api::Result SetTargetURI( const plmxml_api::Handle& );
	
	//! Resolve Target URI and return an object (handle) it points to.
	plmxml_api::Result ResolveTargetURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Target URI. Clears URI string and handle.
	plmxml_api::Result DeleteTargetURI();
	
	//! Check if Target URI is set
	plmxml_api::logical HasTargetURI( ) const;
	

	//! Get number of URIs in Path
	int NumberOfPathURIs() const;

	//! Get i'th URI in Path
	plmxml_api::String GetPathURI( int i ) const;

	//! Add a URI to Path array. Call ResolvePathURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddPathURI( const plmxml_api::String& u );

	//! Set i'th URI in Path array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetPathURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Path URI. Does not resolve the URI.
	plmxml_api::Result GetPathURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Path array.
	plmxml_api::Result AddPathURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Path array to point to 'handle'.
	plmxml_api::Result SetPathURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Path points to.
	plmxml_api::Result ResolvePathURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Path array.
	plmxml_api::Result DeletePathURI( int i );

	//! Remove all URIs from Path array.
	plmxml_api::Result DeletePathURIs( );
	
	//! Check if Path is set
	plmxml_api::logical HasPathURIs( ) const;

	//! Add EntityRef child element to this GDEReference. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	EntityRef *AddEntityRef();
     
	//! Set EntityRef child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetEntityRef( EntityRef *arg );
     
	//! Get EntityRef child element of this GDEReference.
	EntityRef *GetEntityRef() const;
     
	//! Detach and delete EntityRef child element tree from this GDEReference.
	void DeleteEntityRef();
 
// <PLMXML_UserCode type="functionHeaderGDEReference" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassGDEReference;


//! Forward class declarations
class PropertyGroup;
class DeterminedPropertyGroup;

////////////////////////////////////////////////////////////////////////////////////
//! GDE class
/*!
\verbatim

      The GDE element represents an internal constituent of a Structure
      object, such as a Design Feature, Port, Annotation, etc. The Structure
      instances the GDE by means of a GDEInstance.

      Attributes:

      gdeInstanceRefs: a list of references to associated GDEInstances or
                       GDEInstanceGroups. This is to allow the GDE to have
                       internal structure.
      propertyRefs:    reference to properties

      Elements:

      PropertyGroup
      DeterminedPropertyGroup: The Properties determined by a specific method.
      
\endverbatim
*/
class PLMXML60_API GDE : public Managed
{
public:
     
    //! Default constructor
    GDE( );
     
    //! Constructs a GDE with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    GDE( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~GDE();

private:

	//! Assignment operator
	GDE& operator=( const GDE& iSrc );

	//! Copy constructor
	GDE( const GDE& original );
     
public:

	//! Get number of URIs in GdeInstance
	int NumberOfGdeInstanceURIs() const;

	//! Get i'th URI in GdeInstance
	plmxml_api::String GetGdeInstanceURI( int i ) const;

	//! Add a URI to GdeInstance array. Call ResolveGdeInstanceURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddGdeInstanceURI( const plmxml_api::String& u );

	//! Set i'th URI in GdeInstance array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetGdeInstanceURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of GdeInstance URI. Does not resolve the URI.
	plmxml_api::Result GetGdeInstanceURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to GdeInstance array.
	plmxml_api::Result AddGdeInstanceURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in GdeInstance array to point to 'handle'.
	plmxml_api::Result SetGdeInstanceURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in GdeInstance points to.
	plmxml_api::Result ResolveGdeInstanceURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from GdeInstance array.
	plmxml_api::Result DeleteGdeInstanceURI( int i );

	//! Remove all URIs from GdeInstance array.
	plmxml_api::Result DeleteGdeInstanceURIs( );
	
	//! Check if GdeInstance is set
	plmxml_api::logical HasGdeInstanceURIs( ) const;

	//! Get number of URIs in Property
	int NumberOfPropertyURIs() const;

	//! Get i'th URI in Property
	plmxml_api::String GetPropertyURI( int i ) const;

	//! Add a URI to Property array. Call ResolvePropertyURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddPropertyURI( const plmxml_api::String& u );

	//! Set i'th URI in Property array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetPropertyURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Property URI. Does not resolve the URI.
	plmxml_api::Result GetPropertyURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Property array.
	plmxml_api::Result AddPropertyURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Property array to point to 'handle'.
	plmxml_api::Result SetPropertyURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Property points to.
	plmxml_api::Result ResolvePropertyURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Property array.
	plmxml_api::Result DeletePropertyURI( int i );

	//! Remove all URIs from Property array.
	plmxml_api::Result DeletePropertyURIs( );
	
	//! Check if Property is set
	plmxml_api::logical HasPropertyURIs( ) const;

	//! Add PropertyGroup child element to this GDE. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	PropertyGroup *AddPropertyGroup();
     
	//! Set PropertyGroup child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetPropertyGroup( PropertyGroup *arg );
     
	//! Get PropertyGroup child element of this GDE.
	PropertyGroup *GetPropertyGroup() const;
     
	//! Detach and delete PropertyGroup child element tree from this GDE.
	void DeletePropertyGroup();

	//! Add DeterminedPropertyGroup child element to this GDE. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	DeterminedPropertyGroup *AddDeterminedPropertyGroup();
     
	//! Set DeterminedPropertyGroup child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetDeterminedPropertyGroup( DeterminedPropertyGroup *arg );
     
	//! Get DeterminedPropertyGroup child element of this GDE.
	DeterminedPropertyGroup *GetDeterminedPropertyGroup() const;
     
	//! Detach and delete DeterminedPropertyGroup child element tree from this GDE.
	void DeleteDeterminedPropertyGroup();
 
// <PLMXML_UserCode type="functionHeaderGDE" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassGDE;


////////////////////////////////////////////////////////////////////////////////////
//! Link class
/*!
\verbatim

      A type of GDE which represents a non-revisionable connection between 
      InstancePaths in an assembly.
      
\endverbatim
*/
class PLMXML60_API Link : public GDE
{
public:
     
    //! Default constructor
    Link( );
     
    //! Constructs a Link with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Link( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Link();

private:

	//! Assignment operator
	Link& operator=( const Link& iSrc );

	//! Copy constructor
	Link( const Link& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderLink" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassLink;


////////////////////////////////////////////////////////////////////////////////////
//! Connection class
/*!
\verbatim

      A Connection is a structured object which represents a connection between a
      number of InstancePaths in an assembly.
      
\endverbatim
*/
class PLMXML60_API Connection : public Structure
{
public:
     
    //! Default constructor
    Connection( );
     
    //! Constructs a Connection with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Connection( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Connection();

private:

	//! Assignment operator
	Connection& operator=( const Connection& iSrc );

	//! Copy constructor
	Connection( const Connection& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderConnection" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassConnection;


////////////////////////////////////////////////////////////////////////////////////
//! ConnectionRevision class
/*!
\verbatim

      This is a revision of a Connection. 
      
\endverbatim
*/
class PLMXML60_API ConnectionRevision : public StructureRevision
{
public:
     
    //! Default constructor
    ConnectionRevision( );
     
    //! Constructs a ConnectionRevision with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ConnectionRevision( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ConnectionRevision();

private:

	//! Assignment operator
	ConnectionRevision& operator=( const ConnectionRevision& iSrc );

	//! Copy constructor
	ConnectionRevision( const ConnectionRevision& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderConnectionRevision" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassConnectionRevision;


////////////////////////////////////////////////////////////////////////////////////
//! ConnectionRevisionView class
/*!
\verbatim

      This is a 'view' (e.g. 'design', 'manufacturing', 'maintenance') of a 
      revision of a Connection.
      
\endverbatim
*/
class PLMXML60_API ConnectionRevisionView : public StructureRevisionView
{
public:
     
    //! Default constructor
    ConnectionRevisionView( );
     
    //! Constructs a ConnectionRevisionView with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ConnectionRevisionView( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ConnectionRevisionView();

private:

	//! Assignment operator
	ConnectionRevisionView& operator=( const ConnectionRevisionView& iSrc );

	//! Copy constructor
	ConnectionRevisionView( const ConnectionRevisionView& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderConnectionRevisionView" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassConnectionRevisionView;


//! Forward class declarations
class FeatureOccurrence;

////////////////////////////////////////////////////////////////////////////////////
//! Feature class
/*!
\verbatim

      This abstract datatype describes a single feature within the feature tree
      hierarchy. The feature description contains basic information such as name
      and type, as well as information to link the feature to the originating
      application. Parameter descriptions can also be included in the feature
      description.

      Attributes:

      nextFeature:      (optional) the XML id of the next feature in the feature
                        hierarchy.
      targetFeature:    (optional) the XML id of the target feature that this
                        feature relies on. The target feature defines which
                        feature forms the resultant entity. If targetFeature is
                        used, featureRefs should not be used.
      toolFeature:      (optional) the XML id of the tool feature that this
                        feature relies on. If toolFeature is used, featureRefs
                        should not be used.
      suppressed:       (default=false) TRUE if the feature is suppressed in the
                        feature tree.
      editable:         (default=false) TRUE if any parameters of the feature
                        may be edited.
      featureRefs:      References the operand features of a set operation, when
                        it is commutative. If featureRefs is used, targetFeature
                        and toolFeature should not be used.

      Elements:

      Type:             (1) element describing the type of feature. This is an
                        application specific type. The receiving application is
                        not meant to deduce or interpret the type but could use
                        it to classify or group the feature.
      Parameter:        (0 or many) elements to describe the parameters
                        associated with the  feature. It is up to the
                        application to decide what parameters to exchange or
                        describe within the feature description.
      EntityRef:        (0 or many) references to entities on another
                        representation (e.g. a BRep) expressed as PLMXML
                        references.
      FeatureOccurrence: Occurrences of Features.
      
\endverbatim
*/
class PLMXML60_API Feature : public GDE
{
public:
     
    //! Default constructor
    Feature( );
     
    //! Constructs a Feature with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Feature( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Feature();

private:

	//! Assignment operator
	Feature& operator=( const Feature& iSrc );

	//! Copy constructor
	Feature( const Feature& original );
     
public:

	//! Set reference to NextFeature using 'arg's plmxml_api::Id.
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical SetNextFeatureRef( plmxml60::IdObject *arg );

	//! Clear reference to NextFeature
	void RemoveNextFeatureRef( );

	//! Find a plmxml60::IdObject referenced by NextFeature
	plmxml60::IdObject *ResolveNextFeatureRef( plmxml_api::Configuration* config = NULL );

	//! Get NextFeature reference
	plmxml_api::String GetNextFeatureId() const;

	//! Set NextFeature reference.
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical SetNextFeatureId( const plmxml_api::String& u );
	
	//! Check if NextFeature is set
	plmxml_api::logical HasNextFeatureRef( ) const;

	//! Set reference to TargetFeature using 'arg's plmxml_api::Id.
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical SetTargetFeatureRef( plmxml60::IdObject *arg );

	//! Clear reference to TargetFeature
	void RemoveTargetFeatureRef( );

	//! Find a plmxml60::IdObject referenced by TargetFeature
	plmxml60::IdObject *ResolveTargetFeatureRef( plmxml_api::Configuration* config = NULL );

	//! Get TargetFeature reference
	plmxml_api::String GetTargetFeatureId() const;

	//! Set TargetFeature reference.
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical SetTargetFeatureId( const plmxml_api::String& u );
	
	//! Check if TargetFeature is set
	plmxml_api::logical HasTargetFeatureRef( ) const;

	//! Set Editable
	plmxml_api::Result SetEditable( plmxml_api::logical arg );

	//! Get Editable
	plmxml_api::logical GetEditable() const;

	//! Check if Editable is set
	plmxml_api::logical HasEditable() const;

	//! Unset Editable
	plmxml_api::Result UnsetEditable();

	//! Set Suppressed
	plmxml_api::Result SetSuppressed( plmxml_api::logical arg );

	//! Get Suppressed
	plmxml_api::logical GetSuppressed() const;

	//! Check if Suppressed is set
	plmxml_api::logical HasSuppressed() const;

	//! Unset Suppressed
	plmxml_api::Result UnsetSuppressed();

	//! Set reference to ToolFeature using 'arg's plmxml_api::Id.
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical SetToolFeatureRef( plmxml60::IdObject *arg );

	//! Clear reference to ToolFeature
	void RemoveToolFeatureRef( );

	//! Find a plmxml60::IdObject referenced by ToolFeature
	plmxml60::IdObject *ResolveToolFeatureRef( plmxml_api::Configuration* config = NULL );

	//! Get ToolFeature reference
	plmxml_api::String GetToolFeatureId() const;

	//! Set ToolFeature reference.
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical SetToolFeatureId( const plmxml_api::String& u );
	
	//! Check if ToolFeature is set
	plmxml_api::logical HasToolFeatureRef( ) const;

	//! Get number of URIs in Feature
	int NumberOfFeatureURIs() const;

	//! Get i'th URI in Feature
	plmxml_api::String GetFeatureURI( int i ) const;

	//! Add a URI to Feature array. Call ResolveFeatureURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddFeatureURI( const plmxml_api::String& u );

	//! Set i'th URI in Feature array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetFeatureURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Feature URI. Does not resolve the URI.
	plmxml_api::Result GetFeatureURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Feature array.
	plmxml_api::Result AddFeatureURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Feature array to point to 'handle'.
	plmxml_api::Result SetFeatureURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Feature points to.
	plmxml_api::Result ResolveFeatureURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Feature array.
	plmxml_api::Result DeleteFeatureURI( int i );

	//! Remove all URIs from Feature array.
	plmxml_api::Result DeleteFeatureURIs( );
	
	//! Check if Feature is set
	plmxml_api::logical HasFeatureURIs( ) const;

	//! Add Type child element to this Feature. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	UserEnum *AddType();
     
	//! Set Type child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetType( UserEnum *arg );
     
	//! Get Type child element of this Feature.
	UserEnum *GetType() const;
     
	//! Detach and delete Type child element tree from this Feature.
	void DeleteType();

	//! Add Parameter child element to this Feature. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	UserValue *AddParameter();
     
	//! Add 'arg' as Parameter child element to this Feature.
	plmxml_api::Result AddParameter( UserValue *arg );

	//! Detach and delete all Parameter child elements.
	void DeleteParameters();
     
	//! Get number of Parameter child elements.
	int NumberOfParameters() const;
     
	//! Get i'th Parameter child element.
	UserValue *GetParameter( int i ) const;
     
	//! Get all Parameter child element as an array
	void GetParameters( plmxml_api::Array<UserValue*> &array ) const;
	     
	//! Detach and delete i'th Parameter child element
	void DeleteParameter( int i );
     
	//! Detach and delete 'arg' if it's one of the Parameter child elements
	void DeleteParameter( UserValue *arg );

	//! Add FeatureOccurrence child element to this Feature. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	FeatureOccurrence *AddFeatureOccurrence();
     
	//! Add 'arg' as FeatureOccurrence child element to this Feature.
	plmxml_api::Result AddFeatureOccurrence( FeatureOccurrence *arg );

	//! Detach and delete all FeatureOccurrence child elements.
	void DeleteFeatureOccurrences();
     
	//! Get number of FeatureOccurrence child elements.
	int NumberOfFeatureOccurrences() const;
     
	//! Get i'th FeatureOccurrence child element.
	FeatureOccurrence *GetFeatureOccurrence( int i ) const;
     
	//! Get all FeatureOccurrence child element as an array
	void GetFeatureOccurrences( plmxml_api::Array<FeatureOccurrence*> &array ) const;
	     
	//! Detach and delete i'th FeatureOccurrence child element
	void DeleteFeatureOccurrence( int i );
     
	//! Detach and delete 'arg' if it's one of the FeatureOccurrence child elements
	void DeleteFeatureOccurrence( FeatureOccurrence *arg );

	//! Add Reference child element to this Feature. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	GDEReference *AddReference();
     
	//! Add 'arg' as Reference child element to this Feature.
	plmxml_api::Result AddReference( GDEReference *arg );

	//! Detach and delete all Reference child elements.
	void DeleteReferences();
     
	//! Get number of Reference child elements.
	int NumberOfReferences() const;
     
	//! Get i'th Reference child element.
	GDEReference *GetReference( int i ) const;
     
	//! Get all Reference child element as an array
	void GetReferences( plmxml_api::Array<GDEReference*> &array ) const;
	     
	//! Detach and delete i'th Reference child element
	void DeleteReference( int i );
     
	//! Detach and delete 'arg' if it's one of the Reference child elements
	void DeleteReference( GDEReference *arg );

	//! Add EntityRef child element to this Feature. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	EntityRef *AddEntityRef();
     
	//! Add 'arg' as EntityRef child element to this Feature.
	plmxml_api::Result AddEntityRef( EntityRef *arg );

	//! Detach and delete all EntityRef child elements.
	void DeleteEntityRefs();
     
	//! Get number of EntityRef child elements.
	int NumberOfEntityRefs() const;
     
	//! Get i'th EntityRef child element.
	EntityRef *GetEntityRef( int i ) const;
     
	//! Get all EntityRef child element as an array
	void GetEntityRefs( plmxml_api::Array<EntityRef*> &array ) const;
	     
	//! Detach and delete i'th EntityRef child element
	void DeleteEntityRef( int i );
     
	//! Detach and delete 'arg' if it's one of the EntityRef child elements
	void DeleteEntityRef( EntityRef *arg );
 
// <PLMXML_UserCode type="functionHeaderFeature" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassFeature;


////////////////////////////////////////////////////////////////////////////////////
//! EnumFeature class
/*!
\verbatim

      Generic feature element which can be used to enumerate
      'any' parameterised feature. No semantic or specialised 
      information is exchanged via this schema.
      
\endverbatim
*/
class PLMXML60_API EnumFeature : public Feature
{
public:
     
    //! Default constructor
    EnumFeature( );
     
    //! Constructs a EnumFeature with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    EnumFeature( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~EnumFeature();

private:

	//! Assignment operator
	EnumFeature& operator=( const EnumFeature& iSrc );

	//! Copy constructor
	EnumFeature( const EnumFeature& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderEnumFeature" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassEnumFeature;


//! Forward class declarations
class FeatureInstance;

////////////////////////////////////////////////////////////////////////////////////
//! FeatureTree class
/*!
\verbatim

      This datatype describes a feature hierarchy for feature based
      modelling system.
  
      The feature hierarchy is represented via a single linked list of
      set of feature elements that reference the next feature in the 
      hieratchy. The linked list hierachy must describe the features
      in 'replay' order (ie. first operation first in the hierachy).
      There is scope to describe 'tree-like' dependencies via additional
      'dependentFeatures' reference attributes. 
  
      The feature tree is represented within PLMXML as an 'Internal Representation'
      - the FeatureTreeType is based on InternalRepBase and the 
      element FeatureTree is a substitution class for InternalRep.

      Attributes:

      firstFeature   - (optional) the XML id of the first feature in the 
                       feature hierarchy.
      editable       - (optional) TRUE if any features of the feature tree 
                       may be edited.

      Elements:

      Type           - (1) element describing the type of feature tree. This is an 
                       application specific type. The receiving application is not 
                       meant to deduce or interpret the type but could use it to 
                       classify feature tree.

      Feature        - (0 or many) the list of features that make up the feature tree.

      FeatureInstance:  Instances of Features.
      
\endverbatim
*/
class PLMXML60_API FeatureTree : public InternalRep
{
public:
     
    //! Default constructor
    FeatureTree( );
     
    //! Constructs a FeatureTree with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    FeatureTree( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~FeatureTree();

private:

	//! Assignment operator
	FeatureTree& operator=( const FeatureTree& iSrc );

	//! Copy constructor
	FeatureTree( const FeatureTree& original );
     
public:

	//! Set reference to FirstFeature using 'arg's plmxml_api::Id.
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical SetFirstFeatureRef( plmxml60::IdObject *arg );

	//! Clear reference to FirstFeature
	void RemoveFirstFeatureRef( );

	//! Find a plmxml60::IdObject referenced by FirstFeature
	plmxml60::IdObject *ResolveFirstFeatureRef( plmxml_api::Configuration* config = NULL );

	//! Get FirstFeature reference
	plmxml_api::String GetFirstFeatureId() const;

	//! Set FirstFeature reference.
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical SetFirstFeatureId( const plmxml_api::String& u );
	
	//! Check if FirstFeature is set
	plmxml_api::logical HasFirstFeatureRef( ) const;

	//! Set Editable
	plmxml_api::Result SetEditable( plmxml_api::logical arg );

	//! Get Editable
	plmxml_api::logical GetEditable() const;

	//! Check if Editable is set
	plmxml_api::logical HasEditable() const;

	//! Unset Editable
	plmxml_api::Result UnsetEditable();

	//! Add Type child element to this FeatureTree. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	UserEnum *AddType();
     
	//! Set Type child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetType( UserEnum *arg );
     
	//! Get Type child element of this FeatureTree.
	UserEnum *GetType() const;
     
	//! Detach and delete Type child element tree from this FeatureTree.
	void DeleteType();

	//! Add Feature child element to this FeatureTree. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Feature *AddFeature();
     
	//! Add 'arg' as Feature child element to this FeatureTree.
	plmxml_api::Result AddFeature( Feature *arg );

	//! Detach and delete all Feature child elements.
	void DeleteFeatures();
     
	//! Get number of Feature child elements.
	int NumberOfFeatures() const;
     
	//! Get i'th Feature child element.
	Feature *GetFeature( int i ) const;
     
	//! Get all Feature child element as an array
	void GetFeatures( plmxml_api::Array<Feature*> &array ) const;
	     
	//! Detach and delete i'th Feature child element
	void DeleteFeature( int i );
     
	//! Detach and delete 'arg' if it's one of the Feature child elements
	void DeleteFeature( Feature *arg );

	//! Add FeatureInstance child element to this FeatureTree. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	FeatureInstance *AddFeatureInstance();
     
	//! Add 'arg' as FeatureInstance child element to this FeatureTree.
	plmxml_api::Result AddFeatureInstance( FeatureInstance *arg );

	//! Detach and delete all FeatureInstance child elements.
	void DeleteFeatureInstances();
     
	//! Get number of FeatureInstance child elements.
	int NumberOfFeatureInstances() const;
     
	//! Get i'th FeatureInstance child element.
	FeatureInstance *GetFeatureInstance( int i ) const;
     
	//! Get all FeatureInstance child element as an array
	void GetFeatureInstances( plmxml_api::Array<FeatureInstance*> &array ) const;
	     
	//! Detach and delete i'th FeatureInstance child element
	void DeleteFeatureInstance( int i );
     
	//! Detach and delete 'arg' if it's one of the FeatureInstance child elements
	void DeleteFeatureInstance( FeatureInstance *arg );
 
// <PLMXML_UserCode type="functionHeaderFeatureTree" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassFeatureTree;


//! Forward class declarations
class VariantCondition;
class PropertyGroup;
class EntityPropertyGroup;
class DeterminedPropertyGroup;

////////////////////////////////////////////////////////////////////////////////////
//! StructureUsage class
/*!
\verbatim

      A base type for a usage relation between Structure, StructureRevision and
      StructureRevisionView elements.

      Attributes:

      instancedRef     Reference to the 'used' element. This should be derived from
                       StructureRevisionView, StructureRevision, StructureView, or
                       Structure, or GDE. In the latter cases some other context must determine
                       which view or revision is intended.

      partRef:         This attribute is retained for compatibility reasons and should
                       only be used for Product Structure, not general Structures.

      transformRef:    optional Transform which positions the 'used' element in the
                       coordinates of the using one.

      materialRef:     reference to a Material element to use when displaying the 'used'
                       element.
      propertyRefs:    reference to properties

      representationRefs: an optional collection of Representations of the 'used' element.
      designRequired:  true if the 'used' element must have at least one
                       corresponding element in the Design Structure.
      monolithic:      Whether the structure node is treated without sub-structure.

      Elements:

      Transform:       see transformRef. (This should not be used in conjunction with
                       transformRef).
      Representation:  see representationRefs
      VariantCondition:An optional VariantCondition

      Reference        Elements referenced by the StructureUsage. This enables the
                       representation of such relationships as "connected to", and
                       "implemented by".
      PropertyGroup    a group of Properties of the StructureUsage

      EntityPropertyGroup:  used to specify Properties of logical entities in the
                       referenced StructureRevisionView, in the context of the StructureUsage.
      DeterminedPropertyGroup: The StructureUsage Properties determined by a
                        specific method.
      
\endverbatim
*/
class PLMXML60_API StructureUsage : public Managed
{
public:
     
    //! Default constructor
    StructureUsage( );
     
    //! Constructs a StructureUsage with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    StructureUsage( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~StructureUsage();

private:

	//! Assignment operator
	StructureUsage& operator=( const StructureUsage& iSrc );

	//! Copy constructor
	StructureUsage( const StructureUsage& original );
     
public:

	//! Get Part URI as plmxml_api::String
	plmxml_api::String GetPartURI() const;

	//! Set Part URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetPartURI( const plmxml_api::String& );
	
	//! Get the handle of Part URI. Does not resolve the URI.
	plmxml_api::Result GetPartURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Part URI. URI string is unchanged.
	plmxml_api::Result SetPartURI( const plmxml_api::Handle& );
	
	//! Resolve Part URI and return an object (handle) it points to.
	plmxml_api::Result ResolvePartURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Part URI. Clears URI string and handle.
	plmxml_api::Result DeletePartURI();
	
	//! Check if Part URI is set
	plmxml_api::logical HasPartURI( ) const;
	

	//! Get Instanced URI as plmxml_api::String
	plmxml_api::String GetInstancedURI() const;

	//! Set Instanced URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetInstancedURI( const plmxml_api::String& );
	
	//! Get the handle of Instanced URI. Does not resolve the URI.
	plmxml_api::Result GetInstancedURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Instanced URI. URI string is unchanged.
	plmxml_api::Result SetInstancedURI( const plmxml_api::Handle& );
	
	//! Resolve Instanced URI and return an object (handle) it points to.
	plmxml_api::Result ResolveInstancedURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Instanced URI. Clears URI string and handle.
	plmxml_api::Result DeleteInstancedURI();
	
	//! Check if Instanced URI is set
	plmxml_api::logical HasInstancedURI( ) const;
	

	//! Get number of URIs in Representation
	int NumberOfRepresentationURIs() const;

	//! Get i'th URI in Representation
	plmxml_api::String GetRepresentationURI( int i ) const;

	//! Add a URI to Representation array. Call ResolveRepresentationURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddRepresentationURI( const plmxml_api::String& u );

	//! Set i'th URI in Representation array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetRepresentationURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Representation URI. Does not resolve the URI.
	plmxml_api::Result GetRepresentationURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Representation array.
	plmxml_api::Result AddRepresentationURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Representation array to point to 'handle'.
	plmxml_api::Result SetRepresentationURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Representation points to.
	plmxml_api::Result ResolveRepresentationURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Representation array.
	plmxml_api::Result DeleteRepresentationURI( int i );

	//! Remove all URIs from Representation array.
	plmxml_api::Result DeleteRepresentationURIs( );
	
	//! Check if Representation is set
	plmxml_api::logical HasRepresentationURIs( ) const;

	//! Set DesignRequired
	plmxml_api::Result SetDesignRequired( plmxml_api::logical arg );

	//! Get DesignRequired
	plmxml_api::logical GetDesignRequired() const;

	//! Check if DesignRequired is set
	plmxml_api::logical HasDesignRequired() const;

	//! Unset DesignRequired
	plmxml_api::Result UnsetDesignRequired();

	//! Set Monolithic
	plmxml_api::Result SetMonolithic( plmxml_api::logical arg );

	//! Get Monolithic
	plmxml_api::logical GetMonolithic() const;

	//! Check if Monolithic is set
	plmxml_api::logical HasMonolithic() const;

	//! Unset Monolithic
	plmxml_api::Result UnsetMonolithic();

	//! Set reference to Material using 'arg's plmxml_api::Id.
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical SetMaterialRef( plmxml60::IdObject *arg );

	//! Clear reference to Material
	void RemoveMaterialRef( );

	//! Find a plmxml60::IdObject referenced by Material
	plmxml60::IdObject *ResolveMaterialRef( plmxml_api::Configuration* config = NULL );

	//! Get Material reference
	plmxml_api::String GetMaterialId() const;

	//! Set Material reference.
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical SetMaterialId( const plmxml_api::String& u );
	
	//! Check if Material is set
	plmxml_api::logical HasMaterialRef( ) const;

	//! Set reference to Transform using 'arg's plmxml_api::Id.
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical SetTransformRef( plmxml60::IdObject *arg );

	//! Clear reference to Transform
	void RemoveTransformRef( );

	//! Find a plmxml60::IdObject referenced by Transform
	plmxml60::IdObject *ResolveTransformRef( plmxml_api::Configuration* config = NULL );

	//! Get Transform reference
	plmxml_api::String GetTransformId() const;

	//! Set Transform reference.
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical SetTransformId( const plmxml_api::String& u );
	
	//! Check if Transform is set
	plmxml_api::logical HasTransformRef( ) const;

	//! Get number of URIs in Property
	int NumberOfPropertyURIs() const;

	//! Get i'th URI in Property
	plmxml_api::String GetPropertyURI( int i ) const;

	//! Add a URI to Property array. Call ResolvePropertyURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddPropertyURI( const plmxml_api::String& u );

	//! Set i'th URI in Property array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetPropertyURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Property URI. Does not resolve the URI.
	plmxml_api::Result GetPropertyURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Property array.
	plmxml_api::Result AddPropertyURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Property array to point to 'handle'.
	plmxml_api::Result SetPropertyURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Property points to.
	plmxml_api::Result ResolvePropertyURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Property array.
	plmxml_api::Result DeletePropertyURI( int i );

	//! Remove all URIs from Property array.
	plmxml_api::Result DeletePropertyURIs( );
	
	//! Check if Property is set
	plmxml_api::logical HasPropertyURIs( ) const;

	//! Add Transform child element to this StructureUsage. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	Transform *AddTransform();
     
	//! Set Transform child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetTransform( Transform *arg );
     
	//! Get Transform child element of this StructureUsage.
	Transform *GetTransform() const;
     
	//! Detach and delete Transform child element tree from this StructureUsage.
	void DeleteTransform();

	//! Add Representation child element to this StructureUsage. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Representation *AddRepresentation();
     
	//! Add 'arg' as Representation child element to this StructureUsage.
	plmxml_api::Result AddRepresentation( Representation *arg );

	//! Detach and delete all Representation child elements.
	void DeleteRepresentations();
     
	//! Get number of Representation child elements.
	int NumberOfRepresentations() const;
     
	//! Get i'th Representation child element.
	Representation *GetRepresentation( int i ) const;
     
	//! Get all Representation child element as an array
	void GetRepresentations( plmxml_api::Array<Representation*> &array ) const;
	     
	//! Detach and delete i'th Representation child element
	void DeleteRepresentation( int i );
     
	//! Detach and delete 'arg' if it's one of the Representation child elements
	void DeleteRepresentation( Representation *arg );

	//! Add VariantCondition child element to this StructureUsage. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	VariantCondition *AddVariantCondition();
     
	//! Set VariantCondition child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetVariantCondition( VariantCondition *arg );
     
	//! Get VariantCondition child element of this StructureUsage.
	VariantCondition *GetVariantCondition() const;
     
	//! Detach and delete VariantCondition child element tree from this StructureUsage.
	void DeleteVariantCondition();

	//! Add Reference child element to this StructureUsage. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	GDEReference *AddReference();
     
	//! Add 'arg' as Reference child element to this StructureUsage.
	plmxml_api::Result AddReference( GDEReference *arg );

	//! Detach and delete all Reference child elements.
	void DeleteReferences();
     
	//! Get number of Reference child elements.
	int NumberOfReferences() const;
     
	//! Get i'th Reference child element.
	GDEReference *GetReference( int i ) const;
     
	//! Get all Reference child element as an array
	void GetReferences( plmxml_api::Array<GDEReference*> &array ) const;
	     
	//! Detach and delete i'th Reference child element
	void DeleteReference( int i );
     
	//! Detach and delete 'arg' if it's one of the Reference child elements
	void DeleteReference( GDEReference *arg );

	//! Add PropertyGroup child element to this StructureUsage. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	PropertyGroup *AddPropertyGroup();
     
	//! Set PropertyGroup child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetPropertyGroup( PropertyGroup *arg );
     
	//! Get PropertyGroup child element of this StructureUsage.
	PropertyGroup *GetPropertyGroup() const;
     
	//! Detach and delete PropertyGroup child element tree from this StructureUsage.
	void DeletePropertyGroup();

	//! Add EntityPropertyGroup child element to this StructureUsage. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	EntityPropertyGroup *AddEntityPropertyGroup();
     
	//! Add 'arg' as EntityPropertyGroup child element to this StructureUsage.
	plmxml_api::Result AddEntityPropertyGroup( EntityPropertyGroup *arg );

	//! Detach and delete all EntityPropertyGroup child elements.
	void DeleteEntityPropertyGroups();
     
	//! Get number of EntityPropertyGroup child elements.
	int NumberOfEntityPropertyGroups() const;
     
	//! Get i'th EntityPropertyGroup child element.
	EntityPropertyGroup *GetEntityPropertyGroup( int i ) const;
     
	//! Get all EntityPropertyGroup child element as an array
	void GetEntityPropertyGroups( plmxml_api::Array<EntityPropertyGroup*> &array ) const;
	     
	//! Detach and delete i'th EntityPropertyGroup child element
	void DeleteEntityPropertyGroup( int i );
     
	//! Detach and delete 'arg' if it's one of the EntityPropertyGroup child elements
	void DeleteEntityPropertyGroup( EntityPropertyGroup *arg );

	//! Add DeterminedPropertyGroup child element to this StructureUsage. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	DeterminedPropertyGroup *AddDeterminedPropertyGroup();
     
	//! Set DeterminedPropertyGroup child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetDeterminedPropertyGroup( DeterminedPropertyGroup *arg );
     
	//! Get DeterminedPropertyGroup child element of this StructureUsage.
	DeterminedPropertyGroup *GetDeterminedPropertyGroup() const;
     
	//! Detach and delete DeterminedPropertyGroup child element tree from this StructureUsage.
	void DeleteDeterminedPropertyGroup();
 
// <PLMXML_UserCode type="functionHeaderStructureUsage" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassStructureUsage;


////////////////////////////////////////////////////////////////////////////////////
//! AttributeContext class
/*!
\verbatim

      An AttributeContext element specifies the source for an overridden Occurrence 
      attribute or property (e.g. quantity, Transform). An Occurrence attribute or 
      property can be overridden in various ways, for example in the context of a 
      higher-level Occurrence. The AttributeContext is not intended to describe the 
      override mechanism - it simply indicates the context object which was responsible 
      for the override.
      
      Attributes:
      
      attributeName:   The name of the (xml) attribute being overridden, if appropriate.
      targetRef:       The element which carries the attribute being overridden.
      contextRef:      The context element, for example a higher-level Occurrence.
      changeRef:       A reference to an element representing a Change which caused this
                       attribute to be overridden.
      
\endverbatim
*/
class PLMXML60_API AttributeContext : public IdObject
{
public:
     
    //! Default constructor
    AttributeContext( );
     
    //! Constructs a AttributeContext with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    AttributeContext( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~AttributeContext();

private:

	//! Assignment operator
	AttributeContext& operator=( const AttributeContext& iSrc );

	//! Copy constructor
	AttributeContext( const AttributeContext& original );
     
public:

	//! Get Change URI as plmxml_api::String
	plmxml_api::String GetChangeURI() const;

	//! Set Change URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetChangeURI( const plmxml_api::String& );
	
	//! Get the handle of Change URI. Does not resolve the URI.
	plmxml_api::Result GetChangeURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Change URI. URI string is unchanged.
	plmxml_api::Result SetChangeURI( const plmxml_api::Handle& );
	
	//! Resolve Change URI and return an object (handle) it points to.
	plmxml_api::Result ResolveChangeURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Change URI. Clears URI string and handle.
	plmxml_api::Result DeleteChangeURI();
	
	//! Check if Change URI is set
	plmxml_api::logical HasChangeURI( ) const;
	

	//! Get Target URI as plmxml_api::String
	plmxml_api::String GetTargetURI() const;

	//! Set Target URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetTargetURI( const plmxml_api::String& );
	
	//! Get the handle of Target URI. Does not resolve the URI.
	plmxml_api::Result GetTargetURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Target URI. URI string is unchanged.
	plmxml_api::Result SetTargetURI( const plmxml_api::Handle& );
	
	//! Resolve Target URI and return an object (handle) it points to.
	plmxml_api::Result ResolveTargetURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Target URI. Clears URI string and handle.
	plmxml_api::Result DeleteTargetURI();
	
	//! Check if Target URI is set
	plmxml_api::logical HasTargetURI( ) const;
	

	//! Get AttributeName of this AttributeContext
	plmxml_api::String GetAttributeName() const;

	//! Set AttributeName of this AttributeContext
	plmxml_api::Result SetAttributeName( const plmxml_api::String &s );
	
	//! Check if AttributeName is set
	plmxml_api::logical HasAttributeName( ) const;
	
	//! Unset AttributeName
	plmxml_api::Result UnsetAttributeName( );

	//! Get Context URI as plmxml_api::String
	plmxml_api::String GetContextURI() const;

	//! Set Context URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetContextURI( const plmxml_api::String& );
	
	//! Get the handle of Context URI. Does not resolve the URI.
	plmxml_api::Result GetContextURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Context URI. URI string is unchanged.
	plmxml_api::Result SetContextURI( const plmxml_api::Handle& );
	
	//! Resolve Context URI and return an object (handle) it points to.
	plmxml_api::Result ResolveContextURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Context URI. Clears URI string and handle.
	plmxml_api::Result DeleteContextURI();
	
	//! Check if Context URI is set
	plmxml_api::logical HasContextURI( ) const;
	
 
// <PLMXML_UserCode type="functionHeaderAttributeContext" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassAttributeContext;


//! Forward class declarations
class AssociatedAttachment;

////////////////////////////////////////////////////////////////////////////////////
//! Occurrence class
/*!
\verbatim

      Occurrence. An Occurrence specifies a usage of a Structure, StructureRevision, or
      StructureRevisionView in an Assembly. The usage is defined by specifying a chain of 
      Instances which lead from the Assembly down to the Structure, or by a chain of 
      Instances and other Occurrences, which when joined together define an Instance
      chain. It is also possible for an Occurrence to reference a ProductView at the end
      of its Instance chain, rather than a Structure.

      The Assembly, which is the parent of the first Instance in the Instance chain, is
      called the 'top Structure' of the Occurrence. The Structure, which is instanced by
      the last Instance in the Instance chain, is called the 'bottom Structure' of the
      Occurrence.

      Note that the following inherited attributes on an Occurrence override the
      attributes of the same name on the last Instance of the Instance chain:

        materialRef
        instancedRef
        partRef
        representationRefs

      In addition, the 'transformRef' attribute overrides the transform
      obtained by accumulating the transforms in the Instance chain. 

      Attributes:

      instanceRefs:   chain of Instances which define the Occurrence. (May end in a
                      GDEInstanceGroup).
      pathRefs:       chain of Instances and Occurrences which, when joined together,
                      define an Instance chain. Only one of instanceRefs and pathRefs
                      should be present.

      geometryRefs:   optional geometry associated with this Occurrence.

      occurrenceRefs: an Occurrence may have a number of 'child' Occurrences, which this 
                      attribute specifies. A child Occurrence must have an Instance chain
                      which is the same as that of its parent, but with one more Instance
                      added at the bottom end. An Occurrence is normally only rendered in
                      a view if it has no child Occurrences.

      alternativeOfRef: It is possible for one ProductView to be defined by reference to
                      another ProductView. In this case the first ProductView will
                      contain some Occurrences which override Occurrences in the
                      referenced ProductView. The 'alternativeOfRef' attribute is used to
                      indicate the Occurrence which this Occurrence is overriding. If an
                      Occurrence has an alternativeOfRef attribute, it should not also
                      have an instanceRefs attribute, nor should it have an 
                      occurrenceRefs attribute.

      productViewRef: If an Occurrence has a productViewRef, then it is regarded as an
                      Occurrence of that ProductView, not of its 'bottom Structure'. In
                      this case, the 'top Structure' of the ProductView must be the same
                      as the 'bottom Structure' of the Occurrence. 

      visible:        Flag to indicate the Occurrence is visible. If absent, visible is
                      implied. An Occurrence which references another Occurrence via the
                      alternativeOfRef attribute may override its visibility, i.e. make
                      it visible if invisible or vice-versa. NB This is deprecated -
                      use a Visibility Property instead. 

      lastInstanceParentRef: This is the StructureRevisionView which is the parent of the
                      last Instance in the chain. Although this is implied by the last
                      Instance in the chain, it can be specified explicitly with this
                      attribute, either for convenience, or in the case where
                      instanceRefs is absent.

      sourceRef:      A reference to the InstancePath to which this corresponds (which 
                      will have the same instance path as this Occurrence). 
                      
      linkedOccurrenceRef:  In a Composition ProductView, this attribute references an 
                      Occurrence or ConfiguredOccurrenceGroup in a referenced ProductView. 
                      It indicates that this Occurrence should be treated as an Occurrence
                      not of an entire ProductRevisionView, but only of the specified
                      Occurrence(s).
                       
      linkedGroupRef: A reference to a ConfiguredOccurrenceGroup. This corresponds to the
                      group referenced by 'linkedOccurrenceRef', but contains Occurrences
                      in the Composition ProductView.


      associatedAttachmentRefs: reference to any associated attachments. These are the
                      direct attachments of this Occurrence - any sub-attachments will be
                      referenced by those attachments.

      parentRef:      This is an optional back-pointer reference to a parent Occurrence,
                      which references this Occurrence through its 'occurrenceRefs'
                      attribute.

      instanceNumber  A number, or index. This is only relevant when the last Instance
                      in the path is a GDEInstance.
                      
      occurrenceId:   ID for the Occurrence, unique in the context of the top-level 
                      Structure of the Occurrence.
                      
      controlRefs:    The OccurrenceControlRevision objects controlling this occurrence, if any
      symbolicRefs:   the child SymbolicOccurrences

      Elements: 

      Material:
      EntityMaterial: Allows the association of a Material with an entity; for example
                      the Occurrence could specify the colour of a face of a body. The
                      entity should be in a Representation specified by this Occurrence,
                      or by the last Instance in the Instance chain, or by the 'bottom
                      Structure' of the Occurrence.

      AssociatedAttachment
      
      AttributeContext: Used to specify the source of any overridden attributes or
                      properties of this Occurrence.
      
\endverbatim
*/
class PLMXML60_API Occurrence : public StructureUsage
{
public:
     
    //! Default constructor
    Occurrence( );
     
    //! Constructs a Occurrence with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Occurrence( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Occurrence();

private:

	//! Assignment operator
	Occurrence& operator=( const Occurrence& iSrc );

	//! Copy constructor
	Occurrence( const Occurrence& original );
     
public:

	//! Get number of URIs in AssociatedAttachment
	int NumberOfAssociatedAttachmentURIs() const;

	//! Get i'th URI in AssociatedAttachment
	plmxml_api::String GetAssociatedAttachmentURI( int i ) const;

	//! Add a URI to AssociatedAttachment array. Call ResolveAssociatedAttachmentURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddAssociatedAttachmentURI( const plmxml_api::String& u );

	//! Set i'th URI in AssociatedAttachment array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetAssociatedAttachmentURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of AssociatedAttachment URI. Does not resolve the URI.
	plmxml_api::Result GetAssociatedAttachmentURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to AssociatedAttachment array.
	plmxml_api::Result AddAssociatedAttachmentURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in AssociatedAttachment array to point to 'handle'.
	plmxml_api::Result SetAssociatedAttachmentURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in AssociatedAttachment points to.
	plmxml_api::Result ResolveAssociatedAttachmentURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from AssociatedAttachment array.
	plmxml_api::Result DeleteAssociatedAttachmentURI( int i );

	//! Remove all URIs from AssociatedAttachment array.
	plmxml_api::Result DeleteAssociatedAttachmentURIs( );
	
	//! Check if AssociatedAttachment is set
	plmxml_api::logical HasAssociatedAttachmentURIs( ) const;

	//! Get LinkedGroup URI as plmxml_api::String
	plmxml_api::String GetLinkedGroupURI() const;

	//! Set LinkedGroup URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetLinkedGroupURI( const plmxml_api::String& );
	
	//! Get the handle of LinkedGroup URI. Does not resolve the URI.
	plmxml_api::Result GetLinkedGroupURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of LinkedGroup URI. URI string is unchanged.
	plmxml_api::Result SetLinkedGroupURI( const plmxml_api::Handle& );
	
	//! Resolve LinkedGroup URI and return an object (handle) it points to.
	plmxml_api::Result ResolveLinkedGroupURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset LinkedGroup URI. Clears URI string and handle.
	plmxml_api::Result DeleteLinkedGroupURI();
	
	//! Check if LinkedGroup URI is set
	plmxml_api::logical HasLinkedGroupURI( ) const;
	

	//! Get Source URI as plmxml_api::String
	plmxml_api::String GetSourceURI() const;

	//! Set Source URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetSourceURI( const plmxml_api::String& );
	
	//! Get the handle of Source URI. Does not resolve the URI.
	plmxml_api::Result GetSourceURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Source URI. URI string is unchanged.
	plmxml_api::Result SetSourceURI( const plmxml_api::Handle& );
	
	//! Resolve Source URI and return an object (handle) it points to.
	plmxml_api::Result ResolveSourceURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Source URI. Clears URI string and handle.
	plmxml_api::Result DeleteSourceURI();
	
	//! Check if Source URI is set
	plmxml_api::logical HasSourceURI( ) const;
	

	//! Get AlternativeOf URI as plmxml_api::String
	plmxml_api::String GetAlternativeOfURI() const;

	//! Set AlternativeOf URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetAlternativeOfURI( const plmxml_api::String& );
	
	//! Get the handle of AlternativeOf URI. Does not resolve the URI.
	plmxml_api::Result GetAlternativeOfURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of AlternativeOf URI. URI string is unchanged.
	plmxml_api::Result SetAlternativeOfURI( const plmxml_api::Handle& );
	
	//! Resolve AlternativeOf URI and return an object (handle) it points to.
	plmxml_api::Result ResolveAlternativeOfURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset AlternativeOf URI. Clears URI string and handle.
	plmxml_api::Result DeleteAlternativeOfURI();
	
	//! Check if AlternativeOf URI is set
	plmxml_api::logical HasAlternativeOfURI( ) const;
	

	//! Get number of URIs in Instance
	int NumberOfInstanceURIs() const;

	//! Get i'th URI in Instance
	plmxml_api::String GetInstanceURI( int i ) const;

	//! Add a URI to Instance array. Call ResolveInstanceURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddInstanceURI( const plmxml_api::String& u );

	//! Set i'th URI in Instance array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetInstanceURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Instance URI. Does not resolve the URI.
	plmxml_api::Result GetInstanceURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Instance array.
	plmxml_api::Result AddInstanceURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Instance array to point to 'handle'.
	plmxml_api::Result SetInstanceURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Instance points to.
	plmxml_api::Result ResolveInstanceURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Instance array.
	plmxml_api::Result DeleteInstanceURI( int i );

	//! Remove all URIs from Instance array.
	plmxml_api::Result DeleteInstanceURIs( );
	
	//! Check if Instance is set
	plmxml_api::logical HasInstanceURIs( ) const;

	//! Get number of references in Occurrence array
	int NumberOfOccurrenceRefs() const;
     
	//! Add reference to 'arg' to Occurrence array
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical AddOccurrenceRef( plmxml60::IdObject *arg );
     
	//! Add reference to an object pointed to by 'u' to Occurrence array
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical AddOccurrenceId( const plmxml_api::String &u );
     
	//! Set i'th reference in Occurrence array to 'arg'
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical SetOccurrenceRef( int i, plmxml60::IdObject *arg );
     
	//! Set i'th reference in Occurrence array to an object pointed to by 'u'
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical SetOccurrenceId( int i, const plmxml_api::String &u );
     
	//! Resolve i'th reference in Occurrence array and return an object it points to.
	plmxml60::IdObject *ResolveOccurrenceRef( int i, plmxml_api::Configuration* config = NULL );
     
	//! Resolve all references in Occurrence array and return objects they point to.
	void ResolveOccurrenceRefs( plmxml_api::Array<plmxml60::IdObject *> & array, plmxml_api::Configuration* config = NULL );
     
	//! Get i'th reference in Occurrence array as plmxml_api::String
	plmxml_api::String GetOccurrenceId( int i ) const;
     
	//! Get all references in Occurrence array as an array of plmxml_api::String
	void GetOccurrenceIds( plmxml_api::Array<plmxml_api::String> &array ) const;
     
	//! Remove i'th reference from the Occurrence array.
	void RemoveOccurrenceRef( int i );
     
	//! Remove reference to an object pointed to by 'u' from the Occurrence array.
	void RemoveOccurrenceRef( const plmxml_api::String &u );
     
	//! Remove reference to 'arg' from the Occurrence array.
	void RemoveOccurrenceRef( plmxml60::IdObject *arg );
     
	//! Remove all references Occurrence array.
	void RemoveOccurrenceRefs();
	
	//! Check if Occurrence is set
	plmxml_api::logical HasOccurrenceRefs( ) const;

	//! Set InstanceNumber
	plmxml_api::Result SetInstanceNumber( int arg );
     
	//! Get InstanceNumber
	int GetInstanceNumber() const;
     
	//! Check if InstanceNumber is set
	plmxml_api::logical HasInstanceNumber() const;
     
	//! Unset InstanceNumber
	plmxml_api::Result UnsetInstanceNumber();

	//! Get number of URIs in Path
	int NumberOfPathURIs() const;

	//! Get i'th URI in Path
	plmxml_api::String GetPathURI( int i ) const;

	//! Add a URI to Path array. Call ResolvePathURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddPathURI( const plmxml_api::String& u );

	//! Set i'th URI in Path array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetPathURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Path URI. Does not resolve the URI.
	plmxml_api::Result GetPathURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Path array.
	plmxml_api::Result AddPathURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Path array to point to 'handle'.
	plmxml_api::Result SetPathURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Path points to.
	plmxml_api::Result ResolvePathURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Path array.
	plmxml_api::Result DeletePathURI( int i );

	//! Remove all URIs from Path array.
	plmxml_api::Result DeletePathURIs( );
	
	//! Check if Path is set
	plmxml_api::logical HasPathURIs( ) const;

	//! Get ProductView URI as plmxml_api::String
	plmxml_api::String GetProductViewURI() const;

	//! Set ProductView URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetProductViewURI( const plmxml_api::String& );
	
	//! Get the handle of ProductView URI. Does not resolve the URI.
	plmxml_api::Result GetProductViewURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of ProductView URI. URI string is unchanged.
	plmxml_api::Result SetProductViewURI( const plmxml_api::Handle& );
	
	//! Resolve ProductView URI and return an object (handle) it points to.
	plmxml_api::Result ResolveProductViewURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset ProductView URI. Clears URI string and handle.
	plmxml_api::Result DeleteProductViewURI();
	
	//! Check if ProductView URI is set
	plmxml_api::logical HasProductViewURI( ) const;
	

	//! Get number of URIs in Control
	int NumberOfControlURIs() const;

	//! Get i'th URI in Control
	plmxml_api::String GetControlURI( int i ) const;

	//! Add a URI to Control array. Call ResolveControlURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddControlURI( const plmxml_api::String& u );

	//! Set i'th URI in Control array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetControlURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Control URI. Does not resolve the URI.
	plmxml_api::Result GetControlURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Control array.
	plmxml_api::Result AddControlURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Control array to point to 'handle'.
	plmxml_api::Result SetControlURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Control points to.
	plmxml_api::Result ResolveControlURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Control array.
	plmxml_api::Result DeleteControlURI( int i );

	//! Remove all URIs from Control array.
	plmxml_api::Result DeleteControlURIs( );
	
	//! Check if Control is set
	plmxml_api::logical HasControlURIs( ) const;

	//! Get Parent URI as plmxml_api::String
	plmxml_api::String GetParentURI() const;

	//! Set Parent URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetParentURI( const plmxml_api::String& );
	
	//! Get the handle of Parent URI. Does not resolve the URI.
	plmxml_api::Result GetParentURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Parent URI. URI string is unchanged.
	plmxml_api::Result SetParentURI( const plmxml_api::Handle& );
	
	//! Resolve Parent URI and return an object (handle) it points to.
	plmxml_api::Result ResolveParentURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Parent URI. Clears URI string and handle.
	plmxml_api::Result DeleteParentURI();
	
	//! Check if Parent URI is set
	plmxml_api::logical HasParentURI( ) const;
	

	//! Get OccurrenceId of this Occurrence
	plmxml_api::String GetOccurrenceId() const;

	//! Set OccurrenceId of this Occurrence
	plmxml_api::Result SetOccurrenceId( const plmxml_api::String &s );
	
	//! Check if OccurrenceId is set
	plmxml_api::logical HasOccurrenceId( ) const;
	
	//! Unset OccurrenceId
	plmxml_api::Result UnsetOccurrenceId( );

	//! Get LastInstanceParent URI as plmxml_api::String
	plmxml_api::String GetLastInstanceParentURI() const;

	//! Set LastInstanceParent URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetLastInstanceParentURI( const plmxml_api::String& );
	
	//! Get the handle of LastInstanceParent URI. Does not resolve the URI.
	plmxml_api::Result GetLastInstanceParentURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of LastInstanceParent URI. URI string is unchanged.
	plmxml_api::Result SetLastInstanceParentURI( const plmxml_api::Handle& );
	
	//! Resolve LastInstanceParent URI and return an object (handle) it points to.
	plmxml_api::Result ResolveLastInstanceParentURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset LastInstanceParent URI. Clears URI string and handle.
	plmxml_api::Result DeleteLastInstanceParentURI();
	
	//! Check if LastInstanceParent URI is set
	plmxml_api::logical HasLastInstanceParentURI( ) const;
	

	//! Get number of URIs in Geometry
	int NumberOfGeometryURIs() const;

	//! Get i'th URI in Geometry
	plmxml_api::String GetGeometryURI( int i ) const;

	//! Add a URI to Geometry array. Call ResolveGeometryURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddGeometryURI( const plmxml_api::String& u );

	//! Set i'th URI in Geometry array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetGeometryURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Geometry URI. Does not resolve the URI.
	plmxml_api::Result GetGeometryURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Geometry array.
	plmxml_api::Result AddGeometryURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Geometry array to point to 'handle'.
	plmxml_api::Result SetGeometryURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Geometry points to.
	plmxml_api::Result ResolveGeometryURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Geometry array.
	plmxml_api::Result DeleteGeometryURI( int i );

	//! Remove all URIs from Geometry array.
	plmxml_api::Result DeleteGeometryURIs( );
	
	//! Check if Geometry is set
	plmxml_api::logical HasGeometryURIs( ) const;

	//! Set Visible
	plmxml_api::Result SetVisible( plmxml_api::logical arg );

	//! Get Visible
	plmxml_api::logical GetVisible() const;

	//! Check if Visible is set
	plmxml_api::logical HasVisible() const;

	//! Unset Visible
	plmxml_api::Result UnsetVisible();

	//! Get number of URIs in Symbolic
	int NumberOfSymbolicURIs() const;

	//! Get i'th URI in Symbolic
	plmxml_api::String GetSymbolicURI( int i ) const;

	//! Add a URI to Symbolic array. Call ResolveSymbolicURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddSymbolicURI( const plmxml_api::String& u );

	//! Set i'th URI in Symbolic array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetSymbolicURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Symbolic URI. Does not resolve the URI.
	plmxml_api::Result GetSymbolicURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Symbolic array.
	plmxml_api::Result AddSymbolicURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Symbolic array to point to 'handle'.
	plmxml_api::Result SetSymbolicURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Symbolic points to.
	plmxml_api::Result ResolveSymbolicURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Symbolic array.
	plmxml_api::Result DeleteSymbolicURI( int i );

	//! Remove all URIs from Symbolic array.
	plmxml_api::Result DeleteSymbolicURIs( );
	
	//! Check if Symbolic is set
	plmxml_api::logical HasSymbolicURIs( ) const;

	//! Get LinkedOccurrence URI as plmxml_api::String
	plmxml_api::String GetLinkedOccurrenceURI() const;

	//! Set LinkedOccurrence URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetLinkedOccurrenceURI( const plmxml_api::String& );
	
	//! Get the handle of LinkedOccurrence URI. Does not resolve the URI.
	plmxml_api::Result GetLinkedOccurrenceURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of LinkedOccurrence URI. URI string is unchanged.
	plmxml_api::Result SetLinkedOccurrenceURI( const plmxml_api::Handle& );
	
	//! Resolve LinkedOccurrence URI and return an object (handle) it points to.
	plmxml_api::Result ResolveLinkedOccurrenceURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset LinkedOccurrence URI. Clears URI string and handle.
	plmxml_api::Result DeleteLinkedOccurrenceURI();
	
	//! Check if LinkedOccurrence URI is set
	plmxml_api::logical HasLinkedOccurrenceURI( ) const;
	

	//! Add Material child element to this Occurrence. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Material *AddMaterial();
     
	//! Add 'arg' as Material child element to this Occurrence.
	plmxml_api::Result AddMaterial( Material *arg );

	//! Detach and delete all Material child elements.
	void DeleteMaterials();
     
	//! Get number of Material child elements.
	int NumberOfMaterials() const;
     
	//! Get i'th Material child element.
	Material *GetMaterial( int i ) const;
     
	//! Get all Material child element as an array
	void GetMaterials( plmxml_api::Array<Material*> &array ) const;
	     
	//! Detach and delete i'th Material child element
	void DeleteMaterial( int i );
     
	//! Detach and delete 'arg' if it's one of the Material child elements
	void DeleteMaterial( Material *arg );

	//! Add EntityMaterial child element to this Occurrence. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	EntityMaterial *AddEntityMaterial();
     
	//! Add 'arg' as EntityMaterial child element to this Occurrence.
	plmxml_api::Result AddEntityMaterial( EntityMaterial *arg );

	//! Detach and delete all EntityMaterial child elements.
	void DeleteEntityMaterials();
     
	//! Get number of EntityMaterial child elements.
	int NumberOfEntityMaterials() const;
     
	//! Get i'th EntityMaterial child element.
	EntityMaterial *GetEntityMaterial( int i ) const;
     
	//! Get all EntityMaterial child element as an array
	void GetEntityMaterials( plmxml_api::Array<EntityMaterial*> &array ) const;
	     
	//! Detach and delete i'th EntityMaterial child element
	void DeleteEntityMaterial( int i );
     
	//! Detach and delete 'arg' if it's one of the EntityMaterial child elements
	void DeleteEntityMaterial( EntityMaterial *arg );

	//! Add AssociatedAttachment child element to this Occurrence. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	AssociatedAttachment *AddAssociatedAttachment();
     
	//! Add 'arg' as AssociatedAttachment child element to this Occurrence.
	plmxml_api::Result AddAssociatedAttachment( AssociatedAttachment *arg );

	//! Detach and delete all AssociatedAttachment child elements.
	void DeleteAssociatedAttachments();
     
	//! Get number of AssociatedAttachment child elements.
	int NumberOfAssociatedAttachments() const;
     
	//! Get i'th AssociatedAttachment child element.
	AssociatedAttachment *GetAssociatedAttachment( int i ) const;
     
	//! Get all AssociatedAttachment child element as an array
	void GetAssociatedAttachments( plmxml_api::Array<AssociatedAttachment*> &array ) const;
	     
	//! Detach and delete i'th AssociatedAttachment child element
	void DeleteAssociatedAttachment( int i );
     
	//! Detach and delete 'arg' if it's one of the AssociatedAttachment child elements
	void DeleteAssociatedAttachment( AssociatedAttachment *arg );

	//! Add AttributeContext child element to this Occurrence. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	AttributeContext *AddAttributeContext();
     
	//! Add 'arg' as AttributeContext child element to this Occurrence.
	plmxml_api::Result AddAttributeContext( AttributeContext *arg );

	//! Detach and delete all AttributeContext child elements.
	void DeleteAttributeContexts();
     
	//! Get number of AttributeContext child elements.
	int NumberOfAttributeContexts() const;
     
	//! Get i'th AttributeContext child element.
	AttributeContext *GetAttributeContext( int i ) const;
     
	//! Get all AttributeContext child element as an array
	void GetAttributeContexts( plmxml_api::Array<AttributeContext*> &array ) const;
	     
	//! Detach and delete i'th AttributeContext child element
	void DeleteAttributeContext( int i );
     
	//! Detach and delete 'arg' if it's one of the AttributeContext child elements
	void DeleteAttributeContext( AttributeContext *arg );
 
// <PLMXML_UserCode type="functionHeaderOccurrence" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassOccurrence;


////////////////////////////////////////////////////////////////////////////////////
//! Instance class
/*!
\verbatim

      A base type for instancing relations between Structure, StructureRevision,
      StructureView and StructureRevisionView elements. (This is not an abstract
      type because the Instance element is retained for compatibility reasons).

      Attributes:

      quantity:         Quantity of the element referenced. If absent, 1 is
                        implied. If present, any contained or referenced
                        Transform is ignored.
      unitRef:          Units for the quantity attribute. If absent, 'each' is
                        implied. An IDREF to a 'Unit' element.
      instanceType:     A 'subtype' string for the instance. No specified
                        semantics.
      sequenceNumber:   Serves to identify the instance within its parent. If
                        present, should be unique within the parent.
      instanceThreadRef: A reference to the InstanceThread which this Instance
                        is included in, if any.
      instanceTypeRef:  References a multiple language version of instanceType.
                        If multiple language support is required,
                        instanceTypeRef should be used in addition to
                        instanceTypeRef.
      
\endverbatim
*/
class PLMXML60_API Instance : public StructureUsage
{
public:
     
    //! Default constructor
    Instance( );
     
    //! Constructs a Instance with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Instance( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Instance();

private:

	//! Assignment operator
	Instance& operator=( const Instance& iSrc );

	//! Copy constructor
	Instance( const Instance& original );
     
public:

	//! Get InstanceType of this Instance
	plmxml_api::String GetInstanceType() const;

	//! Set InstanceType of this Instance
	plmxml_api::Result SetInstanceType( const plmxml_api::String &s );
	
	//! Check if InstanceType is set
	plmxml_api::logical HasInstanceType( ) const;
	
	//! Unset InstanceType
	plmxml_api::Result UnsetInstanceType( );

	//! Set reference to Unit using 'arg's plmxml_api::Id.
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical SetUnitRef( plmxml60::IdObject *arg );

	//! Clear reference to Unit
	void RemoveUnitRef( );

	//! Find a plmxml60::IdObject referenced by Unit
	plmxml60::IdObject *ResolveUnitRef( plmxml_api::Configuration* config = NULL );

	//! Get Unit reference
	plmxml_api::String GetUnitId() const;

	//! Set Unit reference.
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical SetUnitId( const plmxml_api::String& u );
	
	//! Check if Unit is set
	plmxml_api::logical HasUnitRef( ) const;

	//! Get InstanceThread URI as plmxml_api::String
	plmxml_api::String GetInstanceThreadURI() const;

	//! Set InstanceThread URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetInstanceThreadURI( const plmxml_api::String& );
	
	//! Get the handle of InstanceThread URI. Does not resolve the URI.
	plmxml_api::Result GetInstanceThreadURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of InstanceThread URI. URI string is unchanged.
	plmxml_api::Result SetInstanceThreadURI( const plmxml_api::Handle& );
	
	//! Resolve InstanceThread URI and return an object (handle) it points to.
	plmxml_api::Result ResolveInstanceThreadURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset InstanceThread URI. Clears URI string and handle.
	plmxml_api::Result DeleteInstanceThreadURI();
	
	//! Check if InstanceThread URI is set
	plmxml_api::logical HasInstanceThreadURI( ) const;
	

	//! Set SequenceNumber
	plmxml_api::Result SetSequenceNumber( int arg );
     
	//! Get SequenceNumber
	int GetSequenceNumber() const;
     
	//! Check if SequenceNumber is set
	plmxml_api::logical HasSequenceNumber() const;
     
	//! Unset SequenceNumber
	plmxml_api::Result UnsetSequenceNumber();

	//! Get InstanceType URI as plmxml_api::String
	plmxml_api::String GetInstanceTypeURI() const;

	//! Set InstanceType URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetInstanceTypeURI( const plmxml_api::String& );
	
	//! Get the handle of InstanceType URI. Does not resolve the URI.
	plmxml_api::Result GetInstanceTypeURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of InstanceType URI. URI string is unchanged.
	plmxml_api::Result SetInstanceTypeURI( const plmxml_api::Handle& );
	
	//! Resolve InstanceType URI and return an object (handle) it points to.
	plmxml_api::Result ResolveInstanceTypeURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset InstanceType URI. Clears URI string and handle.
	plmxml_api::Result DeleteInstanceTypeURI();
	
	//! Check if InstanceType URI is set
	plmxml_api::logical HasInstanceTypeURI( ) const;
	

	//! Set Quantity
	plmxml_api::Result SetQuantity( double arg );

     //! Get Quantity
	double GetQuantity() const;

	//! Check if Quantity is set
	plmxml_api::logical HasQuantity() const;

	//! Unset Quantity
	plmxml_api::Result UnsetQuantity();
 
// <PLMXML_UserCode type="functionHeaderInstance" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassInstance;


////////////////////////////////////////////////////////////////////////////////////
//! ProductInstance class
/*!
\verbatim

      An Instance between Product, ProductRevision, or ProductRevisionView elements.
      
      Attributes:
      
      substituteForRef:  A ProductInstance may be a 'substitute' for another, which means
                       that it may be used instead, but only in the context of their
                       common parent assembly. If this is a substitute for another
                       ProductInstance, then this attribute references it.
      
\endverbatim
*/
class PLMXML60_API ProductInstance : public Instance
{
public:
     
    //! Default constructor
    ProductInstance( );
     
    //! Constructs a ProductInstance with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ProductInstance( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ProductInstance();

private:

	//! Assignment operator
	ProductInstance& operator=( const ProductInstance& iSrc );

	//! Copy constructor
	ProductInstance( const ProductInstance& original );
     
public:

	//! Get SubstituteFor URI as plmxml_api::String
	plmxml_api::String GetSubstituteForURI() const;

	//! Set SubstituteFor URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetSubstituteForURI( const plmxml_api::String& );
	
	//! Get the handle of SubstituteFor URI. Does not resolve the URI.
	plmxml_api::Result GetSubstituteForURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of SubstituteFor URI. URI string is unchanged.
	plmxml_api::Result SetSubstituteForURI( const plmxml_api::Handle& );
	
	//! Resolve SubstituteFor URI and return an object (handle) it points to.
	plmxml_api::Result ResolveSubstituteForURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset SubstituteFor URI. Clears URI string and handle.
	plmxml_api::Result DeleteSubstituteForURI();
	
	//! Check if SubstituteFor URI is set
	plmxml_api::logical HasSubstituteForURI( ) const;
	
 
// <PLMXML_UserCode type="functionHeaderProductInstance" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassProductInstance;


////////////////////////////////////////////////////////////////////////////////////
//! CompositionInstance class
/*!
\verbatim

      This is a base type for sub-types of Instance which need to reference 
      an Occurrence.
      
      Attributes:
      
      occurrenceRef:   the referenced Occurrence. No specific semantics at this level.
      
\endverbatim
*/
class PLMXML60_API CompositionInstance : public Instance
{
public:
     
    //! Default constructor
    CompositionInstance( );
     
    //! Constructs a CompositionInstance with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    CompositionInstance( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~CompositionInstance();

private:

	//! Assignment operator
	CompositionInstance& operator=( const CompositionInstance& iSrc );

	//! Copy constructor
	CompositionInstance( const CompositionInstance& original );
     
public:

	//! Get Occurrence URI as plmxml_api::String
	plmxml_api::String GetOccurrenceURI() const;

	//! Set Occurrence URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetOccurrenceURI( const plmxml_api::String& );
	
	//! Get the handle of Occurrence URI. Does not resolve the URI.
	plmxml_api::Result GetOccurrenceURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Occurrence URI. URI string is unchanged.
	plmxml_api::Result SetOccurrenceURI( const plmxml_api::Handle& );
	
	//! Resolve Occurrence URI and return an object (handle) it points to.
	plmxml_api::Result ResolveOccurrenceURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Occurrence URI. Clears URI string and handle.
	plmxml_api::Result DeleteOccurrenceURI();
	
	//! Check if Occurrence URI is set
	plmxml_api::logical HasOccurrenceURI( ) const;
	
 
// <PLMXML_UserCode type="functionHeaderCompositionInstance" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassCompositionInstance;


////////////////////////////////////////////////////////////////////////////////////
//! GDEInstance class
/*!
\verbatim

      An Instance of a GDE.
      
      Attributes:
      
      instanceNumber   A number, or index, which identifies the GDEInstance
                       within its parent.
      
      
\endverbatim
*/
class PLMXML60_API GDEInstance : public Instance
{
public:
     
    //! Default constructor
    GDEInstance( );
     
    //! Constructs a GDEInstance with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    GDEInstance( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~GDEInstance();

private:

	//! Assignment operator
	GDEInstance& operator=( const GDEInstance& iSrc );

	//! Copy constructor
	GDEInstance( const GDEInstance& original );
     
public:

	//! Set InstanceNumber
	plmxml_api::Result SetInstanceNumber( int arg );
     
	//! Get InstanceNumber
	int GetInstanceNumber() const;
     
	//! Check if InstanceNumber is set
	plmxml_api::logical HasInstanceNumber() const;
     
	//! Unset InstanceNumber
	plmxml_api::Result UnsetInstanceNumber();
 
// <PLMXML_UserCode type="functionHeaderGDEInstance" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassGDEInstance;


//! Forward class declarations
class PropertyGroup;
class DeterminedPropertyGroup;

////////////////////////////////////////////////////////////////////////////////////
//! GDEInstanceGroup class
/*!
\verbatim

      GDEInstanceGroup: derived from Managed.

      This global element is used to collect together a number of
      GDEInstance elements to simplify referencing.

      Attributes:

      propertyRefs     Reference to Properties.

      Elements:

      GDEInstance      Any number of GDEInstances.
      PropertyGroup    A group of Properties applicable to all GDEInstances
                       in the GDEInstanceGroup.
      DeterminedPropertyGroup: The GDEInstanceGroup Properties determined by a
                        specific method.
      
\endverbatim
*/
class PLMXML60_API GDEInstanceGroup : public Managed
{
public:
     
    //! Default constructor
    GDEInstanceGroup( );
     
    //! Constructs a GDEInstanceGroup with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    GDEInstanceGroup( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~GDEInstanceGroup();

private:

	//! Assignment operator
	GDEInstanceGroup& operator=( const GDEInstanceGroup& iSrc );

	//! Copy constructor
	GDEInstanceGroup( const GDEInstanceGroup& original );
     
public:

	//! Get number of URIs in Property
	int NumberOfPropertyURIs() const;

	//! Get i'th URI in Property
	plmxml_api::String GetPropertyURI( int i ) const;

	//! Add a URI to Property array. Call ResolvePropertyURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddPropertyURI( const plmxml_api::String& u );

	//! Set i'th URI in Property array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetPropertyURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Property URI. Does not resolve the URI.
	plmxml_api::Result GetPropertyURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Property array.
	plmxml_api::Result AddPropertyURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Property array to point to 'handle'.
	plmxml_api::Result SetPropertyURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Property points to.
	plmxml_api::Result ResolvePropertyURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Property array.
	plmxml_api::Result DeletePropertyURI( int i );

	//! Remove all URIs from Property array.
	plmxml_api::Result DeletePropertyURIs( );
	
	//! Check if Property is set
	plmxml_api::logical HasPropertyURIs( ) const;

	//! Add GDEInstance child element to this GDEInstanceGroup. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	GDEInstance *AddGDEInstance();
     
	//! Add 'arg' as GDEInstance child element to this GDEInstanceGroup.
	plmxml_api::Result AddGDEInstance( GDEInstance *arg );

	//! Detach and delete all GDEInstance child elements.
	void DeleteGDEInstances();
     
	//! Get number of GDEInstance child elements.
	int NumberOfGDEInstances() const;
     
	//! Get i'th GDEInstance child element.
	GDEInstance *GetGDEInstance( int i ) const;
     
	//! Get all GDEInstance child element as an array
	void GetGDEInstances( plmxml_api::Array<GDEInstance*> &array ) const;
	     
	//! Detach and delete i'th GDEInstance child element
	void DeleteGDEInstance( int i );
     
	//! Detach and delete 'arg' if it's one of the GDEInstance child elements
	void DeleteGDEInstance( GDEInstance *arg );

	//! Add PropertyGroup child element to this GDEInstanceGroup. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	PropertyGroup *AddPropertyGroup();
     
	//! Set PropertyGroup child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetPropertyGroup( PropertyGroup *arg );
     
	//! Get PropertyGroup child element of this GDEInstanceGroup.
	PropertyGroup *GetPropertyGroup() const;
     
	//! Detach and delete PropertyGroup child element tree from this GDEInstanceGroup.
	void DeletePropertyGroup();

	//! Add DeterminedPropertyGroup child element to this GDEInstanceGroup. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	DeterminedPropertyGroup *AddDeterminedPropertyGroup();
     
	//! Set DeterminedPropertyGroup child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetDeterminedPropertyGroup( DeterminedPropertyGroup *arg );
     
	//! Get DeterminedPropertyGroup child element of this GDEInstanceGroup.
	DeterminedPropertyGroup *GetDeterminedPropertyGroup() const;
     
	//! Detach and delete DeterminedPropertyGroup child element tree from this GDEInstanceGroup.
	void DeleteDeterminedPropertyGroup();
 
// <PLMXML_UserCode type="functionHeaderGDEInstanceGroup" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassGDEInstanceGroup;


////////////////////////////////////////////////////////////////////////////////////
//! ConnectionInstance class
/*!
\verbatim

      An Instance of a Connection, ConnectionRevision, or ConnectionRevisionView.
      
\endverbatim
*/
class PLMXML60_API ConnectionInstance : public Instance
{
public:
     
    //! Default constructor
    ConnectionInstance( );
     
    //! Constructs a ConnectionInstance with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ConnectionInstance( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ConnectionInstance();

private:

	//! Assignment operator
	ConnectionInstance& operator=( const ConnectionInstance& iSrc );

	//! Copy constructor
	ConnectionInstance( const ConnectionInstance& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderConnectionInstance" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassConnectionInstance;


////////////////////////////////////////////////////////////////////////////////////
//! ConfigurationContext class
/*!
\verbatim

      This element acts as a context for effectivities. An Effectivity can reference a
      ConfigurationContext element to indicate that the Effectivity is only applicable
      to that ConfigurationContext. 
      
      Attributes:
       
      configId:   Unique identifier.
      
\endverbatim
*/
class PLMXML60_API ConfigurationContext : public Managed
{
public:
     
    //! Default constructor
    ConfigurationContext( );
     
    //! Constructs a ConfigurationContext with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ConfigurationContext( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ConfigurationContext();

private:

	//! Assignment operator
	ConfigurationContext& operator=( const ConfigurationContext& iSrc );

	//! Copy constructor
	ConfigurationContext( const ConfigurationContext& original );
     
public:

	//! Get ConfigId of this ConfigurationContext
	plmxml_api::String GetConfigId() const;

	//! Set ConfigId of this ConfigurationContext
	plmxml_api::Result SetConfigId( const plmxml_api::String &s );
	
	//! Check if ConfigId is set
	plmxml_api::logical HasConfigId( ) const;
	
	//! Unset ConfigId
	plmxml_api::Result UnsetConfigId( );
 
// <PLMXML_UserCode type="functionHeaderConfigurationContext" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassConfigurationContext;


////////////////////////////////////////////////////////////////////////////////////
//! Effectivity class
/*!
\verbatim

      Effectivity Base class.
      
      contextRef: the Structure, StructureRevision, or ConfigurationContext in which this 
                  Effectivity applies. If absent, then the Effectivity is relevant for
                  all Products and ProductRevisions which use the element to which the 
                  Effectivity is attached.
      
\endverbatim
*/
class PLMXML60_API Effectivity : public AttribOwner
{
public:
     
    //! Default constructor
    Effectivity( );
     
    //! Constructs a Effectivity with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Effectivity( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Effectivity();

private:

	//! Assignment operator
	Effectivity& operator=( const Effectivity& iSrc );

	//! Copy constructor
	Effectivity( const Effectivity& original );
     
public:

	//! Get Context URI as plmxml_api::String
	plmxml_api::String GetContextURI() const;

	//! Set Context URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetContextURI( const plmxml_api::String& );
	
	//! Get the handle of Context URI. Does not resolve the URI.
	plmxml_api::Result GetContextURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Context URI. URI string is unchanged.
	plmxml_api::Result SetContextURI( const plmxml_api::Handle& );
	
	//! Resolve Context URI and return an object (handle) it points to.
	plmxml_api::Result ResolveContextURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Context URI. Clears URI string and handle.
	plmxml_api::Result DeleteContextURI();
	
	//! Check if Context URI is set
	plmxml_api::logical HasContextURI( ) const;
	
 
// <PLMXML_UserCode type="functionHeaderEffectivity" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassEffectivity;


////////////////////////////////////////////////////////////////////////////////////
//! DateEffectivity class
/*!
\verbatim

      Date Effectivity. Indicates that an element is effective between two specified
      dates. If the start is omitted, the effectivity is openEnded in that direction.
      If the end is omitted, the effectivity is openEnded, or stockOut, in that
      direction.

      Attributes:
     
      start:         Start date and time.
      end:           End date and time.
      endCondition:  If the end dateTime is omitted, this attribute specifies
                     whether the effectivity is stockOut or openEnded. OpenEnded means
                     effective indefinitely after the start date; stockOut means only
                     effective 'while stocks last'. 
      
\endverbatim
*/
class PLMXML60_API DateEffectivity : public Effectivity
{
public:
     
    //! Default constructor
    DateEffectivity( );
     
    //! Constructs a DateEffectivity with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    DateEffectivity( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~DateEffectivity();

private:

	//! Assignment operator
	DateEffectivity& operator=( const DateEffectivity& iSrc );

	//! Copy constructor
	DateEffectivity( const DateEffectivity& original );
     
public:

	//! Set EndCondition
	plmxml_api::Result SetEndCondition( const eEffectivityEndConditionType& arg );

	//! Get EndCondition
	eEffectivityEndConditionType GetEndCondition() const;

	//! Get Start of this DateEffectivity
	plmxml_api::String GetStart() const;

	//! Set Start of this DateEffectivity
	plmxml_api::Result SetStart( const plmxml_api::String &s );
	
	//! Check if Start is set
	plmxml_api::logical HasStart( ) const;
	
	//! Unset Start
	plmxml_api::Result UnsetStart( );

	//! Get End of this DateEffectivity
	plmxml_api::String GetEnd() const;

	//! Set End of this DateEffectivity
	plmxml_api::Result SetEnd( const plmxml_api::String &s );
	
	//! Check if End is set
	plmxml_api::logical HasEnd( ) const;
	
	//! Unset End
	plmxml_api::Result UnsetEnd( );
 
// <PLMXML_UserCode type="functionHeaderDateEffectivity" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassDateEffectivity;


////////////////////////////////////////////////////////////////////////////////////
//! LotEffectivity class
/*!
\verbatim

      Lot Effectivity. Indicates that an element is effective only for a certain 'lot' or
      batch.

      Attributes:
     
      lot:        Lot identifier.
      
\endverbatim
*/
class PLMXML60_API LotEffectivity : public Effectivity
{
public:
     
    //! Default constructor
    LotEffectivity( );
     
    //! Constructs a LotEffectivity with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    LotEffectivity( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~LotEffectivity();

private:

	//! Assignment operator
	LotEffectivity& operator=( const LotEffectivity& iSrc );

	//! Copy constructor
	LotEffectivity( const LotEffectivity& original );
     
public:

	//! Get Lot of this LotEffectivity
	plmxml_api::String GetLot() const;

	//! Set Lot of this LotEffectivity
	plmxml_api::Result SetLot( const plmxml_api::String &s );
	
	//! Check if Lot is set
	plmxml_api::logical HasLot( ) const;
	
	//! Unset Lot
	plmxml_api::Result UnsetLot( );
 
// <PLMXML_UserCode type="functionHeaderLotEffectivity" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassLotEffectivity;


////////////////////////////////////////////////////////////////////////////////////
//! SerialNumberEffectivity class
/*!
\verbatim

      Serial Number Effectivity. Indicates that an element is effective for a range of
      serial numbers. If the start is omitted, the effectivity is openEnded in that 
      direction. If the end is omitted, the effectivity is openEnded, or stockOut, 
      in that direction.

      Attributes:
     
      start:         Start serial number.
      end:           End serial number.
      endCondition:  If the end serial number is omitted, this attribute specifies
                     whether the effectivity is stockOut or openEnded. OpenEnded means
                     effective indefinitely after the start serialNumber; stockOut means
                     only effective 'while stocks last'.
      
\endverbatim
*/
class PLMXML60_API SerialNumberEffectivity : public Effectivity
{
public:
     
    //! Default constructor
    SerialNumberEffectivity( );
     
    //! Constructs a SerialNumberEffectivity with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    SerialNumberEffectivity( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~SerialNumberEffectivity();

private:

	//! Assignment operator
	SerialNumberEffectivity& operator=( const SerialNumberEffectivity& iSrc );

	//! Copy constructor
	SerialNumberEffectivity( const SerialNumberEffectivity& original );
     
public:

	//! Set EndCondition
	plmxml_api::Result SetEndCondition( const eEffectivityEndConditionType& arg );

	//! Get EndCondition
	eEffectivityEndConditionType GetEndCondition() const;

	//! Get Start of this SerialNumberEffectivity
	plmxml_api::String GetStart() const;

	//! Set Start of this SerialNumberEffectivity
	plmxml_api::Result SetStart( const plmxml_api::String &s );
	
	//! Check if Start is set
	plmxml_api::logical HasStart( ) const;
	
	//! Unset Start
	plmxml_api::Result UnsetStart( );

	//! Get End of this SerialNumberEffectivity
	plmxml_api::String GetEnd() const;

	//! Set End of this SerialNumberEffectivity
	plmxml_api::Result SetEnd( const plmxml_api::String &s );
	
	//! Check if End is set
	plmxml_api::logical HasEnd( ) const;
	
	//! Unset End
	plmxml_api::Result UnsetEnd( );
 
// <PLMXML_UserCode type="functionHeaderSerialNumberEffectivity" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassSerialNumberEffectivity;


////////////////////////////////////////////////////////////////////////////////////
//! OptionValue class
/*!
\verbatim

      Attributes:

      vRef:             References a multiple language version of v. If multiple
                        language support is required, vRef should be used in addition to v.
      
\endverbatim
*/
class PLMXML60_API OptionValue : public plmxml_api::Object
{
public:
     
    //! Default constructor
    OptionValue( );
     
    //! Constructs a OptionValue with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    OptionValue( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~OptionValue();

private:

	//! Assignment operator
	OptionValue& operator=( const OptionValue& iSrc );

	//! Copy constructor
	OptionValue( const OptionValue& original );
     
public:

	//! Get V URI as plmxml_api::String
	plmxml_api::String GetVURI() const;

	//! Set V URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetVURI( const plmxml_api::String& );
	
	//! Get the handle of V URI. Does not resolve the URI.
	plmxml_api::Result GetVURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of V URI. URI string is unchanged.
	plmxml_api::Result SetVURI( const plmxml_api::Handle& );
	
	//! Resolve V URI and return an object (handle) it points to.
	plmxml_api::Result ResolveVURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset V URI. Clears URI string and handle.
	plmxml_api::Result DeleteVURI();
	
	//! Check if V URI is set
	plmxml_api::logical HasVURI( ) const;
	

	//! Get V of this OptionValue
	plmxml_api::String GetV() const;

	//! Set V of this OptionValue
	plmxml_api::Result SetV( const plmxml_api::String &s );
	
	//! Check if V is set
	plmxml_api::logical HasV( ) const;
	
	//! Unset V
	plmxml_api::Result UnsetV( );
 
// <PLMXML_UserCode type="functionHeaderOptionValue" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassOptionValue;


////////////////////////////////////////////////////////////////////////////////////
//! Option class
/*!
\verbatim

      Option. This element specifies the valid values for an Option, either as a set of
      allowed values (i.e. an enum), or as a range of values of a particular type.

      Attributes:

      scope:         Option scope.
      type:          Option type - enum, string, int, real or logical.

      Elements:

      Value:         If the Option is of type enum, it should contain a sequence of Value
                     sub-elements giving the allowed values.

      GreaterThan:        ) If the Option type is not enum, then its allowed values are                   
      GreaterThanOrEqual: ) given by a range, which is specified by a GreaterThan or 
      LessThan:           ) GreaterThanOrEqual element, followed by a LessThan or
      LessThanOrEqual:    ) LessThanOrEqual element. These are all of type 
                            OptionValueType.

      Default:       Following these elements there may be a Default element giving a
                     default value for the Option.
      
\endverbatim
*/
class PLMXML60_API Option : public AttribOwner
{
public:
     
    //! Default constructor
    Option( );
     
    //! Constructs a Option with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Option( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Option();

private:

	//! Assignment operator
	Option& operator=( const Option& iSrc );

	//! Copy constructor
	Option( const Option& original );
     
public:

	//! Set Type
	plmxml_api::Result SetType( const eOptionTypesType& arg );

	//! Get Type
	eOptionTypesType GetType() const;

	//! Set Scope
	plmxml_api::Result SetScope( const eOptionScopeType& arg );

	//! Get Scope
	eOptionScopeType GetScope() const;

	//! Add Value child element to this Option. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	OptionValue *AddValue();
     
	//! Add 'arg' as Value child element to this Option.
	plmxml_api::Result AddValue( OptionValue *arg );

	//! Detach and delete all Value child elements.
	void DeleteValues();
     
	//! Get number of Value child elements.
	int NumberOfValues() const;
     
	//! Get i'th Value child element.
	OptionValue *GetValue( int i ) const;
     
	//! Get all Value child element as an array
	void GetValues( plmxml_api::Array<OptionValue*> &array ) const;
	     
	//! Detach and delete i'th Value child element
	void DeleteValue( int i );
     
	//! Detach and delete 'arg' if it's one of the Value child elements
	void DeleteValue( OptionValue *arg );

	//! Add GreaterThan child element to this Option. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	OptionValue *AddGreaterThan();
     
	//! Set GreaterThan child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetGreaterThan( OptionValue *arg );
     
	//! Get GreaterThan child element of this Option.
	OptionValue *GetGreaterThan() const;
     
	//! Detach and delete GreaterThan child element tree from this Option.
	void DeleteGreaterThan();

	//! Add GreaterThanOrEqual child element to this Option. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	OptionValue *AddGreaterThanOrEqual();
     
	//! Set GreaterThanOrEqual child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetGreaterThanOrEqual( OptionValue *arg );
     
	//! Get GreaterThanOrEqual child element of this Option.
	OptionValue *GetGreaterThanOrEqual() const;
     
	//! Detach and delete GreaterThanOrEqual child element tree from this Option.
	void DeleteGreaterThanOrEqual();

	//! Add LessThan child element to this Option. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	OptionValue *AddLessThan();
     
	//! Set LessThan child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetLessThan( OptionValue *arg );
     
	//! Get LessThan child element of this Option.
	OptionValue *GetLessThan() const;
     
	//! Detach and delete LessThan child element tree from this Option.
	void DeleteLessThan();

	//! Add LessThanOrEqual child element to this Option. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	OptionValue *AddLessThanOrEqual();
     
	//! Set LessThanOrEqual child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetLessThanOrEqual( OptionValue *arg );
     
	//! Get LessThanOrEqual child element of this Option.
	OptionValue *GetLessThanOrEqual() const;
     
	//! Detach and delete LessThanOrEqual child element tree from this Option.
	void DeleteLessThanOrEqual();

	//! Add Default child element to this Option. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	OptionValue *AddDefault();
     
	//! Set Default child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetDefault( OptionValue *arg );
     
	//! Get Default child element of this Option.
	OptionValue *GetDefault() const;
     
	//! Detach and delete Default child element tree from this Option.
	void DeleteDefault();
 
// <PLMXML_UserCode type="functionHeaderOption" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassOption;


////////////////////////////////////////////////////////////////////////////////////
//! Operand class
/*!
\verbatim

      Operand - abstract base class for Operands (arguments of operators).
      
\endverbatim
*/
class PLMXML60_API Operand : public plmxml_api::Object
{
public:
     
    //! Default constructor
    Operand( );
     
    //! Constructs a Operand with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Operand( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Operand();

private:

	//! Assignment operator
	Operand& operator=( const Operand& iSrc );

	//! Copy constructor
	Operand( const Operand& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderOperand" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassOperand;


////////////////////////////////////////////////////////////////////////////////////
//! Statement class
/*!
\verbatim

      Statement - abstract base class for statements.
      
\endverbatim
*/
class PLMXML60_API Statement : public plmxml_api::Object
{
public:
     
    //! Default constructor
    Statement( );
     
    //! Constructs a Statement with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Statement( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Statement();

private:

	//! Assignment operator
	Statement& operator=( const Statement& iSrc );

	//! Copy constructor
	Statement( const Statement& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderStatement" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassStatement;


////////////////////////////////////////////////////////////////////////////////////
//! StatementList class
/*!
\verbatim

      StatementList - a list of statements.

      Elements:

      Contains a non-empty sequence of elements derived from Statement.      
      
\endverbatim
*/
class PLMXML60_API StatementList : public plmxml_api::Object
{
public:
     
    //! Default constructor
    StatementList( );
     
    //! Constructs a StatementList with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    StatementList( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~StatementList();

private:

	//! Assignment operator
	StatementList& operator=( const StatementList& iSrc );

	//! Copy constructor
	StatementList( const StatementList& original );
     
public:

	//! Add Statement child element to this StatementList. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Statement *AddStatement();
     
	//! Add 'arg' as Statement child element to this StatementList.
	plmxml_api::Result AddStatement( Statement *arg );

	//! Detach and delete all Statement child elements.
	void DeleteStatements();
     
	//! Get number of Statement child elements.
	int NumberOfStatements() const;
     
	//! Get i'th Statement child element.
	Statement *GetStatement( int i ) const;
     
	//! Get all Statement child element as an array
	void GetStatements( plmxml_api::Array<Statement*> &array ) const;
	     
	//! Detach and delete i'th Statement child element
	void DeleteStatement( int i );
     
	//! Detach and delete 'arg' if it's one of the Statement child elements
	void DeleteStatement( Statement *arg );
 
// <PLMXML_UserCode type="functionHeaderStatementList" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassStatementList;


////////////////////////////////////////////////////////////////////////////////////
//! Expression class
/*!
\verbatim

      Expression - abstract base class for Expressions.
      
\endverbatim
*/
class PLMXML60_API Expression : public Operand
{
public:
     
    //! Default constructor
    Expression( );
     
    //! Constructs a Expression with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Expression( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Expression();

private:

	//! Assignment operator
	Expression& operator=( const Expression& iSrc );

	//! Copy constructor
	Expression( const Expression& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderExpression" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassExpression;


////////////////////////////////////////////////////////////////////////////////////
//! LogicalExpression class
/*!
\verbatim

      LogicalExpression - abstract base class for expressions returning a logical result.
      
\endverbatim
*/
class PLMXML60_API LogicalExpression : public Expression
{
public:
     
    //! Default constructor
    LogicalExpression( );
     
    //! Constructs a LogicalExpression with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    LogicalExpression( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~LogicalExpression();

private:

	//! Assignment operator
	LogicalExpression& operator=( const LogicalExpression& iSrc );

	//! Copy constructor
	LogicalExpression( const LogicalExpression& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderLogicalExpression" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassLogicalExpression;


////////////////////////////////////////////////////////////////////////////////////
//! And class
/*!
\verbatim

      And - a type of logical expression.

      Elements:

      At least two sub-elements, derived from LogicalExpression. The And expression
      returns true if all its sub-elements return true.
      
\endverbatim
*/
class PLMXML60_API And : public LogicalExpression
{
public:
     
    //! Default constructor
    And( );
     
    //! Constructs a And with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    And( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~And();

private:

	//! Assignment operator
	And& operator=( const And& iSrc );

	//! Copy constructor
	And( const And& original );
     
public:

	//! Add LogicalExpression child element to this And. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	LogicalExpression *AddLogicalExpression();
     
	//! Add 'arg' as LogicalExpression child element to this And.
	plmxml_api::Result AddLogicalExpression( LogicalExpression *arg );

	//! Detach and delete all LogicalExpression child elements.
	void DeleteLogicalExpressions();
     
	//! Get number of LogicalExpression child elements.
	int NumberOfLogicalExpressions() const;
     
	//! Get i'th LogicalExpression child element.
	LogicalExpression *GetLogicalExpression( int i ) const;
     
	//! Get all LogicalExpression child element as an array
	void GetLogicalExpressions( plmxml_api::Array<LogicalExpression*> &array ) const;
	     
	//! Detach and delete i'th LogicalExpression child element
	void DeleteLogicalExpression( int i );
     
	//! Detach and delete 'arg' if it's one of the LogicalExpression child elements
	void DeleteLogicalExpression( LogicalExpression *arg );
 
// <PLMXML_UserCode type="functionHeaderAnd" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassAnd;


////////////////////////////////////////////////////////////////////////////////////
//! Or class
/*!
\verbatim

      Or - a type of logical expression.

      Elements:

      At least two sub-elements, derived from LogicalExpression. The Or expression
      returns true if any of its sub-elements return true.
      
\endverbatim
*/
class PLMXML60_API Or : public LogicalExpression
{
public:
     
    //! Default constructor
    Or( );
     
    //! Constructs a Or with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Or( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Or();

private:

	//! Assignment operator
	Or& operator=( const Or& iSrc );

	//! Copy constructor
	Or( const Or& original );
     
public:

	//! Add LogicalExpression child element to this Or. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	LogicalExpression *AddLogicalExpression();
     
	//! Add 'arg' as LogicalExpression child element to this Or.
	plmxml_api::Result AddLogicalExpression( LogicalExpression *arg );

	//! Detach and delete all LogicalExpression child elements.
	void DeleteLogicalExpressions();
     
	//! Get number of LogicalExpression child elements.
	int NumberOfLogicalExpressions() const;
     
	//! Get i'th LogicalExpression child element.
	LogicalExpression *GetLogicalExpression( int i ) const;
     
	//! Get all LogicalExpression child element as an array
	void GetLogicalExpressions( plmxml_api::Array<LogicalExpression*> &array ) const;
	     
	//! Detach and delete i'th LogicalExpression child element
	void DeleteLogicalExpression( int i );
     
	//! Detach and delete 'arg' if it's one of the LogicalExpression child elements
	void DeleteLogicalExpression( LogicalExpression *arg );
 
// <PLMXML_UserCode type="functionHeaderOr" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassOr;


////////////////////////////////////////////////////////////////////////////////////
//! Not class
/*!
\verbatim

      Not - a type of logical expression.

      Elements:

      One sub-element, derived from LogicalExpression. The Not expression returns 
      true if its sub-element returns false.
      
\endverbatim
*/
class PLMXML60_API Not : public LogicalExpression
{
public:
     
    //! Default constructor
    Not( );
     
    //! Constructs a Not with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Not( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Not();

private:

	//! Assignment operator
	Not& operator=( const Not& iSrc );

	//! Copy constructor
	Not( const Not& original );
     
public:

	//! Add LogicalExpression child element to this Not. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	LogicalExpression *AddLogicalExpression();
     
	//! Set LogicalExpression child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetLogicalExpression( LogicalExpression *arg );
     
	//! Get LogicalExpression child element of this Not.
	LogicalExpression *GetLogicalExpression() const;
     
	//! Detach and delete LogicalExpression child element tree from this Not.
	void DeleteLogicalExpression();
 
// <PLMXML_UserCode type="functionHeaderNot" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassNot;


////////////////////////////////////////////////////////////////////////////////////
//! OptionIs class
/*!
\verbatim

      OptionIs - a logical expression which returns true if a given Option has a
      particular relation to a given value (default equality relation).

      Attributes:

      optionRef:        Reference to the Option.
      value:            Specified value for the Option.
      operation:        The operation. For example if operation is "gt", then
                        OptionIs returns true if the option is greater than
                        'value'.
      valueRef:         References a multiple language version of value. If
                        multiple language support is required, valueRef should
                        be used in addition to value.
      
\endverbatim
*/
class PLMXML60_API OptionIs : public LogicalExpression
{
public:
     
    //! Default constructor
    OptionIs( );
     
    //! Constructs a OptionIs with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    OptionIs( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~OptionIs();

private:

	//! Assignment operator
	OptionIs& operator=( const OptionIs& iSrc );

	//! Copy constructor
	OptionIs( const OptionIs& original );
     
public:

	//! Get Option URI as plmxml_api::String
	plmxml_api::String GetOptionURI() const;

	//! Set Option URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetOptionURI( const plmxml_api::String& );
	
	//! Get the handle of Option URI. Does not resolve the URI.
	plmxml_api::Result GetOptionURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Option URI. URI string is unchanged.
	plmxml_api::Result SetOptionURI( const plmxml_api::Handle& );
	
	//! Resolve Option URI and return an object (handle) it points to.
	plmxml_api::Result ResolveOptionURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Option URI. Clears URI string and handle.
	plmxml_api::Result DeleteOptionURI();
	
	//! Check if Option URI is set
	plmxml_api::logical HasOptionURI( ) const;
	

	//! Get Value URI as plmxml_api::String
	plmxml_api::String GetValueURI() const;

	//! Set Value URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetValueURI( const plmxml_api::String& );
	
	//! Get the handle of Value URI. Does not resolve the URI.
	plmxml_api::Result GetValueURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Value URI. URI string is unchanged.
	plmxml_api::Result SetValueURI( const plmxml_api::Handle& );
	
	//! Resolve Value URI and return an object (handle) it points to.
	plmxml_api::Result ResolveValueURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Value URI. Clears URI string and handle.
	plmxml_api::Result DeleteValueURI();
	
	//! Check if Value URI is set
	plmxml_api::logical HasValueURI( ) const;
	

	//! Set Operation
	plmxml_api::Result SetOperation( const eLogicalOperationType& arg );

	//! Get Operation
	eLogicalOperationType GetOperation() const;

	//! Get Value of this OptionIs
	plmxml_api::String GetValue() const;

	//! Set Value of this OptionIs
	plmxml_api::Result SetValue( const plmxml_api::String &s );
	
	//! Check if Value is set
	plmxml_api::logical HasValue( ) const;
	
	//! Unset Value
	plmxml_api::Result UnsetValue( );
 
// <PLMXML_UserCode type="functionHeaderOptionIs" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassOptionIs;


////////////////////////////////////////////////////////////////////////////////////
//! PathIs class
/*!
\verbatim

      PathIs - a logical expression that returns true if the path matches that of the 
      'instanceRefs' attribute. The path is defined as that of the chain of Instances 
      through an Assembly that end on and include the owning Instance.
      
      Attributes:

      instanceRefs:   chain of Instances that define a path through a hierarchical
                      assembly structure.
      
\endverbatim
*/
class PLMXML60_API PathIs : public LogicalExpression
{
public:
     
    //! Default constructor
    PathIs( );
     
    //! Constructs a PathIs with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    PathIs( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~PathIs();

private:

	//! Assignment operator
	PathIs& operator=( const PathIs& iSrc );

	//! Copy constructor
	PathIs( const PathIs& original );
     
public:

	//! Get number of URIs in Instance
	int NumberOfInstanceURIs() const;

	//! Get i'th URI in Instance
	plmxml_api::String GetInstanceURI( int i ) const;

	//! Add a URI to Instance array. Call ResolveInstanceURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddInstanceURI( const plmxml_api::String& u );

	//! Set i'th URI in Instance array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetInstanceURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Instance URI. Does not resolve the URI.
	plmxml_api::Result GetInstanceURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Instance array.
	plmxml_api::Result AddInstanceURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Instance array to point to 'handle'.
	plmxml_api::Result SetInstanceURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Instance points to.
	plmxml_api::Result ResolveInstanceURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Instance array.
	plmxml_api::Result DeleteInstanceURI( int i );

	//! Remove all URIs from Instance array.
	plmxml_api::Result DeleteInstanceURIs( );
	
	//! Check if Instance is set
	plmxml_api::logical HasInstanceURIs( ) const;
 
// <PLMXML_UserCode type="functionHeaderPathIs" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassPathIs;


////////////////////////////////////////////////////////////////////////////////////
//! Set class
/*!
\verbatim

      Set. A Statement which sets an Option to a particular value.

      Attributes:

      optionRef:        Reference to the Option.
      value:            Specified value for the Option.
      valueRef:         References a multiple language version of value. If
                        multiple language support is required, valueRef should
                        be used in addition to value.
      
\endverbatim
*/
class PLMXML60_API Set : public Statement
{
public:
     
    //! Default constructor
    Set( );
     
    //! Constructs a Set with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Set( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Set();

private:

	//! Assignment operator
	Set& operator=( const Set& iSrc );

	//! Copy constructor
	Set( const Set& original );
     
public:

	//! Get Option URI as plmxml_api::String
	plmxml_api::String GetOptionURI() const;

	//! Set Option URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetOptionURI( const plmxml_api::String& );
	
	//! Get the handle of Option URI. Does not resolve the URI.
	plmxml_api::Result GetOptionURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Option URI. URI string is unchanged.
	plmxml_api::Result SetOptionURI( const plmxml_api::Handle& );
	
	//! Resolve Option URI and return an object (handle) it points to.
	plmxml_api::Result ResolveOptionURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Option URI. Clears URI string and handle.
	plmxml_api::Result DeleteOptionURI();
	
	//! Check if Option URI is set
	plmxml_api::logical HasOptionURI( ) const;
	

	//! Get Value URI as plmxml_api::String
	plmxml_api::String GetValueURI() const;

	//! Set Value URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetValueURI( const plmxml_api::String& );
	
	//! Get the handle of Value URI. Does not resolve the URI.
	plmxml_api::Result GetValueURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Value URI. URI string is unchanged.
	plmxml_api::Result SetValueURI( const plmxml_api::Handle& );
	
	//! Resolve Value URI and return an object (handle) it points to.
	plmxml_api::Result ResolveValueURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Value URI. Clears URI string and handle.
	plmxml_api::Result DeleteValueURI();
	
	//! Check if Value URI is set
	plmxml_api::logical HasValueURI( ) const;
	

	//! Get Value of this Set
	plmxml_api::String GetValue() const;

	//! Set Value of this Set
	plmxml_api::Result SetValue( const plmxml_api::String &s );
	
	//! Check if Value is set
	plmxml_api::logical HasValue( ) const;
	
	//! Unset Value
	plmxml_api::Result UnsetValue( );
 
// <PLMXML_UserCode type="functionHeaderSet" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassSet;


////////////////////////////////////////////////////////////////////////////////////
//! SetDefault class
/*!
\verbatim

      SetDefault. A Statement which sets an Option to a particular value, if it
      is unset. Unlike the Set Statement, it will not override an existing
      value.

      Attributes:

      optionRef:        Reference to the Option.
      value:            Specified value for the Option.
      valueRef:         References a multiple language version of value. If
                        multiple language support is required, valueRef should
                        be used in addition to value.
      
\endverbatim
*/
class PLMXML60_API SetDefault : public Statement
{
public:
     
    //! Default constructor
    SetDefault( );
     
    //! Constructs a SetDefault with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    SetDefault( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~SetDefault();

private:

	//! Assignment operator
	SetDefault& operator=( const SetDefault& iSrc );

	//! Copy constructor
	SetDefault( const SetDefault& original );
     
public:

	//! Get Option URI as plmxml_api::String
	plmxml_api::String GetOptionURI() const;

	//! Set Option URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetOptionURI( const plmxml_api::String& );
	
	//! Get the handle of Option URI. Does not resolve the URI.
	plmxml_api::Result GetOptionURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Option URI. URI string is unchanged.
	plmxml_api::Result SetOptionURI( const plmxml_api::Handle& );
	
	//! Resolve Option URI and return an object (handle) it points to.
	plmxml_api::Result ResolveOptionURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Option URI. Clears URI string and handle.
	plmxml_api::Result DeleteOptionURI();
	
	//! Check if Option URI is set
	plmxml_api::logical HasOptionURI( ) const;
	

	//! Get Value URI as plmxml_api::String
	plmxml_api::String GetValueURI() const;

	//! Set Value URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetValueURI( const plmxml_api::String& );
	
	//! Get the handle of Value URI. Does not resolve the URI.
	plmxml_api::Result GetValueURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Value URI. URI string is unchanged.
	plmxml_api::Result SetValueURI( const plmxml_api::Handle& );
	
	//! Resolve Value URI and return an object (handle) it points to.
	plmxml_api::Result ResolveValueURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Value URI. Clears URI string and handle.
	plmxml_api::Result DeleteValueURI();
	
	//! Check if Value URI is set
	plmxml_api::logical HasValueURI( ) const;
	

	//! Get Value of this SetDefault
	plmxml_api::String GetValue() const;

	//! Set Value of this SetDefault
	plmxml_api::Result SetValue( const plmxml_api::String &s );
	
	//! Check if Value is set
	plmxml_api::logical HasValue( ) const;
	
	//! Unset Value
	plmxml_api::Result UnsetValue( );
 
// <PLMXML_UserCode type="functionHeaderSetDefault" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassSetDefault;


////////////////////////////////////////////////////////////////////////////////////
//! Fix class
/*!
\verbatim

      Fix. A Statement which sets an Option to a particular value, and fixes it.
      Subsequent Set, SetDefault, or Fix Statements are not allowed to modify
      it.

      Attributes:

      optionRef:        Reference to the Option.
      value:            Specified value for the Option.
      valueRef:         References a multiple language version of value. If
                        multiple language support is required, valueRef should
                        be used in addition to value.
      
\endverbatim
*/
class PLMXML60_API Fix : public Statement
{
public:
     
    //! Default constructor
    Fix( );
     
    //! Constructs a Fix with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Fix( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Fix();

private:

	//! Assignment operator
	Fix& operator=( const Fix& iSrc );

	//! Copy constructor
	Fix( const Fix& original );
     
public:

	//! Get Option URI as plmxml_api::String
	plmxml_api::String GetOptionURI() const;

	//! Set Option URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetOptionURI( const plmxml_api::String& );
	
	//! Get the handle of Option URI. Does not resolve the URI.
	plmxml_api::Result GetOptionURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Option URI. URI string is unchanged.
	plmxml_api::Result SetOptionURI( const plmxml_api::Handle& );
	
	//! Resolve Option URI and return an object (handle) it points to.
	plmxml_api::Result ResolveOptionURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Option URI. Clears URI string and handle.
	plmxml_api::Result DeleteOptionURI();
	
	//! Check if Option URI is set
	plmxml_api::logical HasOptionURI( ) const;
	

	//! Get Value URI as plmxml_api::String
	plmxml_api::String GetValueURI() const;

	//! Set Value URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetValueURI( const plmxml_api::String& );
	
	//! Get the handle of Value URI. Does not resolve the URI.
	plmxml_api::Result GetValueURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Value URI. URI string is unchanged.
	plmxml_api::Result SetValueURI( const plmxml_api::Handle& );
	
	//! Resolve Value URI and return an object (handle) it points to.
	plmxml_api::Result ResolveValueURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Value URI. Clears URI string and handle.
	plmxml_api::Result DeleteValueURI();
	
	//! Check if Value URI is set
	plmxml_api::logical HasValueURI( ) const;
	

	//! Get Value of this Fix
	plmxml_api::String GetValue() const;

	//! Set Value of this Fix
	plmxml_api::Result SetValue( const plmxml_api::String &s );
	
	//! Check if Value is set
	plmxml_api::logical HasValue( ) const;
	
	//! Unset Value
	plmxml_api::Result UnsetValue( );
 
// <PLMXML_UserCode type="functionHeaderFix" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassFix;


////////////////////////////////////////////////////////////////////////////////////
//! Derived class
/*!
\verbatim

      Derived. A Statement which shows that the particular Option value has
      been derived from other options and given for information only.

      Attributes:

      optionRef:        Reference to the Option.
      value:            Value for the Option.
      valueRef:         References a multiple language version of value. If
                        multiple language support is required, valueRef should
                        be used in addition to value.
      
\endverbatim
*/
class PLMXML60_API Derived : public Statement
{
public:
     
    //! Default constructor
    Derived( );
     
    //! Constructs a Derived with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Derived( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Derived();

private:

	//! Assignment operator
	Derived& operator=( const Derived& iSrc );

	//! Copy constructor
	Derived( const Derived& original );
     
public:

	//! Get Option URI as plmxml_api::String
	plmxml_api::String GetOptionURI() const;

	//! Set Option URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetOptionURI( const plmxml_api::String& );
	
	//! Get the handle of Option URI. Does not resolve the URI.
	plmxml_api::Result GetOptionURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Option URI. URI string is unchanged.
	plmxml_api::Result SetOptionURI( const plmxml_api::Handle& );
	
	//! Resolve Option URI and return an object (handle) it points to.
	plmxml_api::Result ResolveOptionURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Option URI. Clears URI string and handle.
	plmxml_api::Result DeleteOptionURI();
	
	//! Check if Option URI is set
	plmxml_api::logical HasOptionURI( ) const;
	

	//! Get Value URI as plmxml_api::String
	plmxml_api::String GetValueURI() const;

	//! Set Value URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetValueURI( const plmxml_api::String& );
	
	//! Get the handle of Value URI. Does not resolve the URI.
	plmxml_api::Result GetValueURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Value URI. URI string is unchanged.
	plmxml_api::Result SetValueURI( const plmxml_api::Handle& );
	
	//! Resolve Value URI and return an object (handle) it points to.
	plmxml_api::Result ResolveValueURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Value URI. Clears URI string and handle.
	plmxml_api::Result DeleteValueURI();
	
	//! Check if Value URI is set
	plmxml_api::logical HasValueURI( ) const;
	

	//! Get Value of this Derived
	plmxml_api::String GetValue() const;

	//! Set Value of this Derived
	plmxml_api::Result SetValue( const plmxml_api::String &s );
	
	//! Check if Value is set
	plmxml_api::logical HasValue( ) const;
	
	//! Unset Value
	plmxml_api::Result UnsetValue( );
 
// <PLMXML_UserCode type="functionHeaderDerived" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassDerived;


////////////////////////////////////////////////////////////////////////////////////
//! Message class
/*!
\verbatim

      Message - abstract base class for Message Statements.
      
\endverbatim
*/
class PLMXML60_API Message : public Statement
{
public:
     
    //! Default constructor
    Message( );
     
    //! Constructs a Message with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Message( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Message();

private:

	//! Assignment operator
	Message& operator=( const Message& iSrc );

	//! Copy constructor
	Message( const Message& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderMessage" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassMessage;


////////////////////////////////////////////////////////////////////////////////////
//! CheckMessage class
/*!
\verbatim

      Check Message. This is used in VariantRuleChecks.

      Attributes:

      message:          String message to output.
      messageRef:       References a multiple language version of message. If
                        multiple language support is required, messageRef should
                        be used in addition to message.
      
\endverbatim
*/
class PLMXML60_API CheckMessage : public Message
{
public:
     
    //! Default constructor
    CheckMessage( );
     
    //! Constructs a CheckMessage with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    CheckMessage( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~CheckMessage();

private:

	//! Assignment operator
	CheckMessage& operator=( const CheckMessage& iSrc );

	//! Copy constructor
	CheckMessage( const CheckMessage& original );
     
public:

	//! Get Message of this CheckMessage
	plmxml_api::String GetMessage() const;

	//! Set Message of this CheckMessage
	plmxml_api::Result SetMessage( const plmxml_api::String &s );
	
	//! Check if Message is set
	plmxml_api::logical HasMessage( ) const;
	
	//! Unset Message
	plmxml_api::Result UnsetMessage( );

	//! Get Message URI as plmxml_api::String
	plmxml_api::String GetMessageURI() const;

	//! Set Message URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetMessageURI( const plmxml_api::String& );
	
	//! Get the handle of Message URI. Does not resolve the URI.
	plmxml_api::Result GetMessageURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Message URI. URI string is unchanged.
	plmxml_api::Result SetMessageURI( const plmxml_api::Handle& );
	
	//! Resolve Message URI and return an object (handle) it points to.
	plmxml_api::Result ResolveMessageURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Message URI. Clears URI string and handle.
	plmxml_api::Result DeleteMessageURI();
	
	//! Check if Message URI is set
	plmxml_api::logical HasMessageURI( ) const;
	
 
// <PLMXML_UserCode type="functionHeaderCheckMessage" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassCheckMessage;


////////////////////////////////////////////////////////////////////////////////////
//! InformMessage class
/*!
\verbatim

      Inform Message. Outputs an informative message.

      Attributes:

      message:     String message to output.
      
\endverbatim
*/
class PLMXML60_API InformMessage : public Message
{
public:
     
    //! Default constructor
    InformMessage( );
     
    //! Constructs a InformMessage with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    InformMessage( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~InformMessage();

private:

	//! Assignment operator
	InformMessage& operator=( const InformMessage& iSrc );

	//! Copy constructor
	InformMessage( const InformMessage& original );
     
public:

	//! Get Message of this InformMessage
	plmxml_api::String GetMessage() const;

	//! Set Message of this InformMessage
	plmxml_api::Result SetMessage( const plmxml_api::String &s );
	
	//! Check if Message is set
	plmxml_api::logical HasMessage( ) const;
	
	//! Unset Message
	plmxml_api::Result UnsetMessage( );
 
// <PLMXML_UserCode type="functionHeaderInformMessage" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassInformMessage;


////////////////////////////////////////////////////////////////////////////////////
//! WarnMessage class
/*!
\verbatim

      Warn Message. Outputs a warning message.

      Attributes:

      message:     String message to output.
      
\endverbatim
*/
class PLMXML60_API WarnMessage : public Message
{
public:
     
    //! Default constructor
    WarnMessage( );
     
    //! Constructs a WarnMessage with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    WarnMessage( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~WarnMessage();

private:

	//! Assignment operator
	WarnMessage& operator=( const WarnMessage& iSrc );

	//! Copy constructor
	WarnMessage( const WarnMessage& original );
     
public:

	//! Get Message of this WarnMessage
	plmxml_api::String GetMessage() const;

	//! Set Message of this WarnMessage
	plmxml_api::Result SetMessage( const plmxml_api::String &s );
	
	//! Check if Message is set
	plmxml_api::logical HasMessage( ) const;
	
	//! Unset Message
	plmxml_api::Result UnsetMessage( );
 
// <PLMXML_UserCode type="functionHeaderWarnMessage" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassWarnMessage;


////////////////////////////////////////////////////////////////////////////////////
//! ErrorMessage class
/*!
\verbatim

      Error Message. Outputs an error message.

      Attributes:

      message:     String message to output.
      
\endverbatim
*/
class PLMXML60_API ErrorMessage : public Message
{
public:
     
    //! Default constructor
    ErrorMessage( );
     
    //! Constructs a ErrorMessage with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ErrorMessage( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ErrorMessage();

private:

	//! Assignment operator
	ErrorMessage& operator=( const ErrorMessage& iSrc );

	//! Copy constructor
	ErrorMessage( const ErrorMessage& original );
     
public:

	//! Get Message of this ErrorMessage
	plmxml_api::String GetMessage() const;

	//! Set Message of this ErrorMessage
	plmxml_api::Result SetMessage( const plmxml_api::String &s );
	
	//! Check if Message is set
	plmxml_api::logical HasMessage( ) const;
	
	//! Unset Message
	plmxml_api::Result UnsetMessage( );
 
// <PLMXML_UserCode type="functionHeaderErrorMessage" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassErrorMessage;


////////////////////////////////////////////////////////////////////////////////////
//! If class
/*!
\verbatim

      ConditionalStatement. This is an If ... Then ... Else ... Statement.

      Elements:

      First, an element derived from LogicalExpression.

      Then:         StatementList element, executed if the LogicalExpression returns
                    true.
      Else:         Optional StatementList element, executed if the LogicalExpression
                    returns false.
      
\endverbatim
*/
class PLMXML60_API If : public Statement
{
public:
     
    //! Default constructor
    If( );
     
    //! Constructs a If with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    If( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~If();

private:

	//! Assignment operator
	If& operator=( const If& iSrc );

	//! Copy constructor
	If( const If& original );
     
public:

	//! Add LogicalExpression child element to this If. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	LogicalExpression *AddLogicalExpression();
     
	//! Set LogicalExpression child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetLogicalExpression( LogicalExpression *arg );
     
	//! Get LogicalExpression child element of this If.
	LogicalExpression *GetLogicalExpression() const;
     
	//! Detach and delete LogicalExpression child element tree from this If.
	void DeleteLogicalExpression();

	//! Add Then child element to this If. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	StatementList *AddThen();
     
	//! Set Then child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetThen( StatementList *arg );
     
	//! Get Then child element of this If.
	StatementList *GetThen() const;
     
	//! Detach and delete Then child element tree from this If.
	void DeleteThen();

	//! Add Else child element to this If. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	StatementList *AddElse();
     
	//! Set Else child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetElse( StatementList *arg );
     
	//! Get Else child element of this If.
	StatementList *GetElse() const;
     
	//! Detach and delete Else child element tree from this If.
	void DeleteElse();
 
// <PLMXML_UserCode type="functionHeaderIf" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassIf;


////////////////////////////////////////////////////////////////////////////////////
//! VariantRule class
/*!
\verbatim

      VariantRule. This specifies a configuration by giving specified values for
      a set of Options.
      
      Attributes:
      
      configuredRef: The StructureRevision this VariantRule is associated with, if any.
      
      Elements:

      A non-empty sequence of Set, Fix and Derived Statements, which specify values for a set of
      Options.
      
\endverbatim
*/
class PLMXML60_API VariantRule : public ConfigRule
{
public:
     
    //! Default constructor
    VariantRule( );
     
    //! Constructs a VariantRule with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    VariantRule( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~VariantRule();

private:

	//! Assignment operator
	VariantRule& operator=( const VariantRule& iSrc );

	//! Copy constructor
	VariantRule( const VariantRule& original );
     
public:

	//! Get Configured URI as plmxml_api::String
	plmxml_api::String GetConfiguredURI() const;

	//! Set Configured URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetConfiguredURI( const plmxml_api::String& );
	
	//! Get the handle of Configured URI. Does not resolve the URI.
	plmxml_api::Result GetConfiguredURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Configured URI. URI string is unchanged.
	plmxml_api::Result SetConfiguredURI( const plmxml_api::Handle& );
	
	//! Resolve Configured URI and return an object (handle) it points to.
	plmxml_api::Result ResolveConfiguredURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Configured URI. Clears URI string and handle.
	plmxml_api::Result DeleteConfiguredURI();
	
	//! Check if Configured URI is set
	plmxml_api::logical HasConfiguredURI( ) const;
	

	//! Add Set child element to this VariantRule. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Set *AddSet();
     
	//! Add 'arg' as Set child element to this VariantRule.
	plmxml_api::Result AddSet( Set *arg );

	//! Detach and delete all Set child elements.
	void DeleteSets();
     
	//! Get number of Set child elements.
	int NumberOfSets() const;
     
	//! Get i'th Set child element.
	Set *GetSet( int i ) const;
     
	//! Get all Set child element as an array
	void GetSets( plmxml_api::Array<Set*> &array ) const;
	     
	//! Detach and delete i'th Set child element
	void DeleteSet( int i );
     
	//! Detach and delete 'arg' if it's one of the Set child elements
	void DeleteSet( Set *arg );

	//! Add Fix child element to this VariantRule. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Fix *AddFix();
     
	//! Add 'arg' as Fix child element to this VariantRule.
	plmxml_api::Result AddFix( Fix *arg );

	//! Detach and delete all Fix child elements.
	void DeleteFixes();
     
	//! Get number of Fix child elements.
	int NumberOfFixes() const;
     
	//! Get i'th Fix child element.
	Fix *GetFix( int i ) const;
     
	//! Get all Fix child element as an array
	void GetFixes( plmxml_api::Array<Fix*> &array ) const;
	     
	//! Detach and delete i'th Fix child element
	void DeleteFix( int i );
     
	//! Detach and delete 'arg' if it's one of the Fix child elements
	void DeleteFix( Fix *arg );

	//! Add Derived child element to this VariantRule. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Derived *AddDerived();
     
	//! Add 'arg' as Derived child element to this VariantRule.
	plmxml_api::Result AddDerived( Derived *arg );

	//! Detach and delete all Derived child elements.
	void DeleteDeriveds();
     
	//! Get number of Derived child elements.
	int NumberOfDeriveds() const;
     
	//! Get i'th Derived child element.
	Derived *GetDerived( int i ) const;
     
	//! Get all Derived child element as an array
	void GetDeriveds( plmxml_api::Array<Derived*> &array ) const;
	     
	//! Detach and delete i'th Derived child element
	void DeleteDerived( int i );
     
	//! Detach and delete 'arg' if it's one of the Derived child elements
	void DeleteDerived( Derived *arg );
 
// <PLMXML_UserCode type="functionHeaderVariantRule" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassVariantRule;


////////////////////////////////////////////////////////////////////////////////////
//! VariantRuleCheck class
/*!
\verbatim

      VariantRuleCheck. This outputs a Check Message if a condition is true.
      
      Elements:

      An element derived from LogicalExpression.
      A Check element.
      
\endverbatim
*/
class PLMXML60_API VariantRuleCheck : public AttribOwner
{
public:
     
    //! Default constructor
    VariantRuleCheck( );
     
    //! Constructs a VariantRuleCheck with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    VariantRuleCheck( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~VariantRuleCheck();

private:

	//! Assignment operator
	VariantRuleCheck& operator=( const VariantRuleCheck& iSrc );

	//! Copy constructor
	VariantRuleCheck( const VariantRuleCheck& original );
     
public:

	//! Add LogicalExpression child element to this VariantRuleCheck. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	LogicalExpression *AddLogicalExpression();
     
	//! Set LogicalExpression child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetLogicalExpression( LogicalExpression *arg );
     
	//! Get LogicalExpression child element of this VariantRuleCheck.
	LogicalExpression *GetLogicalExpression() const;
     
	//! Detach and delete LogicalExpression child element tree from this VariantRuleCheck.
	void DeleteLogicalExpression();

	//! Add CheckMessage child element to this VariantRuleCheck. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	CheckMessage *AddCheckMessage();
     
	//! Set CheckMessage child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetCheckMessage( CheckMessage *arg );
     
	//! Get CheckMessage child element of this VariantRuleCheck.
	CheckMessage *GetCheckMessage() const;
     
	//! Detach and delete CheckMessage child element tree from this VariantRuleCheck.
	void DeleteCheckMessage();
 
// <PLMXML_UserCode type="functionHeaderVariantRuleCheck" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassVariantRuleCheck;


////////////////////////////////////////////////////////////////////////////////////
//! VariantDefault class
/*!
\verbatim

      VariantDefault. An abstract base class for Variant Defaults.
      
\endverbatim
*/
class PLMXML60_API VariantDefault : public AttribOwner
{
public:
     
    //! Default constructor
    VariantDefault( );
     
    //! Constructs a VariantDefault with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    VariantDefault( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~VariantDefault();

private:

	//! Assignment operator
	VariantDefault& operator=( const VariantDefault& iSrc );

	//! Copy constructor
	VariantDefault( const VariantDefault& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderVariantDefault" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassVariantDefault;


////////////////////////////////////////////////////////////////////////////////////
//! VariantDefaultFixed class
/*!
\verbatim

      VariantDefaultFixed. This is a collection of 'SetDefault' Statements.

      Elements:
 
      A non-empty sequence of SetDefault Statements, which set the values of some
      Options, if they are not already set.
      
\endverbatim
*/
class PLMXML60_API VariantDefaultFixed : public VariantDefault
{
public:
     
    //! Default constructor
    VariantDefaultFixed( );
     
    //! Constructs a VariantDefaultFixed with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    VariantDefaultFixed( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~VariantDefaultFixed();

private:

	//! Assignment operator
	VariantDefaultFixed& operator=( const VariantDefaultFixed& iSrc );

	//! Copy constructor
	VariantDefaultFixed( const VariantDefaultFixed& original );
     
public:

	//! Add SetDefault child element to this VariantDefaultFixed. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	SetDefault *AddSetDefault();
     
	//! Add 'arg' as SetDefault child element to this VariantDefaultFixed.
	plmxml_api::Result AddSetDefault( SetDefault *arg );

	//! Detach and delete all SetDefault child elements.
	void DeleteSetDefaults();
     
	//! Get number of SetDefault child elements.
	int NumberOfSetDefaults() const;
     
	//! Get i'th SetDefault child element.
	SetDefault *GetSetDefault( int i ) const;
     
	//! Get all SetDefault child element as an array
	void GetSetDefaults( plmxml_api::Array<SetDefault*> &array ) const;
	     
	//! Detach and delete i'th SetDefault child element
	void DeleteSetDefault( int i );
     
	//! Detach and delete 'arg' if it's one of the SetDefault child elements
	void DeleteSetDefault( SetDefault *arg );
 
// <PLMXML_UserCode type="functionHeaderVariantDefaultFixed" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassVariantDefaultFixed;


////////////////////////////////////////////////////////////////////////////////////
//! VariantDefaultDerived class
/*!
\verbatim

      VariantDefaultDerived. A set of SetDefault Statements which depend on a 
      LogicalExpression.

      Elements:

      An element derived from LogicalExpression.
      A non-empty sequence of SetDefault Statements, which are executed if the
          expression returns true.
      
\endverbatim
*/
class PLMXML60_API VariantDefaultDerived : public VariantDefault
{
public:
     
    //! Default constructor
    VariantDefaultDerived( );
     
    //! Constructs a VariantDefaultDerived with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    VariantDefaultDerived( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~VariantDefaultDerived();

private:

	//! Assignment operator
	VariantDefaultDerived& operator=( const VariantDefaultDerived& iSrc );

	//! Copy constructor
	VariantDefaultDerived( const VariantDefaultDerived& original );
     
public:

	//! Add LogicalExpression child element to this VariantDefaultDerived. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	LogicalExpression *AddLogicalExpression();
     
	//! Set LogicalExpression child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetLogicalExpression( LogicalExpression *arg );
     
	//! Get LogicalExpression child element of this VariantDefaultDerived.
	LogicalExpression *GetLogicalExpression() const;
     
	//! Detach and delete LogicalExpression child element tree from this VariantDefaultDerived.
	void DeleteLogicalExpression();

	//! Add SetDefault child element to this VariantDefaultDerived. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	SetDefault *AddSetDefault();
     
	//! Add 'arg' as SetDefault child element to this VariantDefaultDerived.
	plmxml_api::Result AddSetDefault( SetDefault *arg );

	//! Detach and delete all SetDefault child elements.
	void DeleteSetDefaults();
     
	//! Get number of SetDefault child elements.
	int NumberOfSetDefaults() const;
     
	//! Get i'th SetDefault child element.
	SetDefault *GetSetDefault( int i ) const;
     
	//! Get all SetDefault child element as an array
	void GetSetDefaults( plmxml_api::Array<SetDefault*> &array ) const;
	     
	//! Detach and delete i'th SetDefault child element
	void DeleteSetDefault( int i );
     
	//! Detach and delete 'arg' if it's one of the SetDefault child elements
	void DeleteSetDefault( SetDefault *arg );
 
// <PLMXML_UserCode type="functionHeaderVariantDefaultDerived" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassVariantDefaultDerived;


////////////////////////////////////////////////////////////////////////////////////
//! VariantCondition class
/*!
\verbatim

      VariantCondition. This contains a logical expression which determines whether
      the Instance it is attached to is 'loaded', i.e. appears in the configuration.

      Elements:

      A single element derived from LogicalExpression.
      
\endverbatim
*/
class PLMXML60_API VariantCondition : public AttribOwner
{
public:
     
    //! Default constructor
    VariantCondition( );
     
    //! Constructs a VariantCondition with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    VariantCondition( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~VariantCondition();

private:

	//! Assignment operator
	VariantCondition& operator=( const VariantCondition& iSrc );

	//! Copy constructor
	VariantCondition( const VariantCondition& original );
     
public:

	//! Add LogicalExpression child element to this VariantCondition. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	LogicalExpression *AddLogicalExpression();
     
	//! Set LogicalExpression child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetLogicalExpression( LogicalExpression *arg );
     
	//! Get LogicalExpression child element of this VariantCondition.
	LogicalExpression *GetLogicalExpression() const;
     
	//! Detach and delete LogicalExpression child element tree from this VariantCondition.
	void DeleteLogicalExpression();
 
// <PLMXML_UserCode type="functionHeaderVariantCondition" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassVariantCondition;


////////////////////////////////////////////////////////////////////////////////////
//! UnitComponent class
/*!
\verbatim

      Component of a standard SI unit of measurement

      Attributes:
      
      prefix:      multiplier prefix, e.g. "kilo", "micro"
      exponent:    power to which unit is raised, e.g. seconds**-2
      
\endverbatim
*/
class PLMXML60_API UnitComponent : public plmxml_api::Object
{
public:
     
    //! Default constructor
    UnitComponent( );
     
    //! Constructs a UnitComponent with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    UnitComponent( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~UnitComponent();

private:

	//! Assignment operator
	UnitComponent& operator=( const UnitComponent& iSrc );

	//! Copy constructor
	UnitComponent( const UnitComponent& original );
     
public:

	//! Set Exponent
	plmxml_api::Result SetExponent( double arg );

     //! Get Exponent
	double GetExponent() const;

	//! Check if Exponent is set
	plmxml_api::logical HasExponent() const;

	//! Unset Exponent
	plmxml_api::Result UnsetExponent();

	//! Set Prefix
	plmxml_api::Result SetPrefix( const eUnitPrefixType& arg );

	//! Get Prefix
	eUnitPrefixType GetPrefix() const;
 
// <PLMXML_UserCode type="functionHeaderUnitComponent" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassUnitComponent;


////////////////////////////////////////////////////////////////////////////////////
//! GeneralUnitComponent class
/*!
\verbatim

      Component of a unit of measurement, other than a standard SI unit.
      The name of the unit can be any string, to allow for the numerous units
      in use. However the following strings should be used for the corresponding
      common units:
      
      SI units (other than those given explicitly in the Unit element):
      
      "gram", "hertz", "newton", "pascal", "joule", "watt", "coulomb", "volt",
      "farad", "ohm", "siemens", "weber", "tesla", "henry", "degreeCelsius",
      "lumen", "lux", "becquerel", "gray", "sievert".
      "are", "hectare", "litre" (note European spelling).

      Common non-SI units:

      "minute", "hour", "day".
      "inch", "foot", "yard", "mile", "nautical mile".
      "acre".
      "pint", "quart", "gallon", "imperial pint", "imperial quart",
      "imperial gallon".
      "ounce", "pound".

      Attributes:

      name:             name of unit, e.g. "inch"
      prefix:           multiplier prefix, e.g. "kilo", "micro"
      exponent:         power to which unit is raised, e.g. cm**-2
      nameRef:          References a multiple language version of name. If
                        multiple language support is required, nameRef should be
                        used in addition to name.
      
\endverbatim
*/
class PLMXML60_API GeneralUnitComponent : public plmxml_api::Object
{
public:
     
    //! Default constructor
    GeneralUnitComponent( );
     
    //! Constructs a GeneralUnitComponent with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    GeneralUnitComponent( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~GeneralUnitComponent();

private:

	//! Assignment operator
	GeneralUnitComponent& operator=( const GeneralUnitComponent& iSrc );

	//! Copy constructor
	GeneralUnitComponent( const GeneralUnitComponent& original );
     
public:

	//! Get Name of this GeneralUnitComponent
	plmxml_api::String GetName() const;

	//! Set Name of this GeneralUnitComponent
	plmxml_api::Result SetName( const plmxml_api::String &s );
	
	//! Check if Name is set
	plmxml_api::logical HasName( ) const;
	
	//! Unset Name
	plmxml_api::Result UnsetName( );

	//! Set Exponent
	plmxml_api::Result SetExponent( double arg );

     //! Get Exponent
	double GetExponent() const;

	//! Check if Exponent is set
	plmxml_api::logical HasExponent() const;

	//! Unset Exponent
	plmxml_api::Result UnsetExponent();

	//! Set Prefix
	plmxml_api::Result SetPrefix( const eUnitPrefixType& arg );

	//! Get Prefix
	eUnitPrefixType GetPrefix() const;

	//! Get Name URI as plmxml_api::String
	plmxml_api::String GetNameURI() const;

	//! Set Name URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetNameURI( const plmxml_api::String& );
	
	//! Get the handle of Name URI. Does not resolve the URI.
	plmxml_api::Result GetNameURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Name URI. URI string is unchanged.
	plmxml_api::Result SetNameURI( const plmxml_api::Handle& );
	
	//! Resolve Name URI and return an object (handle) it points to.
	plmxml_api::Result ResolveNameURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Name URI. Clears URI string and handle.
	plmxml_api::Result DeleteNameURI();
	
	//! Check if Name URI is set
	plmxml_api::logical HasNameURI( ) const;
	
 
// <PLMXML_UserCode type="functionHeaderGeneralUnitComponent" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassGeneralUnitComponent;


////////////////////////////////////////////////////////////////////////////////////
//! Unit class
/*!
\verbatim

      Unit - a unit of measurement, e.g. gallons, or kilogram/metre**2.

      This defines the unit as a combination of powers of other units.
      The standard SI units are represented explicitly, other units are 
      given by a named element.

      Elements:

      Metre:         a UnitComponent element giving the length exponent.
      ...etc...
      
      GeneralUnit:   powers of specified units.
      
\endverbatim
*/
class PLMXML60_API Unit : public AttribOwner
{
public:
     
    //! Default constructor
    Unit( );
     
    //! Constructs a Unit with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Unit( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Unit();

private:

	//! Assignment operator
	Unit& operator=( const Unit& iSrc );

	//! Copy constructor
	Unit( const Unit& original );
     
public:

	//! Add Metre child element to this Unit. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	UnitComponent *AddMetre();
     
	//! Add 'arg' as Metre child element to this Unit.
	plmxml_api::Result AddMetre( UnitComponent *arg );

	//! Detach and delete all Metre child elements.
	void DeleteMetres();
     
	//! Get number of Metre child elements.
	int NumberOfMetres() const;
     
	//! Get i'th Metre child element.
	UnitComponent *GetMetre( int i ) const;
     
	//! Get all Metre child element as an array
	void GetMetres( plmxml_api::Array<UnitComponent*> &array ) const;
	     
	//! Detach and delete i'th Metre child element
	void DeleteMetre( int i );
     
	//! Detach and delete 'arg' if it's one of the Metre child elements
	void DeleteMetre( UnitComponent *arg );

	//! Add Kilogram child element to this Unit. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	UnitComponent *AddKilogram();
     
	//! Add 'arg' as Kilogram child element to this Unit.
	plmxml_api::Result AddKilogram( UnitComponent *arg );

	//! Detach and delete all Kilogram child elements.
	void DeleteKilograms();
     
	//! Get number of Kilogram child elements.
	int NumberOfKilograms() const;
     
	//! Get i'th Kilogram child element.
	UnitComponent *GetKilogram( int i ) const;
     
	//! Get all Kilogram child element as an array
	void GetKilograms( plmxml_api::Array<UnitComponent*> &array ) const;
	     
	//! Detach and delete i'th Kilogram child element
	void DeleteKilogram( int i );
     
	//! Detach and delete 'arg' if it's one of the Kilogram child elements
	void DeleteKilogram( UnitComponent *arg );

	//! Add Second child element to this Unit. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	UnitComponent *AddSecond();
     
	//! Add 'arg' as Second child element to this Unit.
	plmxml_api::Result AddSecond( UnitComponent *arg );

	//! Detach and delete all Second child elements.
	void DeleteSeconds();
     
	//! Get number of Second child elements.
	int NumberOfSeconds() const;
     
	//! Get i'th Second child element.
	UnitComponent *GetSecond( int i ) const;
     
	//! Get all Second child element as an array
	void GetSeconds( plmxml_api::Array<UnitComponent*> &array ) const;
	     
	//! Detach and delete i'th Second child element
	void DeleteSecond( int i );
     
	//! Detach and delete 'arg' if it's one of the Second child elements
	void DeleteSecond( UnitComponent *arg );

	//! Add Ampere child element to this Unit. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	UnitComponent *AddAmpere();
     
	//! Add 'arg' as Ampere child element to this Unit.
	plmxml_api::Result AddAmpere( UnitComponent *arg );

	//! Detach and delete all Ampere child elements.
	void DeleteAmperes();
     
	//! Get number of Ampere child elements.
	int NumberOfAmperes() const;
     
	//! Get i'th Ampere child element.
	UnitComponent *GetAmpere( int i ) const;
     
	//! Get all Ampere child element as an array
	void GetAmperes( plmxml_api::Array<UnitComponent*> &array ) const;
	     
	//! Detach and delete i'th Ampere child element
	void DeleteAmpere( int i );
     
	//! Detach and delete 'arg' if it's one of the Ampere child elements
	void DeleteAmpere( UnitComponent *arg );

	//! Add Mole child element to this Unit. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	UnitComponent *AddMole();
     
	//! Add 'arg' as Mole child element to this Unit.
	plmxml_api::Result AddMole( UnitComponent *arg );

	//! Detach and delete all Mole child elements.
	void DeleteMoles();
     
	//! Get number of Mole child elements.
	int NumberOfMoles() const;
     
	//! Get i'th Mole child element.
	UnitComponent *GetMole( int i ) const;
     
	//! Get all Mole child element as an array
	void GetMoles( plmxml_api::Array<UnitComponent*> &array ) const;
	     
	//! Detach and delete i'th Mole child element
	void DeleteMole( int i );
     
	//! Detach and delete 'arg' if it's one of the Mole child elements
	void DeleteMole( UnitComponent *arg );

	//! Add Candela child element to this Unit. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	UnitComponent *AddCandela();
     
	//! Add 'arg' as Candela child element to this Unit.
	plmxml_api::Result AddCandela( UnitComponent *arg );

	//! Detach and delete all Candela child elements.
	void DeleteCandelas();
     
	//! Get number of Candela child elements.
	int NumberOfCandelas() const;
     
	//! Get i'th Candela child element.
	UnitComponent *GetCandela( int i ) const;
     
	//! Get all Candela child element as an array
	void GetCandelas( plmxml_api::Array<UnitComponent*> &array ) const;
	     
	//! Detach and delete i'th Candela child element
	void DeleteCandela( int i );
     
	//! Detach and delete 'arg' if it's one of the Candela child elements
	void DeleteCandela( UnitComponent *arg );

	//! Add Kelvin child element to this Unit. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	UnitComponent *AddKelvin();
     
	//! Add 'arg' as Kelvin child element to this Unit.
	plmxml_api::Result AddKelvin( UnitComponent *arg );

	//! Detach and delete all Kelvin child elements.
	void DeleteKelvins();
     
	//! Get number of Kelvin child elements.
	int NumberOfKelvins() const;
     
	//! Get i'th Kelvin child element.
	UnitComponent *GetKelvin( int i ) const;
     
	//! Get all Kelvin child element as an array
	void GetKelvins( plmxml_api::Array<UnitComponent*> &array ) const;
	     
	//! Detach and delete i'th Kelvin child element
	void DeleteKelvin( int i );
     
	//! Detach and delete 'arg' if it's one of the Kelvin child elements
	void DeleteKelvin( UnitComponent *arg );

	//! Add GeneralUnit child element to this Unit. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	GeneralUnitComponent *AddGeneralUnit();
     
	//! Add 'arg' as GeneralUnit child element to this Unit.
	plmxml_api::Result AddGeneralUnit( GeneralUnitComponent *arg );

	//! Detach and delete all GeneralUnit child elements.
	void DeleteGeneralUnits();
     
	//! Get number of GeneralUnit child elements.
	int NumberOfGeneralUnits() const;
     
	//! Get i'th GeneralUnit child element.
	GeneralUnitComponent *GetGeneralUnit( int i ) const;
     
	//! Get all GeneralUnit child element as an array
	void GetGeneralUnits( plmxml_api::Array<GeneralUnitComponent*> &array ) const;
	     
	//! Detach and delete i'th GeneralUnit child element
	void DeleteGeneralUnit( int i );
     
	//! Detach and delete 'arg' if it's one of the GeneralUnit child elements
	void DeleteGeneralUnit( GeneralUnitComponent *arg );
 
// <PLMXML_UserCode type="functionHeaderUnit" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassUnit;


////////////////////////////////////////////////////////////////////////////////////
//! Owner class
/*!
\verbatim

      Base class for entities which can 'own' objects (people, organisations, users, 
      sites, etc).
      
\endverbatim
*/
class PLMXML60_API Owner : public AttribOwner
{
public:
     
    //! Default constructor
    Owner( );
     
    //! Constructs a Owner with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Owner( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Owner();

private:

	//! Assignment operator
	Owner& operator=( const Owner& iSrc );

	//! Copy constructor
	Owner( const Owner& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderOwner" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassOwner;


////////////////////////////////////////////////////////////////////////////////////
//! Person class
/*!
\verbatim

      An individual Person.

      Attributes:

      firstName:    first name.
      middleNames:  middle names and/or initials.
      lastName:     last (family) name.
      userId:       user Id.
      addressRef:   optional reference to an Address element.
      
\endverbatim
*/
class PLMXML60_API Person : public Owner
{
public:
     
    //! Default constructor
    Person( );
     
    //! Constructs a Person with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Person( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Person();

private:

	//! Assignment operator
	Person& operator=( const Person& iSrc );

	//! Copy constructor
	Person( const Person& original );
     
public:

	//! Get Address URI as plmxml_api::String
	plmxml_api::String GetAddressURI() const;

	//! Set Address URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetAddressURI( const plmxml_api::String& );
	
	//! Get the handle of Address URI. Does not resolve the URI.
	plmxml_api::Result GetAddressURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Address URI. URI string is unchanged.
	plmxml_api::Result SetAddressURI( const plmxml_api::Handle& );
	
	//! Resolve Address URI and return an object (handle) it points to.
	plmxml_api::Result ResolveAddressURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Address URI. Clears URI string and handle.
	plmxml_api::Result DeleteAddressURI();
	
	//! Check if Address URI is set
	plmxml_api::logical HasAddressURI( ) const;
	

	//! Get FirstName of this Person
	plmxml_api::String GetFirstName() const;

	//! Set FirstName of this Person
	plmxml_api::Result SetFirstName( const plmxml_api::String &s );
	
	//! Check if FirstName is set
	plmxml_api::logical HasFirstName( ) const;
	
	//! Unset FirstName
	plmxml_api::Result UnsetFirstName( );

	//! Get UserId of this Person
	plmxml_api::String GetUserId() const;

	//! Set UserId of this Person
	plmxml_api::Result SetUserId( const plmxml_api::String &s );
	
	//! Check if UserId is set
	plmxml_api::logical HasUserId( ) const;
	
	//! Unset UserId
	plmxml_api::Result UnsetUserId( );

	//! Get MiddleNames of this Person
	plmxml_api::String GetMiddleNames() const;

	//! Set MiddleNames of this Person
	plmxml_api::Result SetMiddleNames( const plmxml_api::String &s );
	
	//! Check if MiddleNames is set
	plmxml_api::logical HasMiddleNames( ) const;
	
	//! Unset MiddleNames
	plmxml_api::Result UnsetMiddleNames( );

	//! Get LastName of this Person
	plmxml_api::String GetLastName() const;

	//! Set LastName of this Person
	plmxml_api::Result SetLastName( const plmxml_api::String &s );
	
	//! Check if LastName is set
	plmxml_api::logical HasLastName( ) const;
	
	//! Unset LastName
	plmxml_api::Result UnsetLastName( );
 
// <PLMXML_UserCode type="functionHeaderPerson" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassPerson;


////////////////////////////////////////////////////////////////////////////////////
//! DisciplineRelation class
/*!
\verbatim

      Enables a User to be associated with a Discipline, at a particular level

      Attributes:

      disciplineRef:    reference to a Discipline
      level:            name of the relevant Level
      levelRef:         References a multiple language version of level. If
                        multiple language support is required, levelRef should
                        be used in addition to level.

      Sub-elements:

      UserData:         Represents user-definable properties on the
                        relationship.
      
\endverbatim
*/
class PLMXML60_API DisciplineRelation : public IdObject
{
public:
     
    //! Default constructor
    DisciplineRelation( );
     
    //! Constructs a DisciplineRelation with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    DisciplineRelation( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~DisciplineRelation();

private:

	//! Assignment operator
	DisciplineRelation& operator=( const DisciplineRelation& iSrc );

	//! Copy constructor
	DisciplineRelation( const DisciplineRelation& original );
     
public:

	//! Get Level of this DisciplineRelation
	plmxml_api::String GetLevel() const;

	//! Set Level of this DisciplineRelation
	plmxml_api::Result SetLevel( const plmxml_api::String &s );
	
	//! Check if Level is set
	plmxml_api::logical HasLevel( ) const;
	
	//! Unset Level
	plmxml_api::Result UnsetLevel( );

	//! Get Discipline URI as plmxml_api::String
	plmxml_api::String GetDisciplineURI() const;

	//! Set Discipline URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetDisciplineURI( const plmxml_api::String& );
	
	//! Get the handle of Discipline URI. Does not resolve the URI.
	plmxml_api::Result GetDisciplineURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Discipline URI. URI string is unchanged.
	plmxml_api::Result SetDisciplineURI( const plmxml_api::Handle& );
	
	//! Resolve Discipline URI and return an object (handle) it points to.
	plmxml_api::Result ResolveDisciplineURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Discipline URI. Clears URI string and handle.
	plmxml_api::Result DeleteDisciplineURI();
	
	//! Check if Discipline URI is set
	plmxml_api::logical HasDisciplineURI( ) const;
	

	//! Get Level URI as plmxml_api::String
	plmxml_api::String GetLevelURI() const;

	//! Set Level URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetLevelURI( const plmxml_api::String& );
	
	//! Get the handle of Level URI. Does not resolve the URI.
	plmxml_api::Result GetLevelURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Level URI. URI string is unchanged.
	plmxml_api::Result SetLevelURI( const plmxml_api::Handle& );
	
	//! Resolve Level URI and return an object (handle) it points to.
	plmxml_api::Result ResolveLevelURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Level URI. Clears URI string and handle.
	plmxml_api::Result DeleteLevelURI();
	
	//! Check if Level URI is set
	plmxml_api::logical HasLevelURI( ) const;
	

	//! Add UserData child element to this DisciplineRelation. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	UserData *AddUserData();
     
	//! Add 'arg' as UserData child element to this DisciplineRelation.
	plmxml_api::Result AddUserData( UserData *arg );

	//! Detach and delete all UserData child elements.
	void DeleteUserDatas();
     
	//! Get number of UserData child elements.
	int NumberOfUserDatas() const;
     
	//! Get i'th UserData child element.
	UserData *GetUserData( int i ) const;
     
	//! Get all UserData child element as an array
	void GetUserDatas( plmxml_api::Array<UserData*> &array ) const;
	     
	//! Detach and delete i'th UserData child element
	void DeleteUserData( int i );
     
	//! Detach and delete 'arg' if it's one of the UserData child elements
	void DeleteUserData( UserData *arg );
 
// <PLMXML_UserCode type="functionHeaderDisciplineRelation" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassDisciplineRelation;


////////////////////////////////////////////////////////////////////////////////////
//! User class
/*!
\verbatim

      A User, i.e. a user account on a computer system.

      Attributes:

      userId:        User Id.
      personRef:     optional reference to a Person element.
      calendarRef:   A reference to the Calendar of the User.

      Elements:

      DisciplineRelation: used to associate a User with a Discipline.
      
\endverbatim
*/
class PLMXML60_API User : public Owner
{
public:
     
    //! Default constructor
    User( );
     
    //! Constructs a User with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    User( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~User();

private:

	//! Assignment operator
	User& operator=( const User& iSrc );

	//! Copy constructor
	User( const User& original );
     
public:

	//! Get Calendar URI as plmxml_api::String
	plmxml_api::String GetCalendarURI() const;

	//! Set Calendar URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetCalendarURI( const plmxml_api::String& );
	
	//! Get the handle of Calendar URI. Does not resolve the URI.
	plmxml_api::Result GetCalendarURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Calendar URI. URI string is unchanged.
	plmxml_api::Result SetCalendarURI( const plmxml_api::Handle& );
	
	//! Resolve Calendar URI and return an object (handle) it points to.
	plmxml_api::Result ResolveCalendarURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Calendar URI. Clears URI string and handle.
	plmxml_api::Result DeleteCalendarURI();
	
	//! Check if Calendar URI is set
	plmxml_api::logical HasCalendarURI( ) const;
	

	//! Get UserId of this User
	plmxml_api::String GetUserId() const;

	//! Set UserId of this User
	plmxml_api::Result SetUserId( const plmxml_api::String &s );
	
	//! Check if UserId is set
	plmxml_api::logical HasUserId( ) const;
	
	//! Unset UserId
	plmxml_api::Result UnsetUserId( );

	//! Get Person URI as plmxml_api::String
	plmxml_api::String GetPersonURI() const;

	//! Set Person URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetPersonURI( const plmxml_api::String& );
	
	//! Get the handle of Person URI. Does not resolve the URI.
	plmxml_api::Result GetPersonURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Person URI. URI string is unchanged.
	plmxml_api::Result SetPersonURI( const plmxml_api::Handle& );
	
	//! Resolve Person URI and return an object (handle) it points to.
	plmxml_api::Result ResolvePersonURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Person URI. Clears URI string and handle.
	plmxml_api::Result DeletePersonURI();
	
	//! Check if Person URI is set
	plmxml_api::logical HasPersonURI( ) const;
	

	//! Add DisciplineRelation child element to this User. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	DisciplineRelation *AddDisciplineRelation();
     
	//! Add 'arg' as DisciplineRelation child element to this User.
	plmxml_api::Result AddDisciplineRelation( DisciplineRelation *arg );

	//! Detach and delete all DisciplineRelation child elements.
	void DeleteDisciplineRelations();
     
	//! Get number of DisciplineRelation child elements.
	int NumberOfDisciplineRelations() const;
     
	//! Get i'th DisciplineRelation child element.
	DisciplineRelation *GetDisciplineRelation( int i ) const;
     
	//! Get all DisciplineRelation child element as an array
	void GetDisciplineRelations( plmxml_api::Array<DisciplineRelation*> &array ) const;
	     
	//! Detach and delete i'th DisciplineRelation child element
	void DeleteDisciplineRelation( int i );
     
	//! Detach and delete 'arg' if it's one of the DisciplineRelation child elements
	void DeleteDisciplineRelation( DisciplineRelation *arg );
 
// <PLMXML_UserCode type="functionHeaderUser" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassUser;


////////////////////////////////////////////////////////////////////////////////////
//! Organisation class
/*!
\verbatim

      An organisation, i.e. a group of people or users. Organisations are hierarchical.
      People/Users are associated with organisations by means of an OrganisationMember 
      element, which also specifies a Role.

      Attributes:

      (name:            Name, inherited from DescriptionBase)
      address:          Optional reference to Address.
      organisationRefs: Reference to sub-organisations.
      cageCode:         CAGE code (5 characters). This is a US government company code.
      disciplineRefs:   Disciplines associated with this Organisation. There is no
                        implication that Users in this Organisation belong to these
                        Disciplines.
      type:             The type of the Organisation, for example, projectTeam.
      
\endverbatim
*/
class PLMXML60_API Organisation : public Owner
{
public:
     
    //! Default constructor
    Organisation( );
     
    //! Constructs a Organisation with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Organisation( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Organisation();

private:

	//! Assignment operator
	Organisation& operator=( const Organisation& iSrc );

	//! Copy constructor
	Organisation( const Organisation& original );
     
public:

	//! Get number of URIs in Organisation
	int NumberOfOrganisationURIs() const;

	//! Get i'th URI in Organisation
	plmxml_api::String GetOrganisationURI( int i ) const;

	//! Add a URI to Organisation array. Call ResolveOrganisationURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddOrganisationURI( const plmxml_api::String& u );

	//! Set i'th URI in Organisation array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetOrganisationURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Organisation URI. Does not resolve the URI.
	plmxml_api::Result GetOrganisationURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Organisation array.
	plmxml_api::Result AddOrganisationURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Organisation array to point to 'handle'.
	plmxml_api::Result SetOrganisationURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Organisation points to.
	plmxml_api::Result ResolveOrganisationURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Organisation array.
	plmxml_api::Result DeleteOrganisationURI( int i );

	//! Remove all URIs from Organisation array.
	plmxml_api::Result DeleteOrganisationURIs( );
	
	//! Check if Organisation is set
	plmxml_api::logical HasOrganisationURIs( ) const;

	//! Get number of URIs in Discipline
	int NumberOfDisciplineURIs() const;

	//! Get i'th URI in Discipline
	plmxml_api::String GetDisciplineURI( int i ) const;

	//! Add a URI to Discipline array. Call ResolveDisciplineURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddDisciplineURI( const plmxml_api::String& u );

	//! Set i'th URI in Discipline array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetDisciplineURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Discipline URI. Does not resolve the URI.
	plmxml_api::Result GetDisciplineURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Discipline array.
	plmxml_api::Result AddDisciplineURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Discipline array to point to 'handle'.
	plmxml_api::Result SetDisciplineURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Discipline points to.
	plmxml_api::Result ResolveDisciplineURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Discipline array.
	plmxml_api::Result DeleteDisciplineURI( int i );

	//! Remove all URIs from Discipline array.
	plmxml_api::Result DeleteDisciplineURIs( );
	
	//! Check if Discipline is set
	plmxml_api::logical HasDisciplineURIs( ) const;

	//! Get Address URI as plmxml_api::String
	plmxml_api::String GetAddressURI() const;

	//! Set Address URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetAddressURI( const plmxml_api::String& );
	
	//! Get the handle of Address URI. Does not resolve the URI.
	plmxml_api::Result GetAddressURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Address URI. URI string is unchanged.
	plmxml_api::Result SetAddressURI( const plmxml_api::Handle& );
	
	//! Resolve Address URI and return an object (handle) it points to.
	plmxml_api::Result ResolveAddressURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Address URI. Clears URI string and handle.
	plmxml_api::Result DeleteAddressURI();
	
	//! Check if Address URI is set
	plmxml_api::logical HasAddressURI( ) const;
	

	//! Get Type of this Organisation
	plmxml_api::String GetType() const;

	//! Set Type of this Organisation
	plmxml_api::Result SetType( const plmxml_api::String &s );
	
	//! Check if Type is set
	plmxml_api::logical HasType( ) const;
	
	//! Unset Type
	plmxml_api::Result UnsetType( );

	//! Get CageCode of this Organisation
	plmxml_api::String GetCageCode() const;

	//! Set CageCode of this Organisation
	plmxml_api::Result SetCageCode( const plmxml_api::String &s );
	
	//! Check if CageCode is set
	plmxml_api::logical HasCageCode( ) const;
	
	//! Unset CageCode
	plmxml_api::Result UnsetCageCode( );
 
// <PLMXML_UserCode type="functionHeaderOrganisation" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassOrganisation;


////////////////////////////////////////////////////////////////////////////////////
//! Role class
/*!
\verbatim

      A Role, e.g. "Designer", "Test Engineer", "Chairman", which a Person 
      plays in an organisation.

      Attributes:

      (name:         The name of the role, i.e. "Designer". Inherited from DescriptionBase)
      
\endverbatim
*/
class PLMXML60_API Role : public AttribOwner
{
public:
     
    //! Default constructor
    Role( );
     
    //! Constructs a Role with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Role( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Role();

private:

	//! Assignment operator
	Role& operator=( const Role& iSrc );

	//! Copy constructor
	Role( const Role& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderRole" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassRole;


////////////////////////////////////////////////////////////////////////////////////
//! OrganisationMember class
/*!
\verbatim

      This element is used to associate a Person/User with an Organisation, and to 
      assign an optional Role to that Person/User within that Organisation. A person
      may have more than one Role in an Organisation.
      
      Attributes:

      memberRef:        Reference to a Person or User.
      organisationRef:  The Organisation.
      roleRef:          The Role.
      
\endverbatim
*/
class PLMXML60_API OrganisationMember : public Owner
{
public:
     
    //! Default constructor
    OrganisationMember( );
     
    //! Constructs a OrganisationMember with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    OrganisationMember( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~OrganisationMember();

private:

	//! Assignment operator
	OrganisationMember& operator=( const OrganisationMember& iSrc );

	//! Copy constructor
	OrganisationMember( const OrganisationMember& original );
     
public:

	//! Get Member URI as plmxml_api::String
	plmxml_api::String GetMemberURI() const;

	//! Set Member URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetMemberURI( const plmxml_api::String& );
	
	//! Get the handle of Member URI. Does not resolve the URI.
	plmxml_api::Result GetMemberURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Member URI. URI string is unchanged.
	plmxml_api::Result SetMemberURI( const plmxml_api::Handle& );
	
	//! Resolve Member URI and return an object (handle) it points to.
	plmxml_api::Result ResolveMemberURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Member URI. Clears URI string and handle.
	plmxml_api::Result DeleteMemberURI();
	
	//! Check if Member URI is set
	plmxml_api::logical HasMemberURI( ) const;
	

	//! Get Organisation URI as plmxml_api::String
	plmxml_api::String GetOrganisationURI() const;

	//! Set Organisation URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetOrganisationURI( const plmxml_api::String& );
	
	//! Get the handle of Organisation URI. Does not resolve the URI.
	plmxml_api::Result GetOrganisationURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Organisation URI. URI string is unchanged.
	plmxml_api::Result SetOrganisationURI( const plmxml_api::Handle& );
	
	//! Resolve Organisation URI and return an object (handle) it points to.
	plmxml_api::Result ResolveOrganisationURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Organisation URI. Clears URI string and handle.
	plmxml_api::Result DeleteOrganisationURI();
	
	//! Check if Organisation URI is set
	plmxml_api::logical HasOrganisationURI( ) const;
	

	//! Get Role URI as plmxml_api::String
	plmxml_api::String GetRoleURI() const;

	//! Set Role URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetRoleURI( const plmxml_api::String& );
	
	//! Get the handle of Role URI. Does not resolve the URI.
	plmxml_api::Result GetRoleURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Role URI. URI string is unchanged.
	plmxml_api::Result SetRoleURI( const plmxml_api::Handle& );
	
	//! Resolve Role URI and return an object (handle) it points to.
	plmxml_api::Result ResolveRoleURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Role URI. Clears URI string and handle.
	plmxml_api::Result DeleteRoleURI();
	
	//! Check if Role URI is set
	plmxml_api::logical HasRoleURI( ) const;
	
 
// <PLMXML_UserCode type="functionHeaderOrganisationMember" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassOrganisationMember;


////////////////////////////////////////////////////////////////////////////////////
//! ResourcePool class
/*!
\verbatim

      This is a class of people/users within an organisation, e.g. all people in
      Company A with role 'programmer'. As such it references an organisation and
      a role. It can be used as a resource without specifying a particular person.

      Attributes:

      organisationRef:  The Organisation.
      roleRef:          The Role.
      allMembers:       Whether all the members of the ResourcePool are
                        applicable to the referencing element. The default value
                        is false meaning only one of the members is applicable.
      
\endverbatim
*/
class PLMXML60_API ResourcePool : public AttribOwner
{
public:
     
    //! Default constructor
    ResourcePool( );
     
    //! Constructs a ResourcePool with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ResourcePool( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ResourcePool();

private:

	//! Assignment operator
	ResourcePool& operator=( const ResourcePool& iSrc );

	//! Copy constructor
	ResourcePool( const ResourcePool& original );
     
public:

	//! Set AllMembers
	plmxml_api::Result SetAllMembers( plmxml_api::logical arg );

	//! Get AllMembers
	plmxml_api::logical GetAllMembers() const;

	//! Check if AllMembers is set
	plmxml_api::logical HasAllMembers() const;

	//! Unset AllMembers
	plmxml_api::Result UnsetAllMembers();

	//! Get Organisation URI as plmxml_api::String
	plmxml_api::String GetOrganisationURI() const;

	//! Set Organisation URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetOrganisationURI( const plmxml_api::String& );
	
	//! Get the handle of Organisation URI. Does not resolve the URI.
	plmxml_api::Result GetOrganisationURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Organisation URI. URI string is unchanged.
	plmxml_api::Result SetOrganisationURI( const plmxml_api::Handle& );
	
	//! Resolve Organisation URI and return an object (handle) it points to.
	plmxml_api::Result ResolveOrganisationURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Organisation URI. Clears URI string and handle.
	plmxml_api::Result DeleteOrganisationURI();
	
	//! Check if Organisation URI is set
	plmxml_api::logical HasOrganisationURI( ) const;
	

	//! Get Role URI as plmxml_api::String
	plmxml_api::String GetRoleURI() const;

	//! Set Role URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetRoleURI( const plmxml_api::String& );
	
	//! Get the handle of Role URI. Does not resolve the URI.
	plmxml_api::Result GetRoleURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Role URI. URI string is unchanged.
	plmxml_api::Result SetRoleURI( const plmxml_api::Handle& );
	
	//! Resolve Role URI and return an object (handle) it points to.
	plmxml_api::Result ResolveRoleURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Role URI. Clears URI string and handle.
	plmxml_api::Result DeleteRoleURI();
	
	//! Check if Role URI is set
	plmxml_api::logical HasRoleURI( ) const;
	
 
// <PLMXML_UserCode type="functionHeaderResourcePool" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassResourcePool;


////////////////////////////////////////////////////////////////////////////////////
//! Address class
/*!
\verbatim

      An address for a Person or Organisation.

      Attributes:

      internalLocation:   Room, mailbox, etc.
      streetNumber:
      street:             Name of street, road, lane, etc.
      town:               Village, Town, City, etc.
      region:             Region, County, State, etc.
      country:            Country.
      postalCode:         PostCode, ZIP, etc.
      emailAddress:
      telephone:
      web:                Web site address.
     
\endverbatim
*/
class PLMXML60_API Address : public AttribOwner
{
public:
     
    //! Default constructor
    Address( );
     
    //! Constructs a Address with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Address( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Address();

private:

	//! Assignment operator
	Address& operator=( const Address& iSrc );

	//! Copy constructor
	Address( const Address& original );
     
public:

	//! Get EmailAddress of this Address
	plmxml_api::String GetEmailAddress() const;

	//! Set EmailAddress of this Address
	plmxml_api::Result SetEmailAddress( const plmxml_api::String &s );
	
	//! Check if EmailAddress is set
	plmxml_api::logical HasEmailAddress( ) const;
	
	//! Unset EmailAddress
	plmxml_api::Result UnsetEmailAddress( );

	//! Get PostalCode of this Address
	plmxml_api::String GetPostalCode() const;

	//! Set PostalCode of this Address
	plmxml_api::Result SetPostalCode( const plmxml_api::String &s );
	
	//! Check if PostalCode is set
	plmxml_api::logical HasPostalCode( ) const;
	
	//! Unset PostalCode
	plmxml_api::Result UnsetPostalCode( );

	//! Get Region of this Address
	plmxml_api::String GetRegion() const;

	//! Set Region of this Address
	plmxml_api::Result SetRegion( const plmxml_api::String &s );
	
	//! Check if Region is set
	plmxml_api::logical HasRegion( ) const;
	
	//! Unset Region
	plmxml_api::Result UnsetRegion( );

	//! Get Web of this Address
	plmxml_api::String GetWeb() const;

	//! Set Web of this Address
	plmxml_api::Result SetWeb( const plmxml_api::String &s );
	
	//! Check if Web is set
	plmxml_api::logical HasWeb( ) const;
	
	//! Unset Web
	plmxml_api::Result UnsetWeb( );

	//! Get InternalLocation of this Address
	plmxml_api::String GetInternalLocation() const;

	//! Set InternalLocation of this Address
	plmxml_api::Result SetInternalLocation( const plmxml_api::String &s );
	
	//! Check if InternalLocation is set
	plmxml_api::logical HasInternalLocation( ) const;
	
	//! Unset InternalLocation
	plmxml_api::Result UnsetInternalLocation( );

	//! Get Street of this Address
	plmxml_api::String GetStreet() const;

	//! Set Street of this Address
	plmxml_api::Result SetStreet( const plmxml_api::String &s );
	
	//! Check if Street is set
	plmxml_api::logical HasStreet( ) const;
	
	//! Unset Street
	plmxml_api::Result UnsetStreet( );

	//! Get StreetNumber of this Address
	plmxml_api::String GetStreetNumber() const;

	//! Set StreetNumber of this Address
	plmxml_api::Result SetStreetNumber( const plmxml_api::String &s );
	
	//! Check if StreetNumber is set
	plmxml_api::logical HasStreetNumber( ) const;
	
	//! Unset StreetNumber
	plmxml_api::Result UnsetStreetNumber( );

	//! Get Telephone of this Address
	plmxml_api::String GetTelephone() const;

	//! Set Telephone of this Address
	plmxml_api::Result SetTelephone( const plmxml_api::String &s );
	
	//! Check if Telephone is set
	plmxml_api::logical HasTelephone( ) const;
	
	//! Unset Telephone
	plmxml_api::Result UnsetTelephone( );

	//! Get Country of this Address
	plmxml_api::String GetCountry() const;

	//! Set Country of this Address
	plmxml_api::Result SetCountry( const plmxml_api::String &s );
	
	//! Check if Country is set
	plmxml_api::logical HasCountry( ) const;
	
	//! Unset Country
	plmxml_api::Result UnsetCountry( );

	//! Get Town of this Address
	plmxml_api::String GetTown() const;

	//! Set Town of this Address
	plmxml_api::Result SetTown( const plmxml_api::String &s );
	
	//! Check if Town is set
	plmxml_api::logical HasTown( ) const;
	
	//! Unset Town
	plmxml_api::Result UnsetTown( );
 
// <PLMXML_UserCode type="functionHeaderAddress" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassAddress;


////////////////////////////////////////////////////////////////////////////////////
//! Site class
/*!
\verbatim

      A Site in the sense of a particular software installation, database,
      or location.
      
      Attributes:
      
      (name:          Name of the Site, inherited from DescriptionBase)
      siteId:         Identifying Id of the Site
      addressRef:     Reference to Address element.
      ownerRef:       Reference to owning Organisation.
      
\endverbatim
*/
class PLMXML60_API Site : public Owner
{
public:
     
    //! Default constructor
    Site( );
     
    //! Constructs a Site with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Site( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Site();

private:

	//! Assignment operator
	Site& operator=( const Site& iSrc );

	//! Copy constructor
	Site( const Site& original );
     
public:

	//! Get Owner URI as plmxml_api::String
	plmxml_api::String GetOwnerURI() const;

	//! Set Owner URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetOwnerURI( const plmxml_api::String& );
	
	//! Get the handle of Owner URI. Does not resolve the URI.
	plmxml_api::Result GetOwnerURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Owner URI. URI string is unchanged.
	plmxml_api::Result SetOwnerURI( const plmxml_api::Handle& );
	
	//! Resolve Owner URI and return an object (handle) it points to.
	plmxml_api::Result ResolveOwnerURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Owner URI. Clears URI string and handle.
	plmxml_api::Result DeleteOwnerURI();
	
	//! Check if Owner URI is set
	plmxml_api::logical HasOwnerURI( ) const;
	

	//! Get SiteId of this Site
	plmxml_api::String GetSiteId() const;

	//! Set SiteId of this Site
	plmxml_api::Result SetSiteId( const plmxml_api::String &s );
	
	//! Check if SiteId is set
	plmxml_api::logical HasSiteId( ) const;
	
	//! Unset SiteId
	plmxml_api::Result UnsetSiteId( );

	//! Get Address URI as plmxml_api::String
	plmxml_api::String GetAddressURI() const;

	//! Set Address URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetAddressURI( const plmxml_api::String& );
	
	//! Get the handle of Address URI. Does not resolve the URI.
	plmxml_api::Result GetAddressURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Address URI. URI string is unchanged.
	plmxml_api::Result SetAddressURI( const plmxml_api::Handle& );
	
	//! Resolve Address URI and return an object (handle) it points to.
	plmxml_api::Result ResolveAddressURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Address URI. Clears URI string and handle.
	plmxml_api::Result DeleteAddressURI();
	
	//! Check if Address URI is set
	plmxml_api::logical HasAddressURI( ) const;
	
 
// <PLMXML_UserCode type="functionHeaderSite" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassSite;


////////////////////////////////////////////////////////////////////////////////////
//! DisciplineLevel class
/*!
\verbatim

      A level of expertise in a Discipline
      
      Attributes:
      
      name:             The name of the Level, e.g. "expert" 
      number:           A number associated with the Level. Higher numbers imply
                        greater expertise.
      nameRef:          References a multiple language version of name. If
                        multiple language support is required, nameRef should be
                        used in addition to name.
      
\endverbatim
*/
class PLMXML60_API DisciplineLevel : public IdObject
{
public:
     
    //! Default constructor
    DisciplineLevel( );
     
    //! Constructs a DisciplineLevel with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    DisciplineLevel( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~DisciplineLevel();

private:

	//! Assignment operator
	DisciplineLevel& operator=( const DisciplineLevel& iSrc );

	//! Copy constructor
	DisciplineLevel( const DisciplineLevel& original );
     
public:

	//! Get Name of this DisciplineLevel
	plmxml_api::String GetName() const;

	//! Set Name of this DisciplineLevel
	plmxml_api::Result SetName( const plmxml_api::String &s );
	
	//! Check if Name is set
	plmxml_api::logical HasName( ) const;
	
	//! Unset Name
	plmxml_api::Result UnsetName( );

	//! Get Name URI as plmxml_api::String
	plmxml_api::String GetNameURI() const;

	//! Set Name URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetNameURI( const plmxml_api::String& );
	
	//! Get the handle of Name URI. Does not resolve the URI.
	plmxml_api::Result GetNameURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Name URI. URI string is unchanged.
	plmxml_api::Result SetNameURI( const plmxml_api::Handle& );
	
	//! Resolve Name URI and return an object (handle) it points to.
	plmxml_api::Result ResolveNameURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Name URI. Clears URI string and handle.
	plmxml_api::Result DeleteNameURI();
	
	//! Check if Name URI is set
	plmxml_api::logical HasNameURI( ) const;
	

	//! Set Number
	plmxml_api::Result SetNumber( double arg );

     //! Get Number
	double GetNumber() const;

	//! Check if Number is set
	plmxml_api::logical HasNumber() const;

	//! Unset Number
	plmxml_api::Result UnsetNumber();
 
// <PLMXML_UserCode type="functionHeaderDisciplineLevel" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassDisciplineLevel;


////////////////////////////////////////////////////////////////////////////////////
//! Discipline class
/*!
\verbatim

      A Discipline which Users may belong to.
      
      Attributes:

      rate:             The default pay rate for this Discipline. The units are
                        unspecified.
                        
      Elements:
      
      Level:            Levels of expertise of the Discipline
      
\endverbatim
*/
class PLMXML60_API Discipline : public AttribOwner
{
public:
     
    //! Default constructor
    Discipline( );
     
    //! Constructs a Discipline with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Discipline( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Discipline();

private:

	//! Assignment operator
	Discipline& operator=( const Discipline& iSrc );

	//! Copy constructor
	Discipline( const Discipline& original );
     
public:

	//! Set Rate
	plmxml_api::Result SetRate( double arg );

     //! Get Rate
	double GetRate() const;

	//! Check if Rate is set
	plmxml_api::logical HasRate() const;

	//! Unset Rate
	plmxml_api::Result UnsetRate();

	//! Add Level child element to this Discipline. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	DisciplineLevel *AddLevel();
     
	//! Add 'arg' as Level child element to this Discipline.
	plmxml_api::Result AddLevel( DisciplineLevel *arg );

	//! Detach and delete all Level child elements.
	void DeleteLevels();
     
	//! Get number of Level child elements.
	int NumberOfLevels() const;
     
	//! Get i'th Level child element.
	DisciplineLevel *GetLevel( int i ) const;
     
	//! Get all Level child element as an array
	void GetLevels( plmxml_api::Array<DisciplineLevel*> &array ) const;
	     
	//! Detach and delete i'th Level child element
	void DeleteLevel( int i );
     
	//! Detach and delete 'arg' if it's one of the Level child elements
	void DeleteLevel( DisciplineLevel *arg );
 
// <PLMXML_UserCode type="functionHeaderDiscipline" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassDiscipline;


////////////////////////////////////////////////////////////////////////////////////
//! AccessIntent class
/*!
\verbatim

      Simple access control element. Specifies a set of owners, and read/write access.
      
      Attributes:
 
      intent:      reference, modifiable or noAccess.
      ownerRefs    Reference to one or more owners. These should be elements 
                   derived from plm:OwnerBase, e.g. Person, Organisation, Site, etc.
      
\endverbatim
*/
class PLMXML60_API AccessIntent : public AccessControl
{
public:
     
    //! Default constructor
    AccessIntent( );
     
    //! Constructs a AccessIntent with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    AccessIntent( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~AccessIntent();

private:

	//! Assignment operator
	AccessIntent& operator=( const AccessIntent& iSrc );

	//! Copy constructor
	AccessIntent( const AccessIntent& original );
     
public:

	//! Get number of URIs in Owner
	int NumberOfOwnerURIs() const;

	//! Get i'th URI in Owner
	plmxml_api::String GetOwnerURI( int i ) const;

	//! Add a URI to Owner array. Call ResolveOwnerURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddOwnerURI( const plmxml_api::String& u );

	//! Set i'th URI in Owner array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetOwnerURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Owner URI. Does not resolve the URI.
	plmxml_api::Result GetOwnerURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Owner array.
	plmxml_api::Result AddOwnerURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Owner array to point to 'handle'.
	plmxml_api::Result SetOwnerURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Owner points to.
	plmxml_api::Result ResolveOwnerURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Owner array.
	plmxml_api::Result DeleteOwnerURI( int i );

	//! Remove all URIs from Owner array.
	plmxml_api::Result DeleteOwnerURIs( );
	
	//! Check if Owner is set
	plmxml_api::logical HasOwnerURIs( ) const;

	//! Set Intent
	plmxml_api::Result SetIntent( const eAccessIntentEnum& arg );

	//! Get Intent
	eAccessIntentEnum GetIntent() const;
 
// <PLMXML_UserCode type="functionHeaderAccessIntent" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassAccessIntent;


////////////////////////////////////////////////////////////////////////////////////
//! StatusInfo class
/*!
\verbatim

      Simple status information.
      
      Attributes:
      
      dateCreated:       Date and time created.  
      dateModified:      Date and time last modified.
      lastModifiedBy:    Person or User who last modified this element.
      
\endverbatim
*/
class PLMXML60_API StatusInfo : public Status
{
public:
     
    //! Default constructor
    StatusInfo( );
     
    //! Constructs a StatusInfo with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    StatusInfo( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~StatusInfo();

private:

	//! Assignment operator
	StatusInfo& operator=( const StatusInfo& iSrc );

	//! Copy constructor
	StatusInfo( const StatusInfo& original );
     
public:

	//! Get LastModifiedBy URI as plmxml_api::String
	plmxml_api::String GetLastModifiedByURI() const;

	//! Set LastModifiedBy URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetLastModifiedByURI( const plmxml_api::String& );
	
	//! Get the handle of LastModifiedBy URI. Does not resolve the URI.
	plmxml_api::Result GetLastModifiedByURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of LastModifiedBy URI. URI string is unchanged.
	plmxml_api::Result SetLastModifiedByURI( const plmxml_api::Handle& );
	
	//! Resolve LastModifiedBy URI and return an object (handle) it points to.
	plmxml_api::Result ResolveLastModifiedByURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset LastModifiedBy URI. Clears URI string and handle.
	plmxml_api::Result DeleteLastModifiedByURI();
	
	//! Check if LastModifiedBy URI is set
	plmxml_api::logical HasLastModifiedByURI( ) const;
	

	//! Get DateCreated of this StatusInfo
	plmxml_api::String GetDateCreated() const;

	//! Set DateCreated of this StatusInfo
	plmxml_api::Result SetDateCreated( const plmxml_api::String &s );
	
	//! Check if DateCreated is set
	plmxml_api::logical HasDateCreated( ) const;
	
	//! Unset DateCreated
	plmxml_api::Result UnsetDateCreated( );

	//! Get DateModified of this StatusInfo
	plmxml_api::String GetDateModified() const;

	//! Set DateModified of this StatusInfo
	plmxml_api::Result SetDateModified( const plmxml_api::String &s );
	
	//! Check if DateModified is set
	plmxml_api::logical HasDateModified( ) const;
	
	//! Unset DateModified
	plmxml_api::Result UnsetDateModified( );
 
// <PLMXML_UserCode type="functionHeaderStatusInfo" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassStatusInfo;


////////////////////////////////////////////////////////////////////////////////////
//! Checkout class
/*!
\verbatim

      Checkout information.
      
      Attributes:
      
      by:           Person etc. holding the checkout. Derived from OwnerBase.
      date:         Date and time checked out.
      
\endverbatim
*/
class PLMXML60_API Checkout : public CheckoutStatus
{
public:
     
    //! Default constructor
    Checkout( );
     
    //! Constructs a Checkout with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Checkout( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Checkout();

private:

	//! Assignment operator
	Checkout& operator=( const Checkout& iSrc );

	//! Copy constructor
	Checkout( const Checkout& original );
     
public:

	//! Get By URI as plmxml_api::String
	plmxml_api::String GetByURI() const;

	//! Set By URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetByURI( const plmxml_api::String& );
	
	//! Get the handle of By URI. Does not resolve the URI.
	plmxml_api::Result GetByURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of By URI. URI string is unchanged.
	plmxml_api::Result SetByURI( const plmxml_api::Handle& );
	
	//! Resolve By URI and return an object (handle) it points to.
	plmxml_api::Result ResolveByURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset By URI. Clears URI string and handle.
	plmxml_api::Result DeleteByURI();
	
	//! Check if By URI is set
	plmxml_api::logical HasByURI( ) const;
	

	//! Get Date of this Checkout
	plmxml_api::String GetDate() const;

	//! Set Date of this Checkout
	plmxml_api::Result SetDate( const plmxml_api::String &s );
	
	//! Check if Date is set
	plmxml_api::logical HasDate( ) const;
	
	//! Unset Date
	plmxml_api::Result UnsetDate( );
 
// <PLMXML_UserCode type="functionHeaderCheckout" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassCheckout;


////////////////////////////////////////////////////////////////////////////////////
//! AssociatedDataSet class
/*!
\verbatim

      Attribute used to associate a DataSet with a PLM XML element.

      Attributes:

      dataSetRef:       uri reference to DataSet
      role:             role/purpose of DataSet. No specified values.
      roleRef:          References a multiple language version of role. If
                        multiple language support is required, roleRef should be
                        used in addition to role.

      Sub-elements:

      UserData:         Represents user-definable properties on the
                        relationship.
      
\endverbatim
*/
class PLMXML60_API AssociatedDataSet : public Attribute
{
public:
     
    //! Default constructor
    AssociatedDataSet( );
     
    //! Constructs a AssociatedDataSet with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    AssociatedDataSet( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~AssociatedDataSet();

private:

	//! Assignment operator
	AssociatedDataSet& operator=( const AssociatedDataSet& iSrc );

	//! Copy constructor
	AssociatedDataSet( const AssociatedDataSet& original );
     
public:

	//! Get DataSet URI as plmxml_api::String
	plmxml_api::String GetDataSetURI() const;

	//! Set DataSet URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetDataSetURI( const plmxml_api::String& );
	
	//! Get the handle of DataSet URI. Does not resolve the URI.
	plmxml_api::Result GetDataSetURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of DataSet URI. URI string is unchanged.
	plmxml_api::Result SetDataSetURI( const plmxml_api::Handle& );
	
	//! Resolve DataSet URI and return an object (handle) it points to.
	plmxml_api::Result ResolveDataSetURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset DataSet URI. Clears URI string and handle.
	plmxml_api::Result DeleteDataSetURI();
	
	//! Check if DataSet URI is set
	plmxml_api::logical HasDataSetURI( ) const;
	

	//! Get Role of this AssociatedDataSet
	plmxml_api::String GetRole() const;

	//! Set Role of this AssociatedDataSet
	plmxml_api::Result SetRole( const plmxml_api::String &s );
	
	//! Check if Role is set
	plmxml_api::logical HasRole( ) const;
	
	//! Unset Role
	plmxml_api::Result UnsetRole( );

	//! Get Role URI as plmxml_api::String
	plmxml_api::String GetRoleURI() const;

	//! Set Role URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetRoleURI( const plmxml_api::String& );
	
	//! Get the handle of Role URI. Does not resolve the URI.
	plmxml_api::Result GetRoleURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Role URI. URI string is unchanged.
	plmxml_api::Result SetRoleURI( const plmxml_api::Handle& );
	
	//! Resolve Role URI and return an object (handle) it points to.
	plmxml_api::Result ResolveRoleURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Role URI. Clears URI string and handle.
	plmxml_api::Result DeleteRoleURI();
	
	//! Check if Role URI is set
	plmxml_api::logical HasRoleURI( ) const;
	

	//! Add UserData child element to this AssociatedDataSet. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	UserData *AddUserData();
     
	//! Add 'arg' as UserData child element to this AssociatedDataSet.
	plmxml_api::Result AddUserData( UserData *arg );

	//! Detach and delete all UserData child elements.
	void DeleteUserDatas();
     
	//! Get number of UserData child elements.
	int NumberOfUserDatas() const;
     
	//! Get i'th UserData child element.
	UserData *GetUserData( int i ) const;
     
	//! Get all UserData child element as an array
	void GetUserDatas( plmxml_api::Array<UserData*> &array ) const;
	     
	//! Detach and delete i'th UserData child element
	void DeleteUserData( int i );
     
	//! Detach and delete 'arg' if it's one of the UserData child elements
	void DeleteUserData( UserData *arg );
 
// <PLMXML_UserCode type="functionHeaderAssociatedDataSet" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassAssociatedDataSet;


////////////////////////////////////////////////////////////////////////////////////
//! ExternalFile class
/*!
\verbatim

      Represents an external file.

      Attributes:
      
      locationRef: uri of the file
      format:      format of the file. This should determine which applications
                   can read the file. There is no fixed set of values for this, but
                   will often correspond to the file extension, e.g. "doc", "txt".
                   If the format is the same as a Representation format, e.g. "JT",
                   then the same format string should be used.
      
\endverbatim
*/
class PLMXML60_API ExternalFile : public Managed
{
public:
     
    //! Default constructor
    ExternalFile( );
     
    //! Constructs a ExternalFile with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ExternalFile( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ExternalFile();

private:

	//! Assignment operator
	ExternalFile& operator=( const ExternalFile& iSrc );

	//! Copy constructor
	ExternalFile( const ExternalFile& original );
     
public:

	//! Get Location URI as plmxml_api::String
	plmxml_api::String GetLocationURI() const;

	//! Set Location URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetLocationURI( const plmxml_api::String& );
	
	//! Get the handle of Location URI. Does not resolve the URI.
	plmxml_api::Result GetLocationURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Location URI. URI string is unchanged.
	plmxml_api::Result SetLocationURI( const plmxml_api::Handle& );
	
	//! Resolve Location URI and return an object (handle) it points to.
	plmxml_api::Result ResolveLocationURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Location URI. Clears URI string and handle.
	plmxml_api::Result DeleteLocationURI();
	
	//! Check if Location URI is set
	plmxml_api::logical HasLocationURI( ) const;
	

	//! Get Format of this ExternalFile
	plmxml_api::String GetFormat() const;

	//! Set Format of this ExternalFile
	plmxml_api::Result SetFormat( const plmxml_api::String &s );
	
	//! Check if Format is set
	plmxml_api::logical HasFormat( ) const;
	
	//! Unset Format
	plmxml_api::Result UnsetFormat( );
 
// <PLMXML_UserCode type="functionHeaderExternalFile" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassExternalFile;


////////////////////////////////////////////////////////////////////////////////////
//! DataSet class
/*!
\verbatim

      Represents a DataSet (collection of files).

      Attributes:

      (name:            name of the DataSet; inherited from AttribOwnerBase)
      version:          version number.
      type:             type of DataSet. No specified values.
      memberRefs:       uri references to the members of the DataSet. These
                        should be plm:ExternalFile elements.
      typeRef:          References a multiple language version of type. If
                        multiple language support is required, typeRef should be
                        used in addition to type.
      
\endverbatim
*/
class PLMXML60_API DataSet : public Managed
{
public:
     
    //! Default constructor
    DataSet( );
     
    //! Constructs a DataSet with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    DataSet( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~DataSet();

private:

	//! Assignment operator
	DataSet& operator=( const DataSet& iSrc );

	//! Copy constructor
	DataSet( const DataSet& original );
     
public:

	//! Get number of URIs in Member
	int NumberOfMemberURIs() const;

	//! Get i'th URI in Member
	plmxml_api::String GetMemberURI( int i ) const;

	//! Add a URI to Member array. Call ResolveMemberURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddMemberURI( const plmxml_api::String& u );

	//! Set i'th URI in Member array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetMemberURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Member URI. Does not resolve the URI.
	plmxml_api::Result GetMemberURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Member array.
	plmxml_api::Result AddMemberURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Member array to point to 'handle'.
	plmxml_api::Result SetMemberURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Member points to.
	plmxml_api::Result ResolveMemberURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Member array.
	plmxml_api::Result DeleteMemberURI( int i );

	//! Remove all URIs from Member array.
	plmxml_api::Result DeleteMemberURIs( );
	
	//! Check if Member is set
	plmxml_api::logical HasMemberURIs( ) const;

	//! Get Type of this DataSet
	plmxml_api::String GetType() const;

	//! Set Type of this DataSet
	plmxml_api::Result SetType( const plmxml_api::String &s );
	
	//! Check if Type is set
	plmxml_api::logical HasType( ) const;
	
	//! Unset Type
	plmxml_api::Result UnsetType( );

	//! Get Type URI as plmxml_api::String
	plmxml_api::String GetTypeURI() const;

	//! Set Type URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetTypeURI( const plmxml_api::String& );
	
	//! Get the handle of Type URI. Does not resolve the URI.
	plmxml_api::Result GetTypeURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Type URI. URI string is unchanged.
	plmxml_api::Result SetTypeURI( const plmxml_api::Handle& );
	
	//! Resolve Type URI and return an object (handle) it points to.
	plmxml_api::Result ResolveTypeURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Type URI. Clears URI string and handle.
	plmxml_api::Result DeleteTypeURI();
	
	//! Check if Type URI is set
	plmxml_api::logical HasTypeURI( ) const;
	

	//! Set Version
	plmxml_api::Result SetVersion( int arg );
     
	//! Get Version
	int GetVersion() const;
     
	//! Check if Version is set
	plmxml_api::logical HasVersion() const;
     
	//! Unset Version
	plmxml_api::Result UnsetVersion();
 
// <PLMXML_UserCode type="functionHeaderDataSet" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassDataSet;


////////////////////////////////////////////////////////////////////////////////////
//! ReleaseStatus class
/*!
\verbatim

      ReleaseStatus. Specifies date of release, and effectivities.

      Attributes:
      
      dateReleased:    Date and time released.
      effectivityRefs: Reference to Effectivity elements.
      
\endverbatim
*/
class PLMXML60_API ReleaseStatus : public AttribOwner
{
public:
     
    //! Default constructor
    ReleaseStatus( );
     
    //! Constructs a ReleaseStatus with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ReleaseStatus( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ReleaseStatus();

private:

	//! Assignment operator
	ReleaseStatus& operator=( const ReleaseStatus& iSrc );

	//! Copy constructor
	ReleaseStatus( const ReleaseStatus& original );
     
public:

	//! Get DateReleased of this ReleaseStatus
	plmxml_api::String GetDateReleased() const;

	//! Set DateReleased of this ReleaseStatus
	plmxml_api::Result SetDateReleased( const plmxml_api::String &s );
	
	//! Check if DateReleased is set
	plmxml_api::logical HasDateReleased( ) const;
	
	//! Unset DateReleased
	plmxml_api::Result UnsetDateReleased( );

	//! Get number of URIs in Effectivity
	int NumberOfEffectivityURIs() const;

	//! Get i'th URI in Effectivity
	plmxml_api::String GetEffectivityURI( int i ) const;

	//! Add a URI to Effectivity array. Call ResolveEffectivityURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddEffectivityURI( const plmxml_api::String& u );

	//! Set i'th URI in Effectivity array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetEffectivityURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Effectivity URI. Does not resolve the URI.
	plmxml_api::Result GetEffectivityURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Effectivity array.
	plmxml_api::Result AddEffectivityURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Effectivity array to point to 'handle'.
	plmxml_api::Result SetEffectivityURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Effectivity points to.
	plmxml_api::Result ResolveEffectivityURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Effectivity array.
	plmxml_api::Result DeleteEffectivityURI( int i );

	//! Remove all URIs from Effectivity array.
	plmxml_api::Result DeleteEffectivityURIs( );
	
	//! Check if Effectivity is set
	plmxml_api::logical HasEffectivityURIs( ) const;
 
// <PLMXML_UserCode type="functionHeaderReleaseStatus" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassReleaseStatus;


////////////////////////////////////////////////////////////////////////////////////
//! Drawing class
/*!
\verbatim

      This is the revision-independent Drawing element. A Drawing is a 2D
      representation of one or more ProductRevisions/ProductRevisionViews.
      
      Use the 'catalogueId' attribute on the Structure class as a persistent Id
      for the Drawing.
      
      Attributes:
      
      title:            Title of the Drawing.
      titleRef:         References a multiple language version of title. If
                        multiple language support is required, titleRef should
                        be used in addition to title.
      
\endverbatim
*/
class PLMXML60_API Drawing : public Structure
{
public:
     
    //! Default constructor
    Drawing( );
     
    //! Constructs a Drawing with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Drawing( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Drawing();

private:

	//! Assignment operator
	Drawing& operator=( const Drawing& iSrc );

	//! Copy constructor
	Drawing( const Drawing& original );
     
public:

	//! Get Title of this Drawing
	plmxml_api::String GetTitle() const;

	//! Set Title of this Drawing
	plmxml_api::Result SetTitle( const plmxml_api::String &s );
	
	//! Check if Title is set
	plmxml_api::logical HasTitle( ) const;
	
	//! Unset Title
	plmxml_api::Result UnsetTitle( );

	//! Get Title URI as plmxml_api::String
	plmxml_api::String GetTitleURI() const;

	//! Set Title URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetTitleURI( const plmxml_api::String& );
	
	//! Get the handle of Title URI. Does not resolve the URI.
	plmxml_api::Result GetTitleURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Title URI. URI string is unchanged.
	plmxml_api::Result SetTitleURI( const plmxml_api::Handle& );
	
	//! Resolve Title URI and return an object (handle) it points to.
	plmxml_api::Result ResolveTitleURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Title URI. Clears URI string and handle.
	plmxml_api::Result DeleteTitleURI();
	
	//! Check if Title URI is set
	plmxml_api::logical HasTitleURI( ) const;
	
 
// <PLMXML_UserCode type="functionHeaderDrawing" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassDrawing;


////////////////////////////////////////////////////////////////////////////////////
//! DrawingRevision class
/*!
\verbatim

      This is a revision of a Drawing.
      
      Attributes:
      
      externalFileRefs:  URI references to the Drawing files. These should be
                         ExternalFile elements.
      drawnRefs:         URI references to ProductRevisions or ProductRevisionViews
                         drawn in this Drawing revision.
      
\endverbatim
*/
class PLMXML60_API DrawingRevision : public StructureRevision
{
public:
     
    //! Default constructor
    DrawingRevision( );
     
    //! Constructs a DrawingRevision with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    DrawingRevision( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~DrawingRevision();

private:

	//! Assignment operator
	DrawingRevision& operator=( const DrawingRevision& iSrc );

	//! Copy constructor
	DrawingRevision( const DrawingRevision& original );
     
public:

	//! Get number of URIs in ExternalFile
	int NumberOfExternalFileURIs() const;

	//! Get i'th URI in ExternalFile
	plmxml_api::String GetExternalFileURI( int i ) const;

	//! Add a URI to ExternalFile array. Call ResolveExternalFileURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddExternalFileURI( const plmxml_api::String& u );

	//! Set i'th URI in ExternalFile array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetExternalFileURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of ExternalFile URI. Does not resolve the URI.
	plmxml_api::Result GetExternalFileURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to ExternalFile array.
	plmxml_api::Result AddExternalFileURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in ExternalFile array to point to 'handle'.
	plmxml_api::Result SetExternalFileURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in ExternalFile points to.
	plmxml_api::Result ResolveExternalFileURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from ExternalFile array.
	plmxml_api::Result DeleteExternalFileURI( int i );

	//! Remove all URIs from ExternalFile array.
	plmxml_api::Result DeleteExternalFileURIs( );
	
	//! Check if ExternalFile is set
	plmxml_api::logical HasExternalFileURIs( ) const;

	//! Get number of URIs in Drawn
	int NumberOfDrawnURIs() const;

	//! Get i'th URI in Drawn
	plmxml_api::String GetDrawnURI( int i ) const;

	//! Add a URI to Drawn array. Call ResolveDrawnURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddDrawnURI( const plmxml_api::String& u );

	//! Set i'th URI in Drawn array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetDrawnURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Drawn URI. Does not resolve the URI.
	plmxml_api::Result GetDrawnURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Drawn array.
	plmxml_api::Result AddDrawnURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Drawn array to point to 'handle'.
	plmxml_api::Result SetDrawnURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Drawn points to.
	plmxml_api::Result ResolveDrawnURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Drawn array.
	plmxml_api::Result DeleteDrawnURI( int i );

	//! Remove all URIs from Drawn array.
	plmxml_api::Result DeleteDrawnURIs( );
	
	//! Check if Drawn is set
	plmxml_api::logical HasDrawnURIs( ) const;
 
// <PLMXML_UserCode type="functionHeaderDrawingRevision" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassDrawingRevision;


////////////////////////////////////////////////////////////////////////////////////
//! DrawingRevisionView class
/*!
\verbatim

      This is a View (design, manufacturing, etc) of a Revision of a Drawing.
      
\endverbatim
*/
class PLMXML60_API DrawingRevisionView : public StructureRevisionView
{
public:
     
    //! Default constructor
    DrawingRevisionView( );
     
    //! Constructs a DrawingRevisionView with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    DrawingRevisionView( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~DrawingRevisionView();

private:

	//! Assignment operator
	DrawingRevisionView& operator=( const DrawingRevisionView& iSrc );

	//! Copy constructor
	DrawingRevisionView( const DrawingRevisionView& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderDrawingRevisionView" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassDrawingRevisionView;


////////////////////////////////////////////////////////////////////////////////////
//! ProductFamily class
/*!
\verbatim

      This element connects a ProductRevision or ProductRevisionView to a 'template'
      ProductRevision/ProductRevisionView which represents a Product Family of which 
      it is a member. For example a template ProductRevision might represent the 'Bolt'
      family and a member ProductRevision might be a 2cm Bolt.
      
      The member may be specified by a collection of parameter values in the 'Parameters' 
      UserData sub-element. The exact way in which these parameters are interpreted will
      depend on the CAD system which defined the Template.
      
      Attributes:
      
      memberRef:         URI reference to member ProductRevision/ProductRevisionView
      templateRef:       URI reference to template ProductRevision/ProductRevisionView
      
      Elements:
      
      Parameters         UserData element containing defining parameters for the member
      
\endverbatim
*/
class PLMXML60_API ProductFamily : public Managed
{
public:
     
    //! Default constructor
    ProductFamily( );
     
    //! Constructs a ProductFamily with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ProductFamily( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ProductFamily();

private:

	//! Assignment operator
	ProductFamily& operator=( const ProductFamily& iSrc );

	//! Copy constructor
	ProductFamily( const ProductFamily& original );
     
public:

	//! Get Template URI as plmxml_api::String
	plmxml_api::String GetTemplateURI() const;

	//! Set Template URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetTemplateURI( const plmxml_api::String& );
	
	//! Get the handle of Template URI. Does not resolve the URI.
	plmxml_api::Result GetTemplateURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Template URI. URI string is unchanged.
	plmxml_api::Result SetTemplateURI( const plmxml_api::Handle& );
	
	//! Resolve Template URI and return an object (handle) it points to.
	plmxml_api::Result ResolveTemplateURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Template URI. Clears URI string and handle.
	plmxml_api::Result DeleteTemplateURI();
	
	//! Check if Template URI is set
	plmxml_api::logical HasTemplateURI( ) const;
	

	//! Get Member URI as plmxml_api::String
	plmxml_api::String GetMemberURI() const;

	//! Set Member URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetMemberURI( const plmxml_api::String& );
	
	//! Get the handle of Member URI. Does not resolve the URI.
	plmxml_api::Result GetMemberURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Member URI. URI string is unchanged.
	plmxml_api::Result SetMemberURI( const plmxml_api::Handle& );
	
	//! Resolve Member URI and return an object (handle) it points to.
	plmxml_api::Result ResolveMemberURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Member URI. Clears URI string and handle.
	plmxml_api::Result DeleteMemberURI();
	
	//! Check if Member URI is set
	plmxml_api::logical HasMemberURI( ) const;
	

	//! Add Parameters child element to this ProductFamily. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	UserData *AddParameters();
     
	//! Set Parameters child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetParameters( UserData *arg );
     
	//! Get Parameters child element of this ProductFamily.
	UserData *GetParameters() const;
     
	//! Detach and delete Parameters child element tree from this ProductFamily.
	void DeleteParameters();
 
// <PLMXML_UserCode type="functionHeaderProductFamily" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassProductFamily;


////////////////////////////////////////////////////////////////////////////////////
//! ProductDependency class
/*!
\verbatim

      This element represents a dependency between one ProductRevision,
      ProductRevisionView or Occurrence, and another. The slave depends in some
      way on the master.

      The nature of the dependency may be specific to the CAD system which
      defined it, and is specified by the 'type' attribute, and the 'Parameters'
      UserData sub-element.

      Attributes:

      type:             The type of dependency.
      slaveRef:         URI reference to the dependent ProductRevision,
                        ProductRevisionView or Occurrence.
      masterRef:        URI reference to the master ProductRevision,
                        ProductRevisionView or Occurrence.
      typeRef:          References a multiple language version of message. If
                        multiple language support is required, messageRef should
                        be used in addition to message.
      
\endverbatim
*/
class PLMXML60_API ProductDependency : public Connection
{
public:
     
    //! Default constructor
    ProductDependency( );
     
    //! Constructs a ProductDependency with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ProductDependency( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ProductDependency();

private:

	//! Assignment operator
	ProductDependency& operator=( const ProductDependency& iSrc );

	//! Copy constructor
	ProductDependency( const ProductDependency& original );
     
public:

	//! Get Master URI as plmxml_api::String
	plmxml_api::String GetMasterURI() const;

	//! Set Master URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetMasterURI( const plmxml_api::String& );
	
	//! Get the handle of Master URI. Does not resolve the URI.
	plmxml_api::Result GetMasterURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Master URI. URI string is unchanged.
	plmxml_api::Result SetMasterURI( const plmxml_api::Handle& );
	
	//! Resolve Master URI and return an object (handle) it points to.
	plmxml_api::Result ResolveMasterURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Master URI. Clears URI string and handle.
	plmxml_api::Result DeleteMasterURI();
	
	//! Check if Master URI is set
	plmxml_api::logical HasMasterURI( ) const;
	

	//! Get Type of this ProductDependency
	plmxml_api::String GetType() const;

	//! Set Type of this ProductDependency
	plmxml_api::Result SetType( const plmxml_api::String &s );
	
	//! Check if Type is set
	plmxml_api::logical HasType( ) const;
	
	//! Unset Type
	plmxml_api::Result UnsetType( );

	//! Get Slave URI as plmxml_api::String
	plmxml_api::String GetSlaveURI() const;

	//! Set Slave URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetSlaveURI( const plmxml_api::String& );
	
	//! Get the handle of Slave URI. Does not resolve the URI.
	plmxml_api::Result GetSlaveURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Slave URI. URI string is unchanged.
	plmxml_api::Result SetSlaveURI( const plmxml_api::Handle& );
	
	//! Resolve Slave URI and return an object (handle) it points to.
	plmxml_api::Result ResolveSlaveURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Slave URI. Clears URI string and handle.
	plmxml_api::Result DeleteSlaveURI();
	
	//! Check if Slave URI is set
	plmxml_api::logical HasSlaveURI( ) const;
	

	//! Get Type URI as plmxml_api::String
	plmxml_api::String GetTypeURI() const;

	//! Set Type URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetTypeURI( const plmxml_api::String& );
	
	//! Get the handle of Type URI. Does not resolve the URI.
	plmxml_api::Result GetTypeURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Type URI. URI string is unchanged.
	plmxml_api::Result SetTypeURI( const plmxml_api::Handle& );
	
	//! Resolve Type URI and return an object (handle) it points to.
	plmxml_api::Result ResolveTypeURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Type URI. Clears URI string and handle.
	plmxml_api::Result DeleteTypeURI();
	
	//! Check if Type URI is set
	plmxml_api::logical HasTypeURI( ) const;
	

	//! Add Parameters child element to this ProductDependency. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	UserData *AddParameters();
     
	//! Set Parameters child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetParameters( UserData *arg );
     
	//! Get Parameters child element of this ProductDependency.
	UserData *GetParameters() const;
     
	//! Detach and delete Parameters child element tree from this ProductDependency.
	void DeleteParameters();
 
// <PLMXML_UserCode type="functionHeaderProductDependency" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassProductDependency;


////////////////////////////////////////////////////////////////////////////////////
//! ValueWithUnit class
/*!
\verbatim

      This represents a numerical value with a unit, e.g. "3.1 miles".
      
      Attributes:
      
      name:       (inherited from DescriptionBase) name, e.g. "mileage"
      value:      the value
      unitRef:    reference to a Unit element. If this omitted, the value is unitless.
      
\endverbatim
*/
class PLMXML60_API ValueWithUnit : public AttribOwner
{
public:
     
    //! Default constructor
    ValueWithUnit( );
     
    //! Constructs a ValueWithUnit with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ValueWithUnit( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ValueWithUnit();

private:

	//! Assignment operator
	ValueWithUnit& operator=( const ValueWithUnit& iSrc );

	//! Copy constructor
	ValueWithUnit( const ValueWithUnit& original );
     
public:

	//! Set Value
	plmxml_api::Result SetValue( double arg );

     //! Get Value
	double GetValue() const;

	//! Check if Value is set
	plmxml_api::logical HasValue() const;

	//! Unset Value
	plmxml_api::Result UnsetValue();

	//! Get Unit URI as plmxml_api::String
	plmxml_api::String GetUnitURI() const;

	//! Set Unit URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetUnitURI( const plmxml_api::String& );
	
	//! Get the handle of Unit URI. Does not resolve the URI.
	plmxml_api::Result GetUnitURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Unit URI. URI string is unchanged.
	plmxml_api::Result SetUnitURI( const plmxml_api::Handle& );
	
	//! Resolve Unit URI and return an object (handle) it points to.
	plmxml_api::Result ResolveUnitURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Unit URI. Clears URI string and handle.
	plmxml_api::Result DeleteUnitURI();
	
	//! Check if Unit URI is set
	plmxml_api::logical HasUnitURI( ) const;
	
 
// <PLMXML_UserCode type="functionHeaderValueWithUnit" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassValueWithUnit;


////////////////////////////////////////////////////////////////////////////////////
//! RangeWithUnit class
/*!
\verbatim

      This represents a numerical range with a unit, e.g. "3.1-4.2 miles", or
      "at least 100 litres". At least one of the limit attributes must be present.
      
      Attributes:
      
      name:       (inherited from DescriptionBase) name, e.g. "mileage"
      lowerLimit: the lower limit
      upperLimit: the upper limit
      unitRef:    reference to a Unit element. If this omitted, the value is unitless.
      
\endverbatim
*/
class PLMXML60_API RangeWithUnit : public AttribOwner
{
public:
     
    //! Default constructor
    RangeWithUnit( );
     
    //! Constructs a RangeWithUnit with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    RangeWithUnit( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~RangeWithUnit();

private:

	//! Assignment operator
	RangeWithUnit& operator=( const RangeWithUnit& iSrc );

	//! Copy constructor
	RangeWithUnit( const RangeWithUnit& original );
     
public:

	//! Get Unit URI as plmxml_api::String
	plmxml_api::String GetUnitURI() const;

	//! Set Unit URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetUnitURI( const plmxml_api::String& );
	
	//! Get the handle of Unit URI. Does not resolve the URI.
	plmxml_api::Result GetUnitURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Unit URI. URI string is unchanged.
	plmxml_api::Result SetUnitURI( const plmxml_api::Handle& );
	
	//! Resolve Unit URI and return an object (handle) it points to.
	plmxml_api::Result ResolveUnitURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Unit URI. Clears URI string and handle.
	plmxml_api::Result DeleteUnitURI();
	
	//! Check if Unit URI is set
	plmxml_api::logical HasUnitURI( ) const;
	

	//! Set LowerLimit
	plmxml_api::Result SetLowerLimit( double arg );

     //! Get LowerLimit
	double GetLowerLimit() const;

	//! Check if LowerLimit is set
	plmxml_api::logical HasLowerLimit() const;

	//! Unset LowerLimit
	plmxml_api::Result UnsetLowerLimit();

	//! Set UpperLimit
	plmxml_api::Result SetUpperLimit( double arg );

     //! Get UpperLimit
	double GetUpperLimit() const;

	//! Check if UpperLimit is set
	plmxml_api::logical HasUpperLimit() const;

	//! Unset UpperLimit
	plmxml_api::Result UnsetUpperLimit();
 
// <PLMXML_UserCode type="functionHeaderRangeWithUnit" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassRangeWithUnit;


////////////////////////////////////////////////////////////////////////////////////
//! AssociatedAttachment class
/*!
\verbatim

      Represents a configured attachment to an Occurrence. When an unconfigured
      element (such as a ProductInstance) has an attachment, for example by
      means of a GeneralRelation, or AssociatedDataSet, then a corresponding
      configured element (such as an Occurrence) may have that attachment
      configured.

      Attributes:

      role:             the role of the attachment i.e. the relation to its owner.
      contextRef:       The corresponding configured element (e.g.
                        ProductInstance) which owns the attachment.
      attachmentRef:    reference to the attached element.
      childRefs:        sub-Attachments
      roleRef:          References a multiple language version of role. If
                        multiple language support is required, roleRef should be
                        used in addition to role.
      
\endverbatim
*/
class PLMXML60_API AssociatedAttachment : public AttribOwner
{
public:
     
    //! Default constructor
    AssociatedAttachment( );
     
    //! Constructs a AssociatedAttachment with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    AssociatedAttachment( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~AssociatedAttachment();

private:

	//! Assignment operator
	AssociatedAttachment& operator=( const AssociatedAttachment& iSrc );

	//! Copy constructor
	AssociatedAttachment( const AssociatedAttachment& original );
     
public:

	//! Get Attachment URI as plmxml_api::String
	plmxml_api::String GetAttachmentURI() const;

	//! Set Attachment URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetAttachmentURI( const plmxml_api::String& );
	
	//! Get the handle of Attachment URI. Does not resolve the URI.
	plmxml_api::Result GetAttachmentURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Attachment URI. URI string is unchanged.
	plmxml_api::Result SetAttachmentURI( const plmxml_api::Handle& );
	
	//! Resolve Attachment URI and return an object (handle) it points to.
	plmxml_api::Result ResolveAttachmentURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Attachment URI. Clears URI string and handle.
	plmxml_api::Result DeleteAttachmentURI();
	
	//! Check if Attachment URI is set
	plmxml_api::logical HasAttachmentURI( ) const;
	

	//! Get Role of this AssociatedAttachment
	plmxml_api::String GetRole() const;

	//! Set Role of this AssociatedAttachment
	plmxml_api::Result SetRole( const plmxml_api::String &s );
	
	//! Check if Role is set
	plmxml_api::logical HasRole( ) const;
	
	//! Unset Role
	plmxml_api::Result UnsetRole( );

	//! Get Role URI as plmxml_api::String
	plmxml_api::String GetRoleURI() const;

	//! Set Role URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetRoleURI( const plmxml_api::String& );
	
	//! Get the handle of Role URI. Does not resolve the URI.
	plmxml_api::Result GetRoleURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Role URI. URI string is unchanged.
	plmxml_api::Result SetRoleURI( const plmxml_api::Handle& );
	
	//! Resolve Role URI and return an object (handle) it points to.
	plmxml_api::Result ResolveRoleURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Role URI. Clears URI string and handle.
	plmxml_api::Result DeleteRoleURI();
	
	//! Check if Role URI is set
	plmxml_api::logical HasRoleURI( ) const;
	

	//! Get number of URIs in Child
	int NumberOfChildURIs() const;

	//! Get i'th URI in Child
	plmxml_api::String GetChildURI( int i ) const;

	//! Add a URI to Child array. Call ResolveChildURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddChildURI( const plmxml_api::String& u );

	//! Set i'th URI in Child array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetChildURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Child URI. Does not resolve the URI.
	plmxml_api::Result GetChildURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Child array.
	plmxml_api::Result AddChildURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Child array to point to 'handle'.
	plmxml_api::Result SetChildURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Child points to.
	plmxml_api::Result ResolveChildURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Child array.
	plmxml_api::Result DeleteChildURI( int i );

	//! Remove all URIs from Child array.
	plmxml_api::Result DeleteChildURIs( );
	
	//! Check if Child is set
	plmxml_api::logical HasChildURIs( ) const;

	//! Get Context URI as plmxml_api::String
	plmxml_api::String GetContextURI() const;

	//! Set Context URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetContextURI( const plmxml_api::String& );
	
	//! Get the handle of Context URI. Does not resolve the URI.
	plmxml_api::Result GetContextURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Context URI. URI string is unchanged.
	plmxml_api::Result SetContextURI( const plmxml_api::Handle& );
	
	//! Resolve Context URI and return an object (handle) it points to.
	plmxml_api::Result ResolveContextURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Context URI. Clears URI string and handle.
	plmxml_api::Result DeleteContextURI();
	
	//! Check if Context URI is set
	plmxml_api::logical HasContextURI( ) const;
	
 
// <PLMXML_UserCode type="functionHeaderAssociatedAttachment" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassAssociatedAttachment;


////////////////////////////////////////////////////////////////////////////////////
//! OccurrenceGroup class
/*!
\verbatim

      This is a group of InstancePaths and other OccurrenceGroups. All the InstancePaths
      included (recursively) in an OccurrenceGroup must have the same InstancePathRoot.
    
      OccurrenceGroups can share InstancePaths or other OccurrenceGroups, but must not
      contain recursive loops.
    
      Attributes:
    
      instancePathRootRef: reference to the common InstancePathRoot.
                      
      childRefs:           reference to contained InstancePaths or OccurrenceGroups
      
\endverbatim
*/
class PLMXML60_API OccurrenceGroup : public Managed
{
public:
     
    //! Default constructor
    OccurrenceGroup( );
     
    //! Constructs a OccurrenceGroup with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    OccurrenceGroup( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~OccurrenceGroup();

private:

	//! Assignment operator
	OccurrenceGroup& operator=( const OccurrenceGroup& iSrc );

	//! Copy constructor
	OccurrenceGroup( const OccurrenceGroup& original );
     
public:

	//! Get number of URIs in Child
	int NumberOfChildURIs() const;

	//! Get i'th URI in Child
	plmxml_api::String GetChildURI( int i ) const;

	//! Add a URI to Child array. Call ResolveChildURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddChildURI( const plmxml_api::String& u );

	//! Set i'th URI in Child array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetChildURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Child URI. Does not resolve the URI.
	plmxml_api::Result GetChildURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Child array.
	plmxml_api::Result AddChildURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Child array to point to 'handle'.
	plmxml_api::Result SetChildURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Child points to.
	plmxml_api::Result ResolveChildURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Child array.
	plmxml_api::Result DeleteChildURI( int i );

	//! Remove all URIs from Child array.
	plmxml_api::Result DeleteChildURIs( );
	
	//! Check if Child is set
	plmxml_api::logical HasChildURIs( ) const;

	//! Get InstancePathRoot URI as plmxml_api::String
	plmxml_api::String GetInstancePathRootURI() const;

	//! Set InstancePathRoot URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetInstancePathRootURI( const plmxml_api::String& );
	
	//! Get the handle of InstancePathRoot URI. Does not resolve the URI.
	plmxml_api::Result GetInstancePathRootURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of InstancePathRoot URI. URI string is unchanged.
	plmxml_api::Result SetInstancePathRootURI( const plmxml_api::Handle& );
	
	//! Resolve InstancePathRoot URI and return an object (handle) it points to.
	plmxml_api::Result ResolveInstancePathRootURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset InstancePathRoot URI. Clears URI string and handle.
	plmxml_api::Result DeleteInstancePathRootURI();
	
	//! Check if InstancePathRoot URI is set
	plmxml_api::logical HasInstancePathRootURI( ) const;
	
 
// <PLMXML_UserCode type="functionHeaderOccurrenceGroup" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassOccurrenceGroup;


////////////////////////////////////////////////////////////////////////////////////
//! InstanceThread class
/*!
\verbatim

      This element collects together Instances which correspond across different
      revisions of a structure. An Instance can only be in one InstanceThread,
      which it references by its instanceThreadRef attribute.
      
\endverbatim
*/
class PLMXML60_API InstanceThread : public AttribOwner
{
public:
     
    //! Default constructor
    InstanceThread( );
     
    //! Constructs a InstanceThread with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    InstanceThread( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~InstanceThread();

private:

	//! Assignment operator
	InstanceThread& operator=( const InstanceThread& iSrc );

	//! Copy constructor
	InstanceThread( const InstanceThread& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderInstanceThread" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassInstanceThread;


////////////////////////////////////////////////////////////////////////////////////
//! InstancePathRoot class
/*!
\verbatim

      This element represents the root of a tree of InstancePaths.
    
      Attributes:
      
      structureViewRef: This is the StructureView at the top of the InstancePaths in the
                        tree.
      
\endverbatim
*/
class PLMXML60_API InstancePathRoot : public AttribOwner
{
public:
     
    //! Default constructor
    InstancePathRoot( );
     
    //! Constructs a InstancePathRoot with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    InstancePathRoot( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~InstancePathRoot();

private:

	//! Assignment operator
	InstancePathRoot& operator=( const InstancePathRoot& iSrc );

	//! Copy constructor
	InstancePathRoot( const InstancePathRoot& original );
     
public:

	//! Get StructureView URI as plmxml_api::String
	plmxml_api::String GetStructureViewURI() const;

	//! Set StructureView URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetStructureViewURI( const plmxml_api::String& );
	
	//! Get the handle of StructureView URI. Does not resolve the URI.
	plmxml_api::Result GetStructureViewURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of StructureView URI. URI string is unchanged.
	plmxml_api::Result SetStructureViewURI( const plmxml_api::Handle& );
	
	//! Resolve StructureView URI and return an object (handle) it points to.
	plmxml_api::Result ResolveStructureViewURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset StructureView URI. Clears URI string and handle.
	plmxml_api::Result DeleteStructureViewURI();
	
	//! Check if StructureView URI is set
	plmxml_api::logical HasStructureViewURI( ) const;
	
 
// <PLMXML_UserCode type="functionHeaderInstancePathRoot" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassInstancePathRoot;


////////////////////////////////////////////////////////////////////////////////////
//! InstancePath class
/*!
\verbatim

      This element represents an unconfigured path of InstanceThreads, top to bottom.
    
      The path must be sequential in that the 'instanced' Structure of each InstanceThread
      must be the same as the 'parent' Structure of the next InstanceThread in the path.
      It is possible (although unusual) for an InstancePath to 'change views' as you go
      down the path.
    
      Attributes:
      
      instancePathRootRef: The InstancePathRoot which represents the top of the tree
                           this InstancePath is in.

      instanceThreadRef:   This is the last (bottom) InstanceThread in the instance path.
                           (Unlike the Occurrence element, which has an "instanceRefs" 
                           attribute to specify the full path, this element only
                           specifies the last InstanceThread, and relies on its
                           'ancestor' elements to define the path).
      
      childRefs:           the 'children' of the InstancePath. This is a selection of
                           other InstancePaths, each of which must have a path which is 
                           formed by adding one more InstanceThread on the end of the
                           path. There must be no duplicates paths.                        

      absoluteOccurrenceRef: This is a back-pointer to a referencing AbsoluteOccurrence 
                           (There can be at most one AbsoluteOccurrence referencing a
                           given InstancePath)
      
\endverbatim
*/
class PLMXML60_API InstancePath : public Managed
{
public:
     
    //! Default constructor
    InstancePath( );
     
    //! Constructs a InstancePath with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    InstancePath( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~InstancePath();

private:

	//! Assignment operator
	InstancePath& operator=( const InstancePath& iSrc );

	//! Copy constructor
	InstancePath( const InstancePath& original );
     
public:

	//! Get InstancePathRoot URI as plmxml_api::String
	plmxml_api::String GetInstancePathRootURI() const;

	//! Set InstancePathRoot URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetInstancePathRootURI( const plmxml_api::String& );
	
	//! Get the handle of InstancePathRoot URI. Does not resolve the URI.
	plmxml_api::Result GetInstancePathRootURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of InstancePathRoot URI. URI string is unchanged.
	plmxml_api::Result SetInstancePathRootURI( const plmxml_api::Handle& );
	
	//! Resolve InstancePathRoot URI and return an object (handle) it points to.
	plmxml_api::Result ResolveInstancePathRootURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset InstancePathRoot URI. Clears URI string and handle.
	plmxml_api::Result DeleteInstancePathRootURI();
	
	//! Check if InstancePathRoot URI is set
	plmxml_api::logical HasInstancePathRootURI( ) const;
	

	//! Get InstanceThread URI as plmxml_api::String
	plmxml_api::String GetInstanceThreadURI() const;

	//! Set InstanceThread URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetInstanceThreadURI( const plmxml_api::String& );
	
	//! Get the handle of InstanceThread URI. Does not resolve the URI.
	plmxml_api::Result GetInstanceThreadURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of InstanceThread URI. URI string is unchanged.
	plmxml_api::Result SetInstanceThreadURI( const plmxml_api::Handle& );
	
	//! Resolve InstanceThread URI and return an object (handle) it points to.
	plmxml_api::Result ResolveInstanceThreadURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset InstanceThread URI. Clears URI string and handle.
	plmxml_api::Result DeleteInstanceThreadURI();
	
	//! Check if InstanceThread URI is set
	plmxml_api::logical HasInstanceThreadURI( ) const;
	

	//! Get AbsoluteOccurrence URI as plmxml_api::String
	plmxml_api::String GetAbsoluteOccurrenceURI() const;

	//! Set AbsoluteOccurrence URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetAbsoluteOccurrenceURI( const plmxml_api::String& );
	
	//! Get the handle of AbsoluteOccurrence URI. Does not resolve the URI.
	plmxml_api::Result GetAbsoluteOccurrenceURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of AbsoluteOccurrence URI. URI string is unchanged.
	plmxml_api::Result SetAbsoluteOccurrenceURI( const plmxml_api::Handle& );
	
	//! Resolve AbsoluteOccurrence URI and return an object (handle) it points to.
	plmxml_api::Result ResolveAbsoluteOccurrenceURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset AbsoluteOccurrence URI. Clears URI string and handle.
	plmxml_api::Result DeleteAbsoluteOccurrenceURI();
	
	//! Check if AbsoluteOccurrence URI is set
	plmxml_api::logical HasAbsoluteOccurrenceURI( ) const;
	

	//! Get number of URIs in Child
	int NumberOfChildURIs() const;

	//! Get i'th URI in Child
	plmxml_api::String GetChildURI( int i ) const;

	//! Add a URI to Child array. Call ResolveChildURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddChildURI( const plmxml_api::String& u );

	//! Set i'th URI in Child array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetChildURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Child URI. Does not resolve the URI.
	plmxml_api::Result GetChildURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Child array.
	plmxml_api::Result AddChildURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Child array to point to 'handle'.
	plmxml_api::Result SetChildURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Child points to.
	plmxml_api::Result ResolveChildURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Child array.
	plmxml_api::Result DeleteChildURI( int i );

	//! Remove all URIs from Child array.
	plmxml_api::Result DeleteChildURIs( );
	
	//! Check if Child is set
	plmxml_api::logical HasChildURIs( ) const;
 
// <PLMXML_UserCode type="functionHeaderInstancePath" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassInstancePath;


////////////////////////////////////////////////////////////////////////////////////
//! AbsoluteOccurrence class
/*!
\verbatim

      An AbsoluteOccurrence provides a mechanism for collecting together a number of
      InstancePaths, which in some sense 'correspond' (for example the front left wheels
      in two different cars). There are no actual requirements on what these
      InstancePaths are.
     
      Attributes:
    
      occurrenceId:         an id for the Occurrence
      instancePathRefs:     the InstancePaths in the AbsoluteOccurrence
      
\endverbatim
*/
class PLMXML60_API AbsoluteOccurrence : public AttribOwner
{
public:
     
    //! Default constructor
    AbsoluteOccurrence( );
     
    //! Constructs a AbsoluteOccurrence with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    AbsoluteOccurrence( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~AbsoluteOccurrence();

private:

	//! Assignment operator
	AbsoluteOccurrence& operator=( const AbsoluteOccurrence& iSrc );

	//! Copy constructor
	AbsoluteOccurrence( const AbsoluteOccurrence& original );
     
public:

	//! Get number of URIs in InstancePath
	int NumberOfInstancePathURIs() const;

	//! Get i'th URI in InstancePath
	plmxml_api::String GetInstancePathURI( int i ) const;

	//! Add a URI to InstancePath array. Call ResolveInstancePathURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddInstancePathURI( const plmxml_api::String& u );

	//! Set i'th URI in InstancePath array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetInstancePathURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of InstancePath URI. Does not resolve the URI.
	plmxml_api::Result GetInstancePathURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to InstancePath array.
	plmxml_api::Result AddInstancePathURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in InstancePath array to point to 'handle'.
	plmxml_api::Result SetInstancePathURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in InstancePath points to.
	plmxml_api::Result ResolveInstancePathURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from InstancePath array.
	plmxml_api::Result DeleteInstancePathURI( int i );

	//! Remove all URIs from InstancePath array.
	plmxml_api::Result DeleteInstancePathURIs( );
	
	//! Check if InstancePath is set
	plmxml_api::logical HasInstancePathURIs( ) const;

	//! Get OccurrenceId of this AbsoluteOccurrence
	plmxml_api::String GetOccurrenceId() const;

	//! Set OccurrenceId of this AbsoluteOccurrence
	plmxml_api::Result SetOccurrenceId( const plmxml_api::String &s );
	
	//! Check if OccurrenceId is set
	plmxml_api::logical HasOccurrenceId( ) const;
	
	//! Unset OccurrenceId
	plmxml_api::Result UnsetOccurrenceId( );
 
// <PLMXML_UserCode type="functionHeaderAbsoluteOccurrence" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassAbsoluteOccurrence;


//! Forward class declarations
class PropertyGroup;
class DeterminedPropertyGroup;

////////////////////////////////////////////////////////////////////////////////////
//! StructureView class
/*!
\verbatim

      This abstract element represents a View (e.g. 'design') of a Structure.
      It simply references the associated Structure and View elements.

      Attributes:

      masterRef:      reference to the Structure
      viewRef:        reference to the View
      propertyRefs:   reference to Properties

      Elements:

      PropertyGroup
      DeterminedPropertyGroup: The Properties determined by a specific method.
      
\endverbatim
*/
class PLMXML60_API StructureView : public Managed
{
public:
     
    //! Default constructor
    StructureView( );
     
    //! Constructs a StructureView with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    StructureView( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~StructureView();

private:

	//! Assignment operator
	StructureView& operator=( const StructureView& iSrc );

	//! Copy constructor
	StructureView( const StructureView& original );
     
public:

	//! Get number of URIs in Property
	int NumberOfPropertyURIs() const;

	//! Get i'th URI in Property
	plmxml_api::String GetPropertyURI( int i ) const;

	//! Add a URI to Property array. Call ResolvePropertyURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddPropertyURI( const plmxml_api::String& u );

	//! Set i'th URI in Property array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetPropertyURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Property URI. Does not resolve the URI.
	plmxml_api::Result GetPropertyURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Property array.
	plmxml_api::Result AddPropertyURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Property array to point to 'handle'.
	plmxml_api::Result SetPropertyURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Property points to.
	plmxml_api::Result ResolvePropertyURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Property array.
	plmxml_api::Result DeletePropertyURI( int i );

	//! Remove all URIs from Property array.
	plmxml_api::Result DeletePropertyURIs( );
	
	//! Check if Property is set
	plmxml_api::logical HasPropertyURIs( ) const;

	//! Get View URI as plmxml_api::String
	plmxml_api::String GetViewURI() const;

	//! Set View URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetViewURI( const plmxml_api::String& );
	
	//! Get the handle of View URI. Does not resolve the URI.
	plmxml_api::Result GetViewURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of View URI. URI string is unchanged.
	plmxml_api::Result SetViewURI( const plmxml_api::Handle& );
	
	//! Resolve View URI and return an object (handle) it points to.
	plmxml_api::Result ResolveViewURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset View URI. Clears URI string and handle.
	plmxml_api::Result DeleteViewURI();
	
	//! Check if View URI is set
	plmxml_api::logical HasViewURI( ) const;
	

	//! Get Master URI as plmxml_api::String
	plmxml_api::String GetMasterURI() const;

	//! Set Master URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetMasterURI( const plmxml_api::String& );
	
	//! Get the handle of Master URI. Does not resolve the URI.
	plmxml_api::Result GetMasterURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Master URI. URI string is unchanged.
	plmxml_api::Result SetMasterURI( const plmxml_api::Handle& );
	
	//! Resolve Master URI and return an object (handle) it points to.
	plmxml_api::Result ResolveMasterURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Master URI. Clears URI string and handle.
	plmxml_api::Result DeleteMasterURI();
	
	//! Check if Master URI is set
	plmxml_api::logical HasMasterURI( ) const;
	

	//! Add PropertyGroup child element to this StructureView. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	PropertyGroup *AddPropertyGroup();
     
	//! Set PropertyGroup child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetPropertyGroup( PropertyGroup *arg );
     
	//! Get PropertyGroup child element of this StructureView.
	PropertyGroup *GetPropertyGroup() const;
     
	//! Detach and delete PropertyGroup child element tree from this StructureView.
	void DeletePropertyGroup();

	//! Add DeterminedPropertyGroup child element to this StructureView. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	DeterminedPropertyGroup *AddDeterminedPropertyGroup();
     
	//! Set DeterminedPropertyGroup child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetDeterminedPropertyGroup( DeterminedPropertyGroup *arg );
     
	//! Get DeterminedPropertyGroup child element of this StructureView.
	DeterminedPropertyGroup *GetDeterminedPropertyGroup() const;
     
	//! Detach and delete DeterminedPropertyGroup child element tree from this StructureView.
	void DeleteDeterminedPropertyGroup();
 
// <PLMXML_UserCode type="functionHeaderStructureView" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassStructureView;


////////////////////////////////////////////////////////////////////////////////////
//! ProductStructureView class
/*!
\verbatim

      This element represents a View of a Product, e.g. 'design' View.
      
\endverbatim
*/
class PLMXML60_API ProductStructureView : public StructureView
{
public:
     
    //! Default constructor
    ProductStructureView( );
     
    //! Constructs a ProductStructureView with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ProductStructureView( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ProductStructureView();

private:

	//! Assignment operator
	ProductStructureView& operator=( const ProductStructureView& iSrc );

	//! Copy constructor
	ProductStructureView( const ProductStructureView& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderProductStructureView" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassProductStructureView;


////////////////////////////////////////////////////////////////////////////////////
//! GeneralRelation class
/*!
\verbatim

      This is general relation between a number of elements. The type of relation
      is given by the 'subType' attribute inherited from ManagedBase.
      
      There are no specified values of 'subType'. Therefore the semantics of the
      relation are not defined here.
      
\endverbatim
*/
class PLMXML60_API GeneralRelation : public Managed
{
public:
     
    //! Default constructor
    GeneralRelation( );
     
    //! Constructs a GeneralRelation with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    GeneralRelation( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~GeneralRelation();

private:

	//! Assignment operator
	GeneralRelation& operator=( const GeneralRelation& iSrc );

	//! Copy constructor
	GeneralRelation( const GeneralRelation& original );
     
public:

	//! Get number of URIs in Related
	int NumberOfRelatedURIs() const;

	//! Get i'th URI in Related
	plmxml_api::String GetRelatedURI( int i ) const;

	//! Add a URI to Related array. Call ResolveRelatedURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddRelatedURI( const plmxml_api::String& u );

	//! Set i'th URI in Related array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetRelatedURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Related URI. Does not resolve the URI.
	plmxml_api::Result GetRelatedURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Related array.
	plmxml_api::Result AddRelatedURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Related array to point to 'handle'.
	plmxml_api::Result SetRelatedURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Related points to.
	plmxml_api::Result ResolveRelatedURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Related array.
	plmxml_api::Result DeleteRelatedURI( int i );

	//! Remove all URIs from Related array.
	plmxml_api::Result DeleteRelatedURIs( );
	
	//! Check if Related is set
	plmxml_api::logical HasRelatedURIs( ) const;
 
// <PLMXML_UserCode type="functionHeaderGeneralRelation" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassGeneralRelation;


////////////////////////////////////////////////////////////////////////////////////
//! Property class
/*!
\verbatim

      This is an abstract base class for Properties. A Property will override a
      similar Property if it is attached to an earlier element in the following
      list:
      Occurrence, Instance, StructureRevisionView, StructureRevision, Structure.
      So, for example, a Property on an Instance will override a similar
      Property on the corresponding StructureRevision.

      Attributes:

      ownerRef:         The owner of the property. Necessary when the owner is
                        an object in a Representation file, e.g. an XT Face.
      determination:    The method by which the property is determined.
      
\endverbatim
*/
class PLMXML60_API Property : public AttribOwner
{
public:
     
    //! Default constructor
    Property( );
     
    //! Constructs a Property with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Property( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Property();

private:

	//! Assignment operator
	Property& operator=( const Property& iSrc );

	//! Copy constructor
	Property( const Property& original );
     
public:

	//! Get Owner URI as plmxml_api::String
	plmxml_api::String GetOwnerURI() const;

	//! Set Owner URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetOwnerURI( const plmxml_api::String& );
	
	//! Get the handle of Owner URI. Does not resolve the URI.
	plmxml_api::Result GetOwnerURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Owner URI. URI string is unchanged.
	plmxml_api::Result SetOwnerURI( const plmxml_api::Handle& );
	
	//! Resolve Owner URI and return an object (handle) it points to.
	plmxml_api::Result ResolveOwnerURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Owner URI. Clears URI string and handle.
	plmxml_api::Result DeleteOwnerURI();
	
	//! Check if Owner URI is set
	plmxml_api::logical HasOwnerURI( ) const;
	

	//! Set Determination
	plmxml_api::Result SetDetermination( const ePropertyDeterminationEnum& arg );

	//! Get Determination
	ePropertyDeterminationEnum GetDetermination() const;
 
// <PLMXML_UserCode type="functionHeaderProperty" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassProperty;


////////////////////////////////////////////////////////////////////////////////////
//! PropertyGroup class
/*!
\verbatim

      This is a group of Properties.
      
\endverbatim
*/
class PLMXML60_API PropertyGroup : public AttribOwner
{
public:
     
    //! Default constructor
    PropertyGroup( );
     
    //! Constructs a PropertyGroup with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    PropertyGroup( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~PropertyGroup();

private:

	//! Assignment operator
	PropertyGroup& operator=( const PropertyGroup& iSrc );

	//! Copy constructor
	PropertyGroup( const PropertyGroup& original );
     
public:

	//! Add Property child element to this PropertyGroup. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Property *AddProperty();
     
	//! Add 'arg' as Property child element to this PropertyGroup.
	plmxml_api::Result AddProperty( Property *arg );

	//! Detach and delete all Property child elements.
	void DeleteProperties();
     
	//! Get number of Property child elements.
	int NumberOfProperties() const;
     
	//! Get i'th Property child element.
	Property *GetProperty( int i ) const;
     
	//! Get all Property child element as an array
	void GetProperties( plmxml_api::Array<Property*> &array ) const;
	     
	//! Detach and delete i'th Property child element
	void DeleteProperty( int i );
     
	//! Detach and delete 'arg' if it's one of the Property child elements
	void DeleteProperty( Property *arg );
 
// <PLMXML_UserCode type="functionHeaderPropertyGroup" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassPropertyGroup;


////////////////////////////////////////////////////////////////////////////////////
//! LengthProperty class
/*!
\verbatim

      This Property represents the length of an object (such as a pipe or wire).

      Attributes:

      type:             A string specifying the type of value, e.g. whether
                        computed or measured.
      typeRef:          References a multiple language version of type. If
                        multiple language support is required, typeRef should be
                        used in addition to type.
      
\endverbatim
*/
class PLMXML60_API LengthProperty : public Property
{
public:
     
    //! Default constructor
    LengthProperty( );
     
    //! Constructs a LengthProperty with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    LengthProperty( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~LengthProperty();

private:

	//! Assignment operator
	LengthProperty& operator=( const LengthProperty& iSrc );

	//! Copy constructor
	LengthProperty( const LengthProperty& original );
     
public:

	//! Get Type of this LengthProperty
	plmxml_api::String GetType() const;

	//! Set Type of this LengthProperty
	plmxml_api::Result SetType( const plmxml_api::String &s );
	
	//! Check if Type is set
	plmxml_api::logical HasType( ) const;
	
	//! Unset Type
	plmxml_api::Result UnsetType( );

	//! Get Type URI as plmxml_api::String
	plmxml_api::String GetTypeURI() const;

	//! Set Type URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetTypeURI( const plmxml_api::String& );
	
	//! Get the handle of Type URI. Does not resolve the URI.
	plmxml_api::Result GetTypeURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Type URI. URI string is unchanged.
	plmxml_api::Result SetTypeURI( const plmxml_api::Handle& );
	
	//! Resolve Type URI and return an object (handle) it points to.
	plmxml_api::Result ResolveTypeURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Type URI. Clears URI string and handle.
	plmxml_api::Result DeleteTypeURI();
	
	//! Check if Type URI is set
	plmxml_api::logical HasTypeURI( ) const;
	

	//! Add ValueWithUnit child element to this LengthProperty. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	ValueWithUnit *AddValueWithUnit();
     
	//! Set ValueWithUnit child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetValueWithUnit( ValueWithUnit *arg );
     
	//! Get ValueWithUnit child element of this LengthProperty.
	ValueWithUnit *GetValueWithUnit() const;
     
	//! Detach and delete ValueWithUnit child element tree from this LengthProperty.
	void DeleteValueWithUnit();

	//! Add RangeWithUnit child element to this LengthProperty. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	RangeWithUnit *AddRangeWithUnit();
     
	//! Set RangeWithUnit child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetRangeWithUnit( RangeWithUnit *arg );
     
	//! Get RangeWithUnit child element of this LengthProperty.
	RangeWithUnit *GetRangeWithUnit() const;
     
	//! Detach and delete RangeWithUnit child element tree from this LengthProperty.
	void DeleteRangeWithUnit();
 
// <PLMXML_UserCode type="functionHeaderLengthProperty" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassLengthProperty;


////////////////////////////////////////////////////////////////////////////////////
//! MassProperty class
/*!
\verbatim

      This Property represents the Mass of an object.
      
\endverbatim
*/
class PLMXML60_API MassProperty : public Property
{
public:
     
    //! Default constructor
    MassProperty( );
     
    //! Constructs a MassProperty with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    MassProperty( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~MassProperty();

private:

	//! Assignment operator
	MassProperty& operator=( const MassProperty& iSrc );

	//! Copy constructor
	MassProperty( const MassProperty& original );
     
public:

	//! Add ValueWithUnit child element to this MassProperty. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	ValueWithUnit *AddValueWithUnit();
     
	//! Set ValueWithUnit child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetValueWithUnit( ValueWithUnit *arg );
     
	//! Get ValueWithUnit child element of this MassProperty.
	ValueWithUnit *GetValueWithUnit() const;
     
	//! Detach and delete ValueWithUnit child element tree from this MassProperty.
	void DeleteValueWithUnit();

	//! Add RangeWithUnit child element to this MassProperty. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	RangeWithUnit *AddRangeWithUnit();
     
	//! Set RangeWithUnit child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetRangeWithUnit( RangeWithUnit *arg );
     
	//! Get RangeWithUnit child element of this MassProperty.
	RangeWithUnit *GetRangeWithUnit() const;
     
	//! Detach and delete RangeWithUnit child element tree from this MassProperty.
	void DeleteRangeWithUnit();
 
// <PLMXML_UserCode type="functionHeaderMassProperty" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassMassProperty;


////////////////////////////////////////////////////////////////////////////////////
//! Density class
/*!
\verbatim

      This Property represents the Density of an object.
      
\endverbatim
*/
class PLMXML60_API Density : public Property
{
public:
     
    //! Default constructor
    Density( );
     
    //! Constructs a Density with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Density( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Density();

private:

	//! Assignment operator
	Density& operator=( const Density& iSrc );

	//! Copy constructor
	Density( const Density& original );
     
public:

	//! Add ValueWithUnit child element to this Density. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	ValueWithUnit *AddValueWithUnit();
     
	//! Set ValueWithUnit child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetValueWithUnit( ValueWithUnit *arg );
     
	//! Get ValueWithUnit child element of this Density.
	ValueWithUnit *GetValueWithUnit() const;
     
	//! Detach and delete ValueWithUnit child element tree from this Density.
	void DeleteValueWithUnit();

	//! Add RangeWithUnit child element to this Density. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	RangeWithUnit *AddRangeWithUnit();
     
	//! Set RangeWithUnit child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetRangeWithUnit( RangeWithUnit *arg );
     
	//! Get RangeWithUnit child element of this Density.
	RangeWithUnit *GetRangeWithUnit() const;
     
	//! Detach and delete RangeWithUnit child element tree from this Density.
	void DeleteRangeWithUnit();
 
// <PLMXML_UserCode type="functionHeaderDensity" >
     // TODO: Add extra function headers within this block
public:
    // djj
	//! Set Error
	plmxml_api::Result SetError( double arg );

     //! Get Error
	double GetError() const;

	//! Check if Error is set
	plmxml_api::logical HasError() const;

	//! Unset Error
	plmxml_api::Result UnsetError();
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassDensity;


////////////////////////////////////////////////////////////////////////////////////
//! Colour class
/*!
\verbatim

      This Property represents the colour of an object.

      Attributes:

      ambient:          ambient colour
      ambientOverride:  The override rules for the ambient attribute.
      diffuse:          diffuse colour
      diffuseOverride:  The override rules for the diffuse attribute.
      specular:         specular colour
      specularOverride: The override rules for the specular attribute.
      emissive:         emissive colour
      emissiveOverride: The override rules for the emissive attribute.
      shininess:        shininess coefficient (0-255)
      shininessOverride: The override rules for the shininess attribute.
      alpha:            alpha coefficient (0-1)
      alphaOverride:    The override rules for the alpha attribute.
      colourId:         string id of the colour
      type:             a string indicating the use of the colour in the owning
                        element.
      typeRef:          References a multiple language version of type. If
                        multiple language support is required, typeRef should be
                        used in addition to type.
      
\endverbatim
*/
class PLMXML60_API Colour : public Property
{
public:
     
    //! Default constructor
    Colour( );
     
    //! Constructs a Colour with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Colour( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Colour();

private:

	//! Assignment operator
	Colour& operator=( const Colour& iSrc );

	//! Copy constructor
	Colour( const Colour& original );
     
public:

	//! Set Ambient array
	plmxml_api::Result SetAmbient( const double *arg );

	//! Get Ambient array
	plmxml_api::Result GetAmbient( double *arg ) const;

	//! Check if Ambient array is set
	plmxml_api::logical HasAmbient() const;

	//! Unset Ambient array
	plmxml_api::Result UnsetAmbient();

	//! Set AlphaOverride
	plmxml_api::Result SetAlphaOverride( const ePropertyOverrideEnum& arg );

	//! Get AlphaOverride
	ePropertyOverrideEnum GetAlphaOverride() const;

	//! Set AmbientOverride
	plmxml_api::Result SetAmbientOverride( const ePropertyOverrideEnum& arg );

	//! Get AmbientOverride
	ePropertyOverrideEnum GetAmbientOverride() const;

	//! Set Diffuse array
	plmxml_api::Result SetDiffuse( const double *arg );

	//! Get Diffuse array
	plmxml_api::Result GetDiffuse( double *arg ) const;

	//! Check if Diffuse array is set
	plmxml_api::logical HasDiffuse() const;

	//! Unset Diffuse array
	plmxml_api::Result UnsetDiffuse();

	//! Set Specular array
	plmxml_api::Result SetSpecular( const double *arg );

	//! Get Specular array
	plmxml_api::Result GetSpecular( double *arg ) const;

	//! Check if Specular array is set
	plmxml_api::logical HasSpecular() const;

	//! Unset Specular array
	plmxml_api::Result UnsetSpecular();

	//! Get Type URI as plmxml_api::String
	plmxml_api::String GetTypeURI() const;

	//! Set Type URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetTypeURI( const plmxml_api::String& );
	
	//! Get the handle of Type URI. Does not resolve the URI.
	plmxml_api::Result GetTypeURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Type URI. URI string is unchanged.
	plmxml_api::Result SetTypeURI( const plmxml_api::Handle& );
	
	//! Resolve Type URI and return an object (handle) it points to.
	plmxml_api::Result ResolveTypeURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Type URI. Clears URI string and handle.
	plmxml_api::Result DeleteTypeURI();
	
	//! Check if Type URI is set
	plmxml_api::logical HasTypeURI( ) const;
	

	//! Set Shininess
	plmxml_api::Result SetShininess( double arg );

     //! Get Shininess
	double GetShininess() const;

	//! Check if Shininess is set
	plmxml_api::logical HasShininess() const;

	//! Unset Shininess
	plmxml_api::Result UnsetShininess();

	//! Get Type of this Colour
	plmxml_api::String GetType() const;

	//! Set Type of this Colour
	plmxml_api::Result SetType( const plmxml_api::String &s );
	
	//! Check if Type is set
	plmxml_api::logical HasType( ) const;
	
	//! Unset Type
	plmxml_api::Result UnsetType( );

	//! Set DiffuseOverride
	plmxml_api::Result SetDiffuseOverride( const ePropertyOverrideEnum& arg );

	//! Get DiffuseOverride
	ePropertyOverrideEnum GetDiffuseOverride() const;

	//! Set EmissiveOverride
	plmxml_api::Result SetEmissiveOverride( const ePropertyOverrideEnum& arg );

	//! Get EmissiveOverride
	ePropertyOverrideEnum GetEmissiveOverride() const;

	//! Set Alpha
	plmxml_api::Result SetAlpha( double arg );

     //! Get Alpha
	double GetAlpha() const;

	//! Check if Alpha is set
	plmxml_api::logical HasAlpha() const;

	//! Unset Alpha
	plmxml_api::Result UnsetAlpha();

	//! Set Emissive array
	plmxml_api::Result SetEmissive( const double *arg );

	//! Get Emissive array
	plmxml_api::Result GetEmissive( double *arg ) const;

	//! Check if Emissive array is set
	plmxml_api::logical HasEmissive() const;

	//! Unset Emissive array
	plmxml_api::Result UnsetEmissive();

	//! Set ShininessOverride
	plmxml_api::Result SetShininessOverride( const ePropertyOverrideEnum& arg );

	//! Get ShininessOverride
	ePropertyOverrideEnum GetShininessOverride() const;

	//! Set SpecularOverride
	plmxml_api::Result SetSpecularOverride( const ePropertyOverrideEnum& arg );

	//! Get SpecularOverride
	ePropertyOverrideEnum GetSpecularOverride() const;

	//! Get ColourId of this Colour
	plmxml_api::String GetColourId() const;

	//! Set ColourId of this Colour
	plmxml_api::Result SetColourId( const plmxml_api::String &s );
	
	//! Check if ColourId is set
	plmxml_api::logical HasColourId( ) const;
	
	//! Unset ColourId
	plmxml_api::Result UnsetColourId( );
 
// <PLMXML_UserCode type="functionHeaderColour" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassColour;


////////////////////////////////////////////////////////////////////////////////////
//! ThermalExpansionCoefficient class
/*!
\verbatim

      This Property gives the (volume) Thermal Expansion Coefficient of an object.
      
      Elements:
      
      ValueWithUnit
      RangeWithUnit  one of these sub-elements should be used to indicate the value
                     or range of the Property.
      
\endverbatim
*/
class PLMXML60_API ThermalExpansionCoefficient : public Property
{
public:
     
    //! Default constructor
    ThermalExpansionCoefficient( );
     
    //! Constructs a ThermalExpansionCoefficient with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ThermalExpansionCoefficient( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ThermalExpansionCoefficient();

private:

	//! Assignment operator
	ThermalExpansionCoefficient& operator=( const ThermalExpansionCoefficient& iSrc );

	//! Copy constructor
	ThermalExpansionCoefficient( const ThermalExpansionCoefficient& original );
     
public:

	//! Add ValueWithUnit child element to this ThermalExpansionCoefficient. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	ValueWithUnit *AddValueWithUnit();
     
	//! Set ValueWithUnit child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetValueWithUnit( ValueWithUnit *arg );
     
	//! Get ValueWithUnit child element of this ThermalExpansionCoefficient.
	ValueWithUnit *GetValueWithUnit() const;
     
	//! Detach and delete ValueWithUnit child element tree from this ThermalExpansionCoefficient.
	void DeleteValueWithUnit();

	//! Add RangeWithUnit child element to this ThermalExpansionCoefficient. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	RangeWithUnit *AddRangeWithUnit();
     
	//! Set RangeWithUnit child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetRangeWithUnit( RangeWithUnit *arg );
     
	//! Get RangeWithUnit child element of this ThermalExpansionCoefficient.
	RangeWithUnit *GetRangeWithUnit() const;
     
	//! Detach and delete RangeWithUnit child element tree from this ThermalExpansionCoefficient.
	void DeleteRangeWithUnit();
 
// <PLMXML_UserCode type="functionHeaderThermalExpansionCoefficient" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassThermalExpansionCoefficient;


////////////////////////////////////////////////////////////////////////////////////
//! ThermalConductivity class
/*!
\verbatim

      This Property gives the Thermal Conductivity of an object.
      
      Elements:
      
      ValueWithUnit
      RangeWithUnit  one of these sub-elements should be used to indicate the value
                     or range of the Property.
      
\endverbatim
*/
class PLMXML60_API ThermalConductivity : public Property
{
public:
     
    //! Default constructor
    ThermalConductivity( );
     
    //! Constructs a ThermalConductivity with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ThermalConductivity( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ThermalConductivity();

private:

	//! Assignment operator
	ThermalConductivity& operator=( const ThermalConductivity& iSrc );

	//! Copy constructor
	ThermalConductivity( const ThermalConductivity& original );
     
public:

	//! Add ValueWithUnit child element to this ThermalConductivity. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	ValueWithUnit *AddValueWithUnit();
     
	//! Set ValueWithUnit child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetValueWithUnit( ValueWithUnit *arg );
     
	//! Get ValueWithUnit child element of this ThermalConductivity.
	ValueWithUnit *GetValueWithUnit() const;
     
	//! Detach and delete ValueWithUnit child element tree from this ThermalConductivity.
	void DeleteValueWithUnit();

	//! Add RangeWithUnit child element to this ThermalConductivity. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	RangeWithUnit *AddRangeWithUnit();
     
	//! Set RangeWithUnit child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetRangeWithUnit( RangeWithUnit *arg );
     
	//! Get RangeWithUnit child element of this ThermalConductivity.
	RangeWithUnit *GetRangeWithUnit() const;
     
	//! Detach and delete RangeWithUnit child element tree from this ThermalConductivity.
	void DeleteRangeWithUnit();
 
// <PLMXML_UserCode type="functionHeaderThermalConductivity" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassThermalConductivity;


////////////////////////////////////////////////////////////////////////////////////
//! SpecificHeatCapacity class
/*!
\verbatim

      This Property gives the Specific Heat Capacity of an object.
      
      Attributes:
      
      type:          constantPressure (default) or constantVolume
      
      Elements:
      
      ValueWithUnit
      RangeWithUnit  one of these sub-elements should be used to indicate the value
                     or range of the Rated Voltage.
      
\endverbatim
*/
class PLMXML60_API SpecificHeatCapacity : public Property
{
public:
     
    //! Default constructor
    SpecificHeatCapacity( );
     
    //! Constructs a SpecificHeatCapacity with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    SpecificHeatCapacity( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~SpecificHeatCapacity();

private:

	//! Assignment operator
	SpecificHeatCapacity& operator=( const SpecificHeatCapacity& iSrc );

	//! Copy constructor
	SpecificHeatCapacity( const SpecificHeatCapacity& original );
     
public:

	//! Set Type
	plmxml_api::Result SetType( const eSpecificHeatCapacityEnum& arg );

	//! Get Type
	eSpecificHeatCapacityEnum GetType() const;

	//! Add ValueWithUnit child element to this SpecificHeatCapacity. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	ValueWithUnit *AddValueWithUnit();
     
	//! Set ValueWithUnit child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetValueWithUnit( ValueWithUnit *arg );
     
	//! Get ValueWithUnit child element of this SpecificHeatCapacity.
	ValueWithUnit *GetValueWithUnit() const;
     
	//! Detach and delete ValueWithUnit child element tree from this SpecificHeatCapacity.
	void DeleteValueWithUnit();

	//! Add RangeWithUnit child element to this SpecificHeatCapacity. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	RangeWithUnit *AddRangeWithUnit();
     
	//! Set RangeWithUnit child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetRangeWithUnit( RangeWithUnit *arg );
     
	//! Get RangeWithUnit child element of this SpecificHeatCapacity.
	RangeWithUnit *GetRangeWithUnit() const;
     
	//! Detach and delete RangeWithUnit child element tree from this SpecificHeatCapacity.
	void DeleteRangeWithUnit();
 
// <PLMXML_UserCode type="functionHeaderSpecificHeatCapacity" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassSpecificHeatCapacity;


////////////////////////////////////////////////////////////////////////////////////
//! ModulusOfElasticity class
/*!
\verbatim

      This Property gives the Modulus of Elasticity of an object (also known 
      as Young's Modulus).
      
      Elements:
      
      ValueWithUnit
      RangeWithUnit  one of these sub-elements should be used to indicate the value
                     or range of the Property.
      
\endverbatim
*/
class PLMXML60_API ModulusOfElasticity : public Property
{
public:
     
    //! Default constructor
    ModulusOfElasticity( );
     
    //! Constructs a ModulusOfElasticity with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ModulusOfElasticity( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ModulusOfElasticity();

private:

	//! Assignment operator
	ModulusOfElasticity& operator=( const ModulusOfElasticity& iSrc );

	//! Copy constructor
	ModulusOfElasticity( const ModulusOfElasticity& original );
     
public:

	//! Add ValueWithUnit child element to this ModulusOfElasticity. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	ValueWithUnit *AddValueWithUnit();
     
	//! Set ValueWithUnit child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetValueWithUnit( ValueWithUnit *arg );
     
	//! Get ValueWithUnit child element of this ModulusOfElasticity.
	ValueWithUnit *GetValueWithUnit() const;
     
	//! Detach and delete ValueWithUnit child element tree from this ModulusOfElasticity.
	void DeleteValueWithUnit();

	//! Add RangeWithUnit child element to this ModulusOfElasticity. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	RangeWithUnit *AddRangeWithUnit();
     
	//! Set RangeWithUnit child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetRangeWithUnit( RangeWithUnit *arg );
     
	//! Get RangeWithUnit child element of this ModulusOfElasticity.
	RangeWithUnit *GetRangeWithUnit() const;
     
	//! Detach and delete RangeWithUnit child element tree from this ModulusOfElasticity.
	void DeleteRangeWithUnit();
 
// <PLMXML_UserCode type="functionHeaderModulusOfElasticity" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassModulusOfElasticity;


////////////////////////////////////////////////////////////////////////////////////
//! PoissonsRatio class
/*!
\verbatim

      This Property gives the Poisson's Ratio of an object.
      
      Attributes:
      
      value:         value of Poissons' Ratio
      lowerLimit:    lower limit
      upperLimit:    upper limit
      
\endverbatim
*/
class PLMXML60_API PoissonsRatio : public Property
{
public:
     
    //! Default constructor
    PoissonsRatio( );
     
    //! Constructs a PoissonsRatio with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    PoissonsRatio( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~PoissonsRatio();

private:

	//! Assignment operator
	PoissonsRatio& operator=( const PoissonsRatio& iSrc );

	//! Copy constructor
	PoissonsRatio( const PoissonsRatio& original );
     
public:

	//! Set LowerLimit
	plmxml_api::Result SetLowerLimit( double arg );

     //! Get LowerLimit
	double GetLowerLimit() const;

	//! Check if LowerLimit is set
	plmxml_api::logical HasLowerLimit() const;

	//! Unset LowerLimit
	plmxml_api::Result UnsetLowerLimit();

	//! Set UpperLimit
	plmxml_api::Result SetUpperLimit( double arg );

     //! Get UpperLimit
	double GetUpperLimit() const;

	//! Check if UpperLimit is set
	plmxml_api::logical HasUpperLimit() const;

	//! Unset UpperLimit
	plmxml_api::Result UnsetUpperLimit();

	//! Set Value
	plmxml_api::Result SetValue( double arg );

     //! Get Value
	double GetValue() const;

	//! Check if Value is set
	plmxml_api::logical HasValue() const;

	//! Unset Value
	plmxml_api::Result UnsetValue();
 
// <PLMXML_UserCode type="functionHeaderPoissonsRatio" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassPoissonsRatio;


////////////////////////////////////////////////////////////////////////////////////
//! YieldStress class
/*!
\verbatim

      This Property gives the Yield Stress of an object (the tensile stress a
      material can support without permanent deformation).
      
      Elements:
      
      ValueWithUnit
      RangeWithUnit  one of these sub-elements should be used to indicate the value
                     or range of the Property.
      
\endverbatim
*/
class PLMXML60_API YieldStress : public Property
{
public:
     
    //! Default constructor
    YieldStress( );
     
    //! Constructs a YieldStress with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    YieldStress( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~YieldStress();

private:

	//! Assignment operator
	YieldStress& operator=( const YieldStress& iSrc );

	//! Copy constructor
	YieldStress( const YieldStress& original );
     
public:

	//! Add ValueWithUnit child element to this YieldStress. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	ValueWithUnit *AddValueWithUnit();
     
	//! Set ValueWithUnit child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetValueWithUnit( ValueWithUnit *arg );
     
	//! Get ValueWithUnit child element of this YieldStress.
	ValueWithUnit *GetValueWithUnit() const;
     
	//! Detach and delete ValueWithUnit child element tree from this YieldStress.
	void DeleteValueWithUnit();

	//! Add RangeWithUnit child element to this YieldStress. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	RangeWithUnit *AddRangeWithUnit();
     
	//! Set RangeWithUnit child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetRangeWithUnit( RangeWithUnit *arg );
     
	//! Get RangeWithUnit child element of this YieldStress.
	RangeWithUnit *GetRangeWithUnit() const;
     
	//! Detach and delete RangeWithUnit child element tree from this YieldStress.
	void DeleteRangeWithUnit();
 
// <PLMXML_UserCode type="functionHeaderYieldStress" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassYieldStress;


////////////////////////////////////////////////////////////////////////////////////
//! UltimateStress class
/*!
\verbatim

      This Property gives the Ultimate Stress of an object (the tensile stress a
      material can support without breaking).
      
      Elements:
      
      ValueWithUnit
      RangeWithUnit  one of these sub-elements should be used to indicate the value
                     or range of the Property.
      
\endverbatim
*/
class PLMXML60_API UltimateStress : public Property
{
public:
     
    //! Default constructor
    UltimateStress( );
     
    //! Constructs a UltimateStress with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    UltimateStress( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~UltimateStress();

private:

	//! Assignment operator
	UltimateStress& operator=( const UltimateStress& iSrc );

	//! Copy constructor
	UltimateStress( const UltimateStress& original );
     
public:

	//! Add ValueWithUnit child element to this UltimateStress. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	ValueWithUnit *AddValueWithUnit();
     
	//! Set ValueWithUnit child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetValueWithUnit( ValueWithUnit *arg );
     
	//! Get ValueWithUnit child element of this UltimateStress.
	ValueWithUnit *GetValueWithUnit() const;
     
	//! Detach and delete ValueWithUnit child element tree from this UltimateStress.
	void DeleteValueWithUnit();

	//! Add RangeWithUnit child element to this UltimateStress. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	RangeWithUnit *AddRangeWithUnit();
     
	//! Set RangeWithUnit child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetRangeWithUnit( RangeWithUnit *arg );
     
	//! Get RangeWithUnit child element of this UltimateStress.
	RangeWithUnit *GetRangeWithUnit() const;
     
	//! Detach and delete RangeWithUnit child element tree from this UltimateStress.
	void DeleteRangeWithUnit();
 
// <PLMXML_UserCode type="functionHeaderUltimateStress" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassUltimateStress;


////////////////////////////////////////////////////////////////////////////////////
//! UltimateElongation class
/*!
\verbatim

      This Property gives the Ultimate Elongation of an object, that is, the 
      strain an object can support under tensile stress, before breaking. Note
      this is a ratio, not a percentage.
      
      Attributes:
      
      value:         value of Ultimate Elongation.
      lowerLimit:    lower limit
      upperLimit:    upper limit
      
\endverbatim
*/
class PLMXML60_API UltimateElongation : public Property
{
public:
     
    //! Default constructor
    UltimateElongation( );
     
    //! Constructs a UltimateElongation with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    UltimateElongation( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~UltimateElongation();

private:

	//! Assignment operator
	UltimateElongation& operator=( const UltimateElongation& iSrc );

	//! Copy constructor
	UltimateElongation( const UltimateElongation& original );
     
public:

	//! Set LowerLimit
	plmxml_api::Result SetLowerLimit( double arg );

     //! Get LowerLimit
	double GetLowerLimit() const;

	//! Check if LowerLimit is set
	plmxml_api::logical HasLowerLimit() const;

	//! Unset LowerLimit
	plmxml_api::Result UnsetLowerLimit();

	//! Set UpperLimit
	plmxml_api::Result SetUpperLimit( double arg );

     //! Get UpperLimit
	double GetUpperLimit() const;

	//! Check if UpperLimit is set
	plmxml_api::logical HasUpperLimit() const;

	//! Unset UpperLimit
	plmxml_api::Result UnsetUpperLimit();

	//! Set Value
	plmxml_api::Result SetValue( double arg );

     //! Get Value
	double GetValue() const;

	//! Check if Value is set
	plmxml_api::logical HasValue() const;

	//! Unset Value
	plmxml_api::Result UnsetValue();
 
// <PLMXML_UserCode type="functionHeaderUltimateElongation" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassUltimateElongation;


////////////////////////////////////////////////////////////////////////////////////
//! SurfaceArea class
/*!
\verbatim

      This Property gives the Surface Area of an object.
      
      Elements:
      
      ValueWithUnit
      RangeWithUnit  one of these sub-elements should be used to indicate the value
                     or range of the Property.
      
\endverbatim
*/
class PLMXML60_API SurfaceArea : public Property
{
public:
     
    //! Default constructor
    SurfaceArea( );
     
    //! Constructs a SurfaceArea with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    SurfaceArea( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~SurfaceArea();

private:

	//! Assignment operator
	SurfaceArea& operator=( const SurfaceArea& iSrc );

	//! Copy constructor
	SurfaceArea( const SurfaceArea& original );
     
public:

	//! Add ValueWithUnit child element to this SurfaceArea. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	ValueWithUnit *AddValueWithUnit();
     
	//! Set ValueWithUnit child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetValueWithUnit( ValueWithUnit *arg );
     
	//! Get ValueWithUnit child element of this SurfaceArea.
	ValueWithUnit *GetValueWithUnit() const;
     
	//! Detach and delete ValueWithUnit child element tree from this SurfaceArea.
	void DeleteValueWithUnit();

	//! Add RangeWithUnit child element to this SurfaceArea. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	RangeWithUnit *AddRangeWithUnit();
     
	//! Set RangeWithUnit child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetRangeWithUnit( RangeWithUnit *arg );
     
	//! Get RangeWithUnit child element of this SurfaceArea.
	RangeWithUnit *GetRangeWithUnit() const;
     
	//! Detach and delete RangeWithUnit child element tree from this SurfaceArea.
	void DeleteRangeWithUnit();
 
// <PLMXML_UserCode type="functionHeaderSurfaceArea" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassSurfaceArea;


////////////////////////////////////////////////////////////////////////////////////
//! Volume class
/*!
\verbatim

      This Property gives the Volume of an object.
      
      Elements:
      
      ValueWithUnit
      RangeWithUnit  one of these sub-elements should be used to indicate the value
                     or range of the Property.
      
\endverbatim
*/
class PLMXML60_API Volume : public Property
{
public:
     
    //! Default constructor
    Volume( );
     
    //! Constructs a Volume with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Volume( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Volume();

private:

	//! Assignment operator
	Volume& operator=( const Volume& iSrc );

	//! Copy constructor
	Volume( const Volume& original );
     
public:

	//! Add ValueWithUnit child element to this Volume. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	ValueWithUnit *AddValueWithUnit();
     
	//! Set ValueWithUnit child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetValueWithUnit( ValueWithUnit *arg );
     
	//! Get ValueWithUnit child element of this Volume.
	ValueWithUnit *GetValueWithUnit() const;
     
	//! Detach and delete ValueWithUnit child element tree from this Volume.
	void DeleteValueWithUnit();

	//! Add RangeWithUnit child element to this Volume. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	RangeWithUnit *AddRangeWithUnit();
     
	//! Set RangeWithUnit child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetRangeWithUnit( RangeWithUnit *arg );
     
	//! Get RangeWithUnit child element of this Volume.
	RangeWithUnit *GetRangeWithUnit() const;
     
	//! Detach and delete RangeWithUnit child element tree from this Volume.
	void DeleteRangeWithUnit();
 
// <PLMXML_UserCode type="functionHeaderVolume" >
     // TODO: Add extra function headers within this block
public:
    // djj
	//! Set Error
	plmxml_api::Result SetError( double arg );

     //! Get Error
	double GetError() const;

	//! Check if Error is set
	plmxml_api::logical HasError() const;

	//! Unset Error
	plmxml_api::Result UnsetError();
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassVolume;


////////////////////////////////////////////////////////////////////////////////////
//! CentreOfMass class
/*!
\verbatim

      This Property gives the Centre of Mass of an object.
      
      Attributes:
      
      value:         The vector position of the Centre Of Mass (in metres).
      
      Elements:
      
      Bound:         The Bound sub-element, if present, gives an error bound
                     on the centre of mass.
      
\endverbatim
*/
class PLMXML60_API CentreOfMass : public Property
{
public:
     
    //! Default constructor
    CentreOfMass( );
     
    //! Constructs a CentreOfMass with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    CentreOfMass( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~CentreOfMass();

private:

	//! Assignment operator
	CentreOfMass& operator=( const CentreOfMass& iSrc );

	//! Copy constructor
	CentreOfMass( const CentreOfMass& original );
     
public:

	//! Set Value using plmxml_api::Vector components
	plmxml_api::Result SetValue( const plmxml_api::Vector& arg );

	//! Get Value as plmxml_api::Vector
	plmxml_api::Result GetValue( plmxml_api::Vector& arg ) const;

	//! Check if Value is set
	plmxml_api::logical HasValue() const;

	//! Unset Value
	plmxml_api::Result UnsetValue();

	//! Add Bound child element to this CentreOfMass. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	Bound *AddBound();
     
	//! Set Bound child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetBound( Bound *arg );
     
	//! Get Bound child element of this CentreOfMass.
	Bound *GetBound() const;
     
	//! Detach and delete Bound child element tree from this CentreOfMass.
	void DeleteBound();
 
// <PLMXML_UserCode type="functionHeaderCentreOfMass" >
     // TODO: Add extra function headers within this block
public:
    // djj
	//! Set Error
	plmxml_api::Result SetError( double arg );

     //! Get Error
	double GetError() const;

	//! Check if Error is set
	plmxml_api::logical HasError() const;

	//! Unset Error
	plmxml_api::Result UnsetError();
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassCentreOfMass;


////////////////////////////////////////////////////////////////////////////////////
//! Inertia class
/*!
\verbatim

      This Property gives the Inertia Tensor of an object, at its Centre of
      Mass.
      
      Attributes:
      
      value:        The value of the Inertia matrix. Only 6 values are given,
                    in the order Ixx, Ixy, Ixz, Iyy, Iyz, Izz, as the matrix
                    is symmetric.
      error:        If present, this gives the error bound for the Inertia, as
                    12 doubles, in the order Ixx-min, Ixx-max, Ixy-min, Ixy-max,
                    etc.
      unitRef:      Reference to a Unit element. If absent, S.I. units are
                    assumed.
      
\endverbatim
*/
class PLMXML60_API Inertia : public Property
{
public:
     
    //! Default constructor
    Inertia( );
     
    //! Constructs a Inertia with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Inertia( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Inertia();

private:

	//! Assignment operator
	Inertia& operator=( const Inertia& iSrc );

	//! Copy constructor
	Inertia( const Inertia& original );
     
public:

	//! Set Error
	plmxml_api::Result SetError( const plmxml_api::Array<double>& arg );

	//! Get Error
	plmxml_api::Result GetError( plmxml_api::Array<double>& arg ) const;

	//! Check if Error is set
	plmxml_api::logical HasError() const;

	//! Unset Error
	plmxml_api::Result UnsetError();

	//! Get Unit URI as plmxml_api::String
	plmxml_api::String GetUnitURI() const;

	//! Set Unit URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetUnitURI( const plmxml_api::String& );
	
	//! Get the handle of Unit URI. Does not resolve the URI.
	plmxml_api::Result GetUnitURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Unit URI. URI string is unchanged.
	plmxml_api::Result SetUnitURI( const plmxml_api::Handle& );
	
	//! Resolve Unit URI and return an object (handle) it points to.
	plmxml_api::Result ResolveUnitURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Unit URI. Clears URI string and handle.
	plmxml_api::Result DeleteUnitURI();
	
	//! Check if Unit URI is set
	plmxml_api::logical HasUnitURI( ) const;
	

	//! Set Value
	plmxml_api::Result SetValue( const plmxml_api::Array<double>& arg );

	//! Get Value
	plmxml_api::Result GetValue( plmxml_api::Array<double>& arg ) const;

	//! Check if Value is set
	plmxml_api::logical HasValue() const;

	//! Unset Value
	plmxml_api::Result UnsetValue();
 
// <PLMXML_UserCode type="functionHeaderInertia" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassInertia;


////////////////////////////////////////////////////////////////////////////////////
//! SetFilter class
/*!
\verbatim

      A type of Filter which is defined in terms of set operations on other
      Filters.

      Attributes:

      operation:        unite, intersect, or complement
      subFilterRefs:    References component 4GD Search Criteria allowing them to be shared.

      Elements:

      OccurrenceFilter: Filters to be combined. If operation="complement", the Filters
                        are implicitly united before the Complement is performed.
      
\endverbatim
*/
class PLMXML60_API SetFilter : public OccurrenceFilter
{
public:
     
    //! Default constructor
    SetFilter( );
     
    //! Constructs a SetFilter with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    SetFilter( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~SetFilter();

private:

	//! Assignment operator
	SetFilter& operator=( const SetFilter& iSrc );

	//! Copy constructor
	SetFilter( const SetFilter& original );
     
public:

	//! Set Operation
	plmxml_api::Result SetOperation( const eSetFilterOperationEnum& arg );

	//! Get Operation
	eSetFilterOperationEnum GetOperation() const;

	//! Get number of URIs in SubFilter
	int NumberOfSubFilterURIs() const;

	//! Get i'th URI in SubFilter
	plmxml_api::String GetSubFilterURI( int i ) const;

	//! Add a URI to SubFilter array. Call ResolveSubFilterURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddSubFilterURI( const plmxml_api::String& u );

	//! Set i'th URI in SubFilter array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetSubFilterURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of SubFilter URI. Does not resolve the URI.
	plmxml_api::Result GetSubFilterURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to SubFilter array.
	plmxml_api::Result AddSubFilterURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in SubFilter array to point to 'handle'.
	plmxml_api::Result SetSubFilterURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in SubFilter points to.
	plmxml_api::Result ResolveSubFilterURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from SubFilter array.
	plmxml_api::Result DeleteSubFilterURI( int i );

	//! Remove all URIs from SubFilter array.
	plmxml_api::Result DeleteSubFilterURIs( );
	
	//! Check if SubFilter is set
	plmxml_api::logical HasSubFilterURIs( ) const;

	//! Add OccurrenceFilter child element to this SetFilter. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	OccurrenceFilter *AddOccurrenceFilter();
     
	//! Add 'arg' as OccurrenceFilter child element to this SetFilter.
	plmxml_api::Result AddOccurrenceFilter( OccurrenceFilter *arg );

	//! Detach and delete all OccurrenceFilter child elements.
	void DeleteOccurrenceFilters();
     
	//! Get number of OccurrenceFilter child elements.
	int NumberOfOccurrenceFilters() const;
     
	//! Get i'th OccurrenceFilter child element.
	OccurrenceFilter *GetOccurrenceFilter( int i ) const;
     
	//! Get all OccurrenceFilter child element as an array
	void GetOccurrenceFilters( plmxml_api::Array<OccurrenceFilter*> &array ) const;
	     
	//! Detach and delete i'th OccurrenceFilter child element
	void DeleteOccurrenceFilter( int i );
     
	//! Detach and delete 'arg' if it's one of the OccurrenceFilter child elements
	void DeleteOccurrenceFilter( OccurrenceFilter *arg );
 
// <PLMXML_UserCode type="functionHeaderSetFilter" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassSetFilter;


////////////////////////////////////////////////////////////////////////////////////
//! GroupFilter class
/*!
\verbatim

      A type of Filter which specifies an explicit collection of Occurrences. The filter
      specifies two lists of Occurrences. Those in the first list are simply added to the
      output of the Filter, without child Occurrences being included. Those in the second
      list result in the output of the Filter also containing their (recursive) child
      Occurrences.

      Attributes:

      targetRefs:       Occurrences, not including their child Occurrences
      targetRecursiveRefs: Occurrences, recursively including their child Occurrences
      excludedRefs:     References explicit non-target 4GD Design Elements and Design Features.
      
\endverbatim
*/
class PLMXML60_API GroupFilter : public OccurrenceFilter
{
public:
     
    //! Default constructor
    GroupFilter( );
     
    //! Constructs a GroupFilter with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    GroupFilter( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~GroupFilter();

private:

	//! Assignment operator
	GroupFilter& operator=( const GroupFilter& iSrc );

	//! Copy constructor
	GroupFilter( const GroupFilter& original );
     
public:

	//! Get number of URIs in TargetRecursive
	int NumberOfTargetRecursiveURIs() const;

	//! Get i'th URI in TargetRecursive
	plmxml_api::String GetTargetRecursiveURI( int i ) const;

	//! Add a URI to TargetRecursive array. Call ResolveTargetRecursiveURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddTargetRecursiveURI( const plmxml_api::String& u );

	//! Set i'th URI in TargetRecursive array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetTargetRecursiveURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of TargetRecursive URI. Does not resolve the URI.
	plmxml_api::Result GetTargetRecursiveURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to TargetRecursive array.
	plmxml_api::Result AddTargetRecursiveURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in TargetRecursive array to point to 'handle'.
	plmxml_api::Result SetTargetRecursiveURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in TargetRecursive points to.
	plmxml_api::Result ResolveTargetRecursiveURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from TargetRecursive array.
	plmxml_api::Result DeleteTargetRecursiveURI( int i );

	//! Remove all URIs from TargetRecursive array.
	plmxml_api::Result DeleteTargetRecursiveURIs( );
	
	//! Check if TargetRecursive is set
	plmxml_api::logical HasTargetRecursiveURIs( ) const;

	//! Get number of URIs in Target
	int NumberOfTargetURIs() const;

	//! Get i'th URI in Target
	plmxml_api::String GetTargetURI( int i ) const;

	//! Add a URI to Target array. Call ResolveTargetURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddTargetURI( const plmxml_api::String& u );

	//! Set i'th URI in Target array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetTargetURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Target URI. Does not resolve the URI.
	plmxml_api::Result GetTargetURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Target array.
	plmxml_api::Result AddTargetURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Target array to point to 'handle'.
	plmxml_api::Result SetTargetURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Target points to.
	plmxml_api::Result ResolveTargetURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Target array.
	plmxml_api::Result DeleteTargetURI( int i );

	//! Remove all URIs from Target array.
	plmxml_api::Result DeleteTargetURIs( );
	
	//! Check if Target is set
	plmxml_api::logical HasTargetURIs( ) const;

	//! Get number of URIs in Excluded
	int NumberOfExcludedURIs() const;

	//! Get i'th URI in Excluded
	plmxml_api::String GetExcludedURI( int i ) const;

	//! Add a URI to Excluded array. Call ResolveExcludedURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddExcludedURI( const plmxml_api::String& u );

	//! Set i'th URI in Excluded array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetExcludedURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Excluded URI. Does not resolve the URI.
	plmxml_api::Result GetExcludedURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Excluded array.
	plmxml_api::Result AddExcludedURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Excluded array to point to 'handle'.
	plmxml_api::Result SetExcludedURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Excluded points to.
	plmxml_api::Result ResolveExcludedURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Excluded array.
	plmxml_api::Result DeleteExcludedURI( int i );

	//! Remove all URIs from Excluded array.
	plmxml_api::Result DeleteExcludedURIs( );
	
	//! Check if Excluded is set
	plmxml_api::logical HasExcludedURIs( ) const;
 
// <PLMXML_UserCode type="functionHeaderGroupFilter" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassGroupFilter;


////////////////////////////////////////////////////////////////////////////////////
//! PropertyFilter class
/*!
\verbatim

      A type of Filter based on querying properties of the objects filtered. If
      the operation specified returns true, the relevant Occurrence is included.
      
      If 'operation' and 'value' are both omitted, then the PropertyFilter selects
      those Occurrences for which the indicated property has a value.
    
      Attributes:    
      
      property:           The name of the property on which the filter is based
      operation:          The operation performed on the property value
      value:              The other operand
      type:               The type of 'value'
      
\endverbatim
*/
class PLMXML60_API PropertyFilter : public OccurrenceFilter
{
public:
     
    //! Default constructor
    PropertyFilter( );
     
    //! Constructs a PropertyFilter with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    PropertyFilter( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~PropertyFilter();

private:

	//! Assignment operator
	PropertyFilter& operator=( const PropertyFilter& iSrc );

	//! Copy constructor
	PropertyFilter( const PropertyFilter& original );
     
public:

	//! Set Type
	plmxml_api::Result SetType( const eUserValueDataType& arg );

	//! Get Type
	eUserValueDataType GetType() const;

	//! Get Property of this PropertyFilter
	plmxml_api::String GetProperty() const;

	//! Set Property of this PropertyFilter
	plmxml_api::Result SetProperty( const plmxml_api::String &s );
	
	//! Check if Property is set
	plmxml_api::logical HasProperty( ) const;
	
	//! Unset Property
	plmxml_api::Result UnsetProperty( );

	//! Set Operation
	plmxml_api::Result SetOperation( const ePropertyFilterOperationEnum& arg );

	//! Get Operation
	ePropertyFilterOperationEnum GetOperation() const;

	//! Get Value of this PropertyFilter
	plmxml_api::String GetValue() const;

	//! Set Value of this PropertyFilter
	plmxml_api::Result SetValue( const plmxml_api::String &s );
	
	//! Check if Value is set
	plmxml_api::logical HasValue( ) const;
	
	//! Unset Value
	plmxml_api::Result UnsetValue( );
 
// <PLMXML_UserCode type="functionHeaderPropertyFilter" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassPropertyFilter;


////////////////////////////////////////////////////////////////////////////////////
//! ProximityZone class
/*!
\verbatim

      This is a Zone defined by a distance from a bounding shape, defined by a collection
      of objects.

      Attributes:
      
      entityRefs:           Reference to objects which defines the Zone. The objects are
                            implicitly united.
      distance:             Proximity distance in metres.
      
\endverbatim
*/
class PLMXML60_API ProximityZone : public Zone
{
public:
     
    //! Default constructor
    ProximityZone( );
     
    //! Constructs a ProximityZone with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ProximityZone( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ProximityZone();

private:

	//! Assignment operator
	ProximityZone& operator=( const ProximityZone& iSrc );

	//! Copy constructor
	ProximityZone( const ProximityZone& original );
     
public:

	//! Get number of URIs in Entity
	int NumberOfEntityURIs() const;

	//! Get i'th URI in Entity
	plmxml_api::String GetEntityURI( int i ) const;

	//! Add a URI to Entity array. Call ResolveEntityURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddEntityURI( const plmxml_api::String& u );

	//! Set i'th URI in Entity array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetEntityURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Entity URI. Does not resolve the URI.
	plmxml_api::Result GetEntityURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Entity array.
	plmxml_api::Result AddEntityURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Entity array to point to 'handle'.
	plmxml_api::Result SetEntityURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Entity points to.
	plmxml_api::Result ResolveEntityURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Entity array.
	plmxml_api::Result DeleteEntityURI( int i );

	//! Remove all URIs from Entity array.
	plmxml_api::Result DeleteEntityURIs( );
	
	//! Check if Entity is set
	plmxml_api::logical HasEntityURIs( ) const;

	//! Set Distance
	plmxml_api::Result SetDistance( double arg );

     //! Get Distance
	double GetDistance() const;

	//! Check if Distance is set
	plmxml_api::logical HasDistance() const;

	//! Unset Distance
	plmxml_api::Result UnsetDistance();
 
// <PLMXML_UserCode type="functionHeaderProximityZone" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassProximityZone;


////////////////////////////////////////////////////////////////////////////////////
//! ZoneFilter class
/*!
\verbatim

      A type of Occurrence Filter based on a geometric zone.
            
      Attributes:      
        
      includeIn:          If true, then include occurrences that are inside the zone. 
      includeOut:         If true, then include occurrences that are outside the zone. 
      includeOn:          If true, then include occurrences that intersect the zone. 
      zoneRef:            Reference to Zone element.
      
\endverbatim
*/
class PLMXML60_API ZoneFilter : public OccurrenceFilter
{
public:
     
    //! Default constructor
    ZoneFilter( );
     
    //! Constructs a ZoneFilter with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ZoneFilter( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ZoneFilter();

private:

	//! Assignment operator
	ZoneFilter& operator=( const ZoneFilter& iSrc );

	//! Copy constructor
	ZoneFilter( const ZoneFilter& original );
     
public:

	//! Set IncludeIn
	plmxml_api::Result SetIncludeIn( plmxml_api::logical arg );

	//! Get IncludeIn
	plmxml_api::logical GetIncludeIn() const;

	//! Check if IncludeIn is set
	plmxml_api::logical HasIncludeIn() const;

	//! Unset IncludeIn
	plmxml_api::Result UnsetIncludeIn();

	//! Get Zone URI as plmxml_api::String
	plmxml_api::String GetZoneURI() const;

	//! Set Zone URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetZoneURI( const plmxml_api::String& );
	
	//! Get the handle of Zone URI. Does not resolve the URI.
	plmxml_api::Result GetZoneURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Zone URI. URI string is unchanged.
	plmxml_api::Result SetZoneURI( const plmxml_api::Handle& );
	
	//! Resolve Zone URI and return an object (handle) it points to.
	plmxml_api::Result ResolveZoneURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Zone URI. Clears URI string and handle.
	plmxml_api::Result DeleteZoneURI();
	
	//! Check if Zone URI is set
	plmxml_api::logical HasZoneURI( ) const;
	

	//! Set IncludeOut
	plmxml_api::Result SetIncludeOut( plmxml_api::logical arg );

	//! Get IncludeOut
	plmxml_api::logical GetIncludeOut() const;

	//! Check if IncludeOut is set
	plmxml_api::logical HasIncludeOut() const;

	//! Unset IncludeOut
	plmxml_api::Result UnsetIncludeOut();

	//! Set IncludeOn
	plmxml_api::Result SetIncludeOn( plmxml_api::logical arg );

	//! Get IncludeOn
	plmxml_api::logical GetIncludeOn() const;

	//! Check if IncludeOn is set
	plmxml_api::logical HasIncludeOn() const;

	//! Unset IncludeOn
	plmxml_api::Result UnsetIncludeOn();
 
// <PLMXML_UserCode type="functionHeaderZoneFilter" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassZoneFilter;


////////////////////////////////////////////////////////////////////////////////////
//! ClassFilter class
/*!
\verbatim

      Filters Occurrences by Class Attribute.

      Attributes:      

      classRef:           References the Class.
      
\endverbatim
*/
class PLMXML60_API ClassFilter : public SetFilter
{
public:
     
    //! Default constructor
    ClassFilter( );
     
    //! Constructs a ClassFilter with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ClassFilter( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ClassFilter();

private:

	//! Assignment operator
	ClassFilter& operator=( const ClassFilter& iSrc );

	//! Copy constructor
	ClassFilter( const ClassFilter& original );
     
public:

	//! Get Class URI as plmxml_api::String
	plmxml_api::String GetClassURI() const;

	//! Set Class URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetClassURI( const plmxml_api::String& );
	
	//! Get the handle of Class URI. Does not resolve the URI.
	plmxml_api::Result GetClassURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Class URI. URI string is unchanged.
	plmxml_api::Result SetClassURI( const plmxml_api::Handle& );
	
	//! Resolve Class URI and return an object (handle) it points to.
	plmxml_api::Result ResolveClassURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Class URI. Clears URI string and handle.
	plmxml_api::Result DeleteClassURI();
	
	//! Check if Class URI is set
	plmxml_api::logical HasClassURI( ) const;
	
 
// <PLMXML_UserCode type="functionHeaderClassFilter" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassClassFilter;


////////////////////////////////////////////////////////////////////////////////////
//! DisplayPreferences class
/*!
\verbatim

      This Property represents the display preferences for an element such as a
      ProductRevisionView.

      Attributes:
      
      unitRef:         a Unit element giving the preferred display units.
      displayAnnotations Indicates that elements derived from Annotation3D
                       should be displayed in the target visualisation application.
      displayGeometry  Indicates that elements derived from Geometry or geometry
                       referenced via Reference elements should be displayed
                       in the target visualisation application.
      
\endverbatim
*/
class PLMXML60_API DisplayPreferences : public Property
{
public:
     
    //! Default constructor
    DisplayPreferences( );
     
    //! Constructs a DisplayPreferences with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    DisplayPreferences( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~DisplayPreferences();

private:

	//! Assignment operator
	DisplayPreferences& operator=( const DisplayPreferences& iSrc );

	//! Copy constructor
	DisplayPreferences( const DisplayPreferences& original );
     
public:

	//! Get Unit URI as plmxml_api::String
	plmxml_api::String GetUnitURI() const;

	//! Set Unit URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetUnitURI( const plmxml_api::String& );
	
	//! Get the handle of Unit URI. Does not resolve the URI.
	plmxml_api::Result GetUnitURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Unit URI. URI string is unchanged.
	plmxml_api::Result SetUnitURI( const plmxml_api::Handle& );
	
	//! Resolve Unit URI and return an object (handle) it points to.
	plmxml_api::Result ResolveUnitURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Unit URI. Clears URI string and handle.
	plmxml_api::Result DeleteUnitURI();
	
	//! Check if Unit URI is set
	plmxml_api::logical HasUnitURI( ) const;
	

	//! Set DisplayGeometry
	plmxml_api::Result SetDisplayGeometry( plmxml_api::logical arg );

	//! Get DisplayGeometry
	plmxml_api::logical GetDisplayGeometry() const;

	//! Check if DisplayGeometry is set
	plmxml_api::logical HasDisplayGeometry() const;

	//! Unset DisplayGeometry
	plmxml_api::Result UnsetDisplayGeometry();

	//! Set DisplayAnnotations
	plmxml_api::Result SetDisplayAnnotations( plmxml_api::logical arg );

	//! Get DisplayAnnotations
	plmxml_api::logical GetDisplayAnnotations() const;

	//! Check if DisplayAnnotations is set
	plmxml_api::logical HasDisplayAnnotations() const;

	//! Unset DisplayAnnotations
	plmxml_api::Result UnsetDisplayAnnotations();
 
// <PLMXML_UserCode type="functionHeaderDisplayPreferences" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassDisplayPreferences;


////////////////////////////////////////////////////////////////////////////////////
//! RepresentationEntity class
/*!
\verbatim

      A 'logical entity' which corresponds to objects in a number of equivalent
      Representations.

      Attributes:

      entityRefs:      reference to EntityRef elements in Representations
                       or CompoundReps.
      propertyRefs:    References the MaterialSpecification for the
                       RepresentationEntity.
      
\endverbatim
*/
class PLMXML60_API RepresentationEntity : public AttribOwner
{
public:
     
    //! Default constructor
    RepresentationEntity( );
     
    //! Constructs a RepresentationEntity with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    RepresentationEntity( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~RepresentationEntity();

private:

	//! Assignment operator
	RepresentationEntity& operator=( const RepresentationEntity& iSrc );

	//! Copy constructor
	RepresentationEntity( const RepresentationEntity& original );
     
public:

	//! Get number of URIs in Entity
	int NumberOfEntityURIs() const;

	//! Get i'th URI in Entity
	plmxml_api::String GetEntityURI( int i ) const;

	//! Add a URI to Entity array. Call ResolveEntityURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddEntityURI( const plmxml_api::String& u );

	//! Set i'th URI in Entity array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetEntityURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Entity URI. Does not resolve the URI.
	plmxml_api::Result GetEntityURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Entity array.
	plmxml_api::Result AddEntityURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Entity array to point to 'handle'.
	plmxml_api::Result SetEntityURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Entity points to.
	plmxml_api::Result ResolveEntityURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Entity array.
	plmxml_api::Result DeleteEntityURI( int i );

	//! Remove all URIs from Entity array.
	plmxml_api::Result DeleteEntityURIs( );
	
	//! Check if Entity is set
	plmxml_api::logical HasEntityURIs( ) const;

	//! Get number of URIs in Property
	int NumberOfPropertyURIs() const;

	//! Get i'th URI in Property
	plmxml_api::String GetPropertyURI( int i ) const;

	//! Add a URI to Property array. Call ResolvePropertyURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddPropertyURI( const plmxml_api::String& u );

	//! Set i'th URI in Property array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetPropertyURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Property URI. Does not resolve the URI.
	plmxml_api::Result GetPropertyURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Property array.
	plmxml_api::Result AddPropertyURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Property array to point to 'handle'.
	plmxml_api::Result SetPropertyURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Property points to.
	plmxml_api::Result ResolvePropertyURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Property array.
	plmxml_api::Result DeletePropertyURI( int i );

	//! Remove all URIs from Property array.
	plmxml_api::Result DeletePropertyURIs( );
	
	//! Check if Property is set
	plmxml_api::logical HasPropertyURIs( ) const;
 
// <PLMXML_UserCode type="functionHeaderRepresentationEntity" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassRepresentationEntity;


////////////////////////////////////////////////////////////////////////////////////
//! EntityPropertyGroup class
/*!
\verbatim

      This is a group of Properties which apply to a specified set of 
      RepresentationEntities.
      
      Attributes:
      
      entityRefs:      reference to RepresentationEntity elements
      
      Elements:
      
      Property         Properties of the referenced entities.
      
\endverbatim
*/
class PLMXML60_API EntityPropertyGroup : public AttribOwner
{
public:
     
    //! Default constructor
    EntityPropertyGroup( );
     
    //! Constructs a EntityPropertyGroup with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    EntityPropertyGroup( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~EntityPropertyGroup();

private:

	//! Assignment operator
	EntityPropertyGroup& operator=( const EntityPropertyGroup& iSrc );

	//! Copy constructor
	EntityPropertyGroup( const EntityPropertyGroup& original );
     
public:

	//! Get number of URIs in Entity
	int NumberOfEntityURIs() const;

	//! Get i'th URI in Entity
	plmxml_api::String GetEntityURI( int i ) const;

	//! Add a URI to Entity array. Call ResolveEntityURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddEntityURI( const plmxml_api::String& u );

	//! Set i'th URI in Entity array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetEntityURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Entity URI. Does not resolve the URI.
	plmxml_api::Result GetEntityURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Entity array.
	plmxml_api::Result AddEntityURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Entity array to point to 'handle'.
	plmxml_api::Result SetEntityURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Entity points to.
	plmxml_api::Result ResolveEntityURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Entity array.
	plmxml_api::Result DeleteEntityURI( int i );

	//! Remove all URIs from Entity array.
	plmxml_api::Result DeleteEntityURIs( );
	
	//! Check if Entity is set
	plmxml_api::logical HasEntityURIs( ) const;

	//! Add Property child element to this EntityPropertyGroup. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Property *AddProperty();
     
	//! Add 'arg' as Property child element to this EntityPropertyGroup.
	plmxml_api::Result AddProperty( Property *arg );

	//! Detach and delete all Property child elements.
	void DeleteProperties();
     
	//! Get number of Property child elements.
	int NumberOfProperties() const;
     
	//! Get i'th Property child element.
	Property *GetProperty( int i ) const;
     
	//! Get all Property child element as an array
	void GetProperties( plmxml_api::Array<Property*> &array ) const;
	     
	//! Detach and delete i'th Property child element
	void DeleteProperty( int i );
     
	//! Detach and delete 'arg' if it's one of the Property child elements
	void DeleteProperty( Property *arg );
 
// <PLMXML_UserCode type="functionHeaderEntityPropertyGroup" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassEntityPropertyGroup;


////////////////////////////////////////////////////////////////////////////////////
//! Visibility class
/*!
\verbatim

      This Property specifies whether an object is visible or not - also
      referred to as unblanked/blanked.

      Attributes:
      
      value:           logical: true is visible, false is invisible
      
\endverbatim
*/
class PLMXML60_API Visibility : public Property
{
public:
     
    //! Default constructor
    Visibility( );
     
    //! Constructs a Visibility with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Visibility( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Visibility();

private:

	//! Assignment operator
	Visibility& operator=( const Visibility& iSrc );

	//! Copy constructor
	Visibility( const Visibility& original );
     
public:

	//! Set Value
	plmxml_api::Result SetValue( plmxml_api::logical arg );

	//! Get Value
	plmxml_api::logical GetValue() const;

	//! Check if Value is set
	plmxml_api::logical HasValue() const;

	//! Unset Value
	plmxml_api::Result UnsetValue();
 
// <PLMXML_UserCode type="functionHeaderVisibility" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassVisibility;


////////////////////////////////////////////////////////////////////////////////////
//! CoordinateSystemDisplay class
/*!
\verbatim

      This Property controls the display of a Coordinate System.

      Attributes:
      
      style:           an enumeration defining the display.
      
\endverbatim
*/
class PLMXML60_API CoordinateSystemDisplay : public Property
{
public:
     
    //! Default constructor
    CoordinateSystemDisplay( );
     
    //! Constructs a CoordinateSystemDisplay with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    CoordinateSystemDisplay( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~CoordinateSystemDisplay();

private:

	//! Assignment operator
	CoordinateSystemDisplay& operator=( const CoordinateSystemDisplay& iSrc );

	//! Copy constructor
	CoordinateSystemDisplay( const CoordinateSystemDisplay& original );
     
public:

	//! Set Style
	plmxml_api::Result SetStyle( const eCoordinateSystemStyleEnum& arg );

	//! Get Style
	eCoordinateSystemStyleEnum GetStyle() const;
 
// <PLMXML_UserCode type="functionHeaderCoordinateSystemDisplay" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassCoordinateSystemDisplay;


////////////////////////////////////////////////////////////////////////////////////
//! PointDisplay class
/*!
\verbatim

      This Property controls the display of a Point.

      Attributes:
      
      style:           an enumeration defining the display.
      
\endverbatim
*/
class PLMXML60_API PointDisplay : public Property
{
public:
     
    //! Default constructor
    PointDisplay( );
     
    //! Constructs a PointDisplay with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    PointDisplay( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~PointDisplay();

private:

	//! Assignment operator
	PointDisplay& operator=( const PointDisplay& iSrc );

	//! Copy constructor
	PointDisplay( const PointDisplay& original );
     
public:

	//! Set Style
	plmxml_api::Result SetStyle( const ePointStyleEnum& arg );

	//! Get Style
	ePointStyleEnum GetStyle() const;
 
// <PLMXML_UserCode type="functionHeaderPointDisplay" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassPointDisplay;


////////////////////////////////////////////////////////////////////////////////////
//! LineDisplay class
/*!
\verbatim

      This Property controls the display of a line.

      Attributes:
      
      style:           an enumeration defining the display.
      thickness:       an enumeration defining the thickness of the line.
      widthRef:        References a LineWidth, which specifies the thickness of
                       the line quantitatively.
      
\endverbatim
*/
class PLMXML60_API LineDisplay : public Property
{
public:
     
    //! Default constructor
    LineDisplay( );
     
    //! Constructs a LineDisplay with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    LineDisplay( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~LineDisplay();

private:

	//! Assignment operator
	LineDisplay& operator=( const LineDisplay& iSrc );

	//! Copy constructor
	LineDisplay( const LineDisplay& original );
     
public:

	//! Set Thickness
	plmxml_api::Result SetThickness( const eLineThicknessEnum& arg );

	//! Get Thickness
	eLineThicknessEnum GetThickness() const;

	//! Set Style
	plmxml_api::Result SetStyle( const eLineStyleEnum& arg );

	//! Get Style
	eLineStyleEnum GetStyle() const;

	//! Set Width
	plmxml_api::Result SetWidth( double arg );

     //! Get Width
	double GetWidth() const;

	//! Check if Width is set
	plmxml_api::logical HasWidth() const;

	//! Unset Width
	plmxml_api::Result UnsetWidth();

	//! Get Width URI as plmxml_api::String
	plmxml_api::String GetWidthURI() const;

	//! Set Width URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetWidthURI( const plmxml_api::String& );
	
	//! Get the handle of Width URI. Does not resolve the URI.
	plmxml_api::Result GetWidthURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Width URI. URI string is unchanged.
	plmxml_api::Result SetWidthURI( const plmxml_api::Handle& );
	
	//! Resolve Width URI and return an object (handle) it points to.
	plmxml_api::Result ResolveWidthURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Width URI. Clears URI string and handle.
	plmxml_api::Result DeleteWidthURI();
	
	//! Check if Width URI is set
	plmxml_api::logical HasWidthURI( ) const;
	
 
// <PLMXML_UserCode type="functionHeaderLineDisplay" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassLineDisplay;


////////////////////////////////////////////////////////////////////////////////////
//! Translucency class
/*!
\verbatim

      This Property specifies the Translucency of an object.

      Attributes:
      
      value:           the Translucency. 0.0 is opaque; 1.0 is fully Translucent (invisible).
      
\endverbatim
*/
class PLMXML60_API Translucency : public Property
{
public:
     
    //! Default constructor
    Translucency( );
     
    //! Constructs a Translucency with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Translucency( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Translucency();

private:

	//! Assignment operator
	Translucency& operator=( const Translucency& iSrc );

	//! Copy constructor
	Translucency( const Translucency& original );
     
public:

	//! Set Value
	plmxml_api::Result SetValue( double arg );

     //! Get Value
	double GetValue() const;

	//! Check if Value is set
	plmxml_api::logical HasValue() const;

	//! Unset Value
	plmxml_api::Result UnsetValue();
 
// <PLMXML_UserCode type="functionHeaderTranslucency" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassTranslucency;


////////////////////////////////////////////////////////////////////////////////////
//! OccurrenceControl class
/*!
\verbatim

      This is the revision-independent element which represents control over Occurrence(s) 
      and their AbsoluteOccurrence data in a set context
       
      Attributes:
      
      controlledOccurrenceRef: the AbsoluteOccurrence controlled by this OccurrenceControl
      contextRef:            the context of the OccurrenceControl

      
\endverbatim
*/
class PLMXML60_API OccurrenceControl : public Structure
{
public:
     
    //! Default constructor
    OccurrenceControl( );
     
    //! Constructs a OccurrenceControl with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    OccurrenceControl( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~OccurrenceControl();

private:

	//! Assignment operator
	OccurrenceControl& operator=( const OccurrenceControl& iSrc );

	//! Copy constructor
	OccurrenceControl( const OccurrenceControl& original );
     
public:

	//! Get ControlledOccurrence URI as plmxml_api::String
	plmxml_api::String GetControlledOccurrenceURI() const;

	//! Set ControlledOccurrence URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetControlledOccurrenceURI( const plmxml_api::String& );
	
	//! Get the handle of ControlledOccurrence URI. Does not resolve the URI.
	plmxml_api::Result GetControlledOccurrenceURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of ControlledOccurrence URI. URI string is unchanged.
	plmxml_api::Result SetControlledOccurrenceURI( const plmxml_api::Handle& );
	
	//! Resolve ControlledOccurrence URI and return an object (handle) it points to.
	plmxml_api::Result ResolveControlledOccurrenceURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset ControlledOccurrence URI. Clears URI string and handle.
	plmxml_api::Result DeleteControlledOccurrenceURI();
	
	//! Check if ControlledOccurrence URI is set
	plmxml_api::logical HasControlledOccurrenceURI( ) const;
	

	//! Get Context URI as plmxml_api::String
	plmxml_api::String GetContextURI() const;

	//! Set Context URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetContextURI( const plmxml_api::String& );
	
	//! Get the handle of Context URI. Does not resolve the URI.
	plmxml_api::Result GetContextURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Context URI. URI string is unchanged.
	plmxml_api::Result SetContextURI( const plmxml_api::Handle& );
	
	//! Resolve Context URI and return an object (handle) it points to.
	plmxml_api::Result ResolveContextURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Context URI. Clears URI string and handle.
	plmxml_api::Result DeleteContextURI();
	
	//! Check if Context URI is set
	plmxml_api::logical HasContextURI( ) const;
	
 
// <PLMXML_UserCode type="functionHeaderOccurrenceControl" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassOccurrenceControl;


////////////////////////////////////////////////////////////////////////////////////
//! OccurrenceControlRevision class
/*!
\verbatim

      This is a revision of an OccurrenceControl
      
\endverbatim
*/
class PLMXML60_API OccurrenceControlRevision : public StructureRevision
{
public:
     
    //! Default constructor
    OccurrenceControlRevision( );
     
    //! Constructs a OccurrenceControlRevision with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    OccurrenceControlRevision( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~OccurrenceControlRevision();

private:

	//! Assignment operator
	OccurrenceControlRevision& operator=( const OccurrenceControlRevision& iSrc );

	//! Copy constructor
	OccurrenceControlRevision( const OccurrenceControlRevision& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderOccurrenceControlRevision" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassOccurrenceControlRevision;


////////////////////////////////////////////////////////////////////////////////////
//! SymbolicOccurrence class
/*!
\verbatim

      This element is used to "re-organise" an Occurrence under a new parent
      Occurrence. It references the "source" Occurrence which is being reorganised, and 
      specifies the new parent.
     
      Attributes:
    
      contextRef:            Occurrence defining the context in which the reorganisation
                             was defined
      sourceRef:             the source Occurrence or Instance being reorganised
      parentRef:             the new parent Occurrence, SymbolicOccurrence, Instance or 
                             StructureRevisionView
      showSource:            true if the source Occurrence or Instance should be displayed, 
                             as well as the reorganised one
      symbolicRefs:          the child SymbolicOccurrences
      
\endverbatim
*/
class PLMXML60_API SymbolicOccurrence : public DescriptionObject
{
public:
     
    //! Default constructor
    SymbolicOccurrence( );
     
    //! Constructs a SymbolicOccurrence with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    SymbolicOccurrence( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~SymbolicOccurrence();

private:

	//! Assignment operator
	SymbolicOccurrence& operator=( const SymbolicOccurrence& iSrc );

	//! Copy constructor
	SymbolicOccurrence( const SymbolicOccurrence& original );
     
public:

	//! Set ShowSource
	plmxml_api::Result SetShowSource( plmxml_api::logical arg );

	//! Get ShowSource
	plmxml_api::logical GetShowSource() const;

	//! Check if ShowSource is set
	plmxml_api::logical HasShowSource() const;

	//! Unset ShowSource
	plmxml_api::Result UnsetShowSource();

	//! Get Parent URI as plmxml_api::String
	plmxml_api::String GetParentURI() const;

	//! Set Parent URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetParentURI( const plmxml_api::String& );
	
	//! Get the handle of Parent URI. Does not resolve the URI.
	plmxml_api::Result GetParentURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Parent URI. URI string is unchanged.
	plmxml_api::Result SetParentURI( const plmxml_api::Handle& );
	
	//! Resolve Parent URI and return an object (handle) it points to.
	plmxml_api::Result ResolveParentURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Parent URI. Clears URI string and handle.
	plmxml_api::Result DeleteParentURI();
	
	//! Check if Parent URI is set
	plmxml_api::logical HasParentURI( ) const;
	

	//! Get Source URI as plmxml_api::String
	plmxml_api::String GetSourceURI() const;

	//! Set Source URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetSourceURI( const plmxml_api::String& );
	
	//! Get the handle of Source URI. Does not resolve the URI.
	plmxml_api::Result GetSourceURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Source URI. URI string is unchanged.
	plmxml_api::Result SetSourceURI( const plmxml_api::Handle& );
	
	//! Resolve Source URI and return an object (handle) it points to.
	plmxml_api::Result ResolveSourceURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Source URI. Clears URI string and handle.
	plmxml_api::Result DeleteSourceURI();
	
	//! Check if Source URI is set
	plmxml_api::logical HasSourceURI( ) const;
	

	//! Get number of URIs in Symbolic
	int NumberOfSymbolicURIs() const;

	//! Get i'th URI in Symbolic
	plmxml_api::String GetSymbolicURI( int i ) const;

	//! Add a URI to Symbolic array. Call ResolveSymbolicURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddSymbolicURI( const plmxml_api::String& u );

	//! Set i'th URI in Symbolic array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetSymbolicURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Symbolic URI. Does not resolve the URI.
	plmxml_api::Result GetSymbolicURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Symbolic array.
	plmxml_api::Result AddSymbolicURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Symbolic array to point to 'handle'.
	plmxml_api::Result SetSymbolicURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Symbolic points to.
	plmxml_api::Result ResolveSymbolicURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Symbolic array.
	plmxml_api::Result DeleteSymbolicURI( int i );

	//! Remove all URIs from Symbolic array.
	plmxml_api::Result DeleteSymbolicURIs( );
	
	//! Check if Symbolic is set
	plmxml_api::logical HasSymbolicURIs( ) const;

	//! Get Context URI as plmxml_api::String
	plmxml_api::String GetContextURI() const;

	//! Set Context URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetContextURI( const plmxml_api::String& );
	
	//! Get the handle of Context URI. Does not resolve the URI.
	plmxml_api::Result GetContextURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Context URI. URI string is unchanged.
	plmxml_api::Result SetContextURI( const plmxml_api::Handle& );
	
	//! Resolve Context URI and return an object (handle) it points to.
	plmxml_api::Result ResolveContextURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Context URI. Clears URI string and handle.
	plmxml_api::Result DeleteContextURI();
	
	//! Check if Context URI is set
	plmxml_api::logical HasContextURI( ) const;
	
 
// <PLMXML_UserCode type="functionHeaderSymbolicOccurrence" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassSymbolicOccurrence;


////////////////////////////////////////////////////////////////////////////////////
//! Suppression class
/*!
\verbatim

      This Property specifies the Suppression state of an object. Suppressing 
      an Occurrence effectively removes it from the Product Structure; so it 
      is not rendered, does not take part in mass property calculations, and 
      does not appear in the Bill of Materials.

      Attributes:
      
      value:           true if the object is Suppressed.
      
\endverbatim
*/
class PLMXML60_API Suppression : public Property
{
public:
     
    //! Default constructor
    Suppression( );
     
    //! Constructs a Suppression with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Suppression( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Suppression();

private:

	//! Assignment operator
	Suppression& operator=( const Suppression& iSrc );

	//! Copy constructor
	Suppression( const Suppression& original );
     
public:

	//! Set Value
	plmxml_api::Result SetValue( plmxml_api::logical arg );

	//! Get Value
	plmxml_api::logical GetValue() const;

	//! Check if Value is set
	plmxml_api::logical HasValue() const;

	//! Unset Value
	plmxml_api::Result UnsetValue();
 
// <PLMXML_UserCode type="functionHeaderSuppression" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassSuppression;


////////////////////////////////////////////////////////////////////////////////////
//! Layer class
/*!
\verbatim

      This Property specifies the Layer number of an element, for display purposes.

      Attributes:
      
      value:           the number of the Layer the object is on.
      
\endverbatim
*/
class PLMXML60_API Layer : public Property
{
public:
     
    //! Default constructor
    Layer( );
     
    //! Constructs a Layer with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Layer( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Layer();

private:

	//! Assignment operator
	Layer& operator=( const Layer& iSrc );

	//! Copy constructor
	Layer( const Layer& original );
     
public:

	//! Set Value
	plmxml_api::Result SetValue( int arg );
     
	//! Get Value
	int GetValue() const;
     
	//! Check if Value is set
	plmxml_api::logical HasValue() const;
     
	//! Unset Value
	plmxml_api::Result UnsetValue();
 
// <PLMXML_UserCode type="functionHeaderLayer" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassLayer;


////////////////////////////////////////////////////////////////////////////////////
//! TraceabilityRelation class
/*!
\verbatim

      This relation relates a "defining" element to a "complying" element.
      
      For example, the "defining" element might be a Requirements Document,
      and the "complying" element a Part.
      
\endverbatim
*/
class PLMXML60_API TraceabilityRelation : public GeneralRelation
{
public:
     
    //! Default constructor
    TraceabilityRelation( );
     
    //! Constructs a TraceabilityRelation with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    TraceabilityRelation( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~TraceabilityRelation();

private:

	//! Assignment operator
	TraceabilityRelation& operator=( const TraceabilityRelation& iSrc );

	//! Copy constructor
	TraceabilityRelation( const TraceabilityRelation& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderTraceabilityRelation" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassTraceabilityRelation;


////////////////////////////////////////////////////////////////////////////////////
//! Design class
/*!
\verbatim

      This represents the geometric definition of a Product.
      
\endverbatim
*/
class PLMXML60_API Design : public Structure
{
public:
     
    //! Default constructor
    Design( );
     
    //! Constructs a Design with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Design( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Design();

private:

	//! Assignment operator
	Design& operator=( const Design& iSrc );

	//! Copy constructor
	Design( const Design& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderDesign" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassDesign;


////////////////////////////////////////////////////////////////////////////////////
//! DesignRevision class
/*!
\verbatim

      This is a revision of a Design.
      
\endverbatim
*/
class PLMXML60_API DesignRevision : public StructureRevision
{
public:
     
    //! Default constructor
    DesignRevision( );
     
    //! Constructs a DesignRevision with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    DesignRevision( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~DesignRevision();

private:

	//! Assignment operator
	DesignRevision& operator=( const DesignRevision& iSrc );

	//! Copy constructor
	DesignRevision( const DesignRevision& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderDesignRevision" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassDesignRevision;


////////////////////////////////////////////////////////////////////////////////////
//! DesignRevisionView class
/*!
\verbatim

      This is a 'view' of a revision of a Design.
      
      Attributes:
      
      representationRefs: Representations of the DesignRevisionView.
      geometryRefs:       geometry elements referenced by the DesignRevisionView.
     
      Elements:

      Representation:     see representationRefs.
      
\endverbatim
*/
class PLMXML60_API DesignRevisionView : public StructureRevisionView
{
public:
     
    //! Default constructor
    DesignRevisionView( );
     
    //! Constructs a DesignRevisionView with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    DesignRevisionView( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~DesignRevisionView();

private:

	//! Assignment operator
	DesignRevisionView& operator=( const DesignRevisionView& iSrc );

	//! Copy constructor
	DesignRevisionView( const DesignRevisionView& original );
     
public:

	//! Get number of URIs in Geometry
	int NumberOfGeometryURIs() const;

	//! Get i'th URI in Geometry
	plmxml_api::String GetGeometryURI( int i ) const;

	//! Add a URI to Geometry array. Call ResolveGeometryURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddGeometryURI( const plmxml_api::String& u );

	//! Set i'th URI in Geometry array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetGeometryURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Geometry URI. Does not resolve the URI.
	plmxml_api::Result GetGeometryURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Geometry array.
	plmxml_api::Result AddGeometryURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Geometry array to point to 'handle'.
	plmxml_api::Result SetGeometryURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Geometry points to.
	plmxml_api::Result ResolveGeometryURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Geometry array.
	plmxml_api::Result DeleteGeometryURI( int i );

	//! Remove all URIs from Geometry array.
	plmxml_api::Result DeleteGeometryURIs( );
	
	//! Check if Geometry is set
	plmxml_api::logical HasGeometryURIs( ) const;

	//! Get number of references in Representation array
	int NumberOfRepresentationRefs() const;
     
	//! Add reference to 'arg' to Representation array
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical AddRepresentationRef( plmxml60::IdObject *arg );
     
	//! Add reference to an object pointed to by 'u' to Representation array
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical AddRepresentationId( const plmxml_api::String &u );
     
	//! Set i'th reference in Representation array to 'arg'
	/*! 
		Returns FALSE if 'arg's Id is unset otherwise TRUE.
	*/
	plmxml_api::logical SetRepresentationRef( int i, plmxml60::IdObject *arg );
     
	//! Set i'th reference in Representation array to an object pointed to by 'u'
	/*! 
		Returns FALSE if input String is empty otherwise TRUE.
	*/
	plmxml_api::logical SetRepresentationId( int i, const plmxml_api::String &u );
     
	//! Resolve i'th reference in Representation array and return an object it points to.
	plmxml60::IdObject *ResolveRepresentationRef( int i, plmxml_api::Configuration* config = NULL );
     
	//! Resolve all references in Representation array and return objects they point to.
	void ResolveRepresentationRefs( plmxml_api::Array<plmxml60::IdObject *> & array, plmxml_api::Configuration* config = NULL );
     
	//! Get i'th reference in Representation array as plmxml_api::String
	plmxml_api::String GetRepresentationId( int i ) const;
     
	//! Get all references in Representation array as an array of plmxml_api::String
	void GetRepresentationIds( plmxml_api::Array<plmxml_api::String> &array ) const;
     
	//! Remove i'th reference from the Representation array.
	void RemoveRepresentationRef( int i );
     
	//! Remove reference to an object pointed to by 'u' from the Representation array.
	void RemoveRepresentationRef( const plmxml_api::String &u );
     
	//! Remove reference to 'arg' from the Representation array.
	void RemoveRepresentationRef( plmxml60::IdObject *arg );
     
	//! Remove all references Representation array.
	void RemoveRepresentationRefs();
	
	//! Check if Representation is set
	plmxml_api::logical HasRepresentationRefs( ) const;

	//! Add Representation child element to this DesignRevisionView. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Representation *AddRepresentation();
     
	//! Add 'arg' as Representation child element to this DesignRevisionView.
	plmxml_api::Result AddRepresentation( Representation *arg );

	//! Detach and delete all Representation child elements.
	void DeleteRepresentations();
     
	//! Get number of Representation child elements.
	int NumberOfRepresentations() const;
     
	//! Get i'th Representation child element.
	Representation *GetRepresentation( int i ) const;
     
	//! Get all Representation child element as an array
	void GetRepresentations( plmxml_api::Array<Representation*> &array ) const;
	     
	//! Detach and delete i'th Representation child element
	void DeleteRepresentation( int i );
     
	//! Detach and delete 'arg' if it's one of the Representation child elements
	void DeleteRepresentation( Representation *arg );
 
// <PLMXML_UserCode type="functionHeaderDesignRevisionView" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassDesignRevisionView;


////////////////////////////////////////////////////////////////////////////////////
//! RepresentedByRelation class
/*!
\verbatim

      This relation relates a ProductRevision to a corresponding DesignRevision.
      
      Attributes:
      
      primaryDesign: Whether the referenced DesignRevision is the primary.
      
\endverbatim
*/
class PLMXML60_API RepresentedByRelation : public GeneralRelation
{
public:
     
    //! Default constructor
    RepresentedByRelation( );
     
    //! Constructs a RepresentedByRelation with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    RepresentedByRelation( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~RepresentedByRelation();

private:

	//! Assignment operator
	RepresentedByRelation& operator=( const RepresentedByRelation& iSrc );

	//! Copy constructor
	RepresentedByRelation( const RepresentedByRelation& original );
     
public:

	//! Set PrimaryDesign
	plmxml_api::Result SetPrimaryDesign( plmxml_api::logical arg );

	//! Get PrimaryDesign
	plmxml_api::logical GetPrimaryDesign() const;

	//! Check if PrimaryDesign is set
	plmxml_api::logical HasPrimaryDesign() const;

	//! Unset PrimaryDesign
	plmxml_api::Result UnsetPrimaryDesign();
 
// <PLMXML_UserCode type="functionHeaderRepresentedByRelation" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassRepresentedByRelation;


////////////////////////////////////////////////////////////////////////////////////
//! DefinitionRelation class
/*!
\verbatim

      This relation relates an Occurrence of a ProductRevisionView to a
      corresponding Occurrence of a DesignRevisionView. The inherited
      relatedRefs references must be in that order.
      
      Attributes:
      
      transform: Whether transform information in the Product Structure comes
                 from the Design Structure.
      geometry:  Whether geometry information in the Product Structure comes
                 from the Design Structure.
      
\endverbatim
*/
class PLMXML60_API DefinitionRelation : public GeneralRelation
{
public:
     
    //! Default constructor
    DefinitionRelation( );
     
    //! Constructs a DefinitionRelation with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    DefinitionRelation( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~DefinitionRelation();

private:

	//! Assignment operator
	DefinitionRelation& operator=( const DefinitionRelation& iSrc );

	//! Copy constructor
	DefinitionRelation( const DefinitionRelation& original );
     
public:

	//! Set Transform
	plmxml_api::Result SetTransform( plmxml_api::logical arg );

	//! Get Transform
	plmxml_api::logical GetTransform() const;

	//! Check if Transform is set
	plmxml_api::logical HasTransform() const;

	//! Unset Transform
	plmxml_api::Result UnsetTransform();

	//! Set Geometry
	plmxml_api::Result SetGeometry( plmxml_api::logical arg );

	//! Get Geometry
	plmxml_api::logical GetGeometry() const;

	//! Check if Geometry is set
	plmxml_api::logical HasGeometry() const;

	//! Unset Geometry
	plmxml_api::Result UnsetGeometry();
 
// <PLMXML_UserCode type="functionHeaderDefinitionRelation" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassDefinitionRelation;


////////////////////////////////////////////////////////////////////////////////////
//! Requirement class
/*!
\verbatim

      This represents a Requirement, i.e. a single Requirement for a 
      Product (not a Requirements Document).
      
\endverbatim
*/
class PLMXML60_API Requirement : public Structure
{
public:
     
    //! Default constructor
    Requirement( );
     
    //! Constructs a Requirement with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Requirement( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Requirement();

private:

	//! Assignment operator
	Requirement& operator=( const Requirement& iSrc );

	//! Copy constructor
	Requirement( const Requirement& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderRequirement" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassRequirement;


////////////////////////////////////////////////////////////////////////////////////
//! RequirementRevision class
/*!
\verbatim

      This is a revision of a Requirement.

      Attributes:

      plainRef:         References a multiple language version of PlainText. If
                        multiple language support is required, plainRef should
                        be used in addition to PlainText.
      
\endverbatim
*/
class PLMXML60_API RequirementRevision : public StructureRevision
{
public:
     
    //! Default constructor
    RequirementRevision( );
     
    //! Constructs a RequirementRevision with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    RequirementRevision( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~RequirementRevision();

private:

	//! Assignment operator
	RequirementRevision& operator=( const RequirementRevision& iSrc );

	//! Copy constructor
	RequirementRevision( const RequirementRevision& original );
     
public:

	//! Get Plain URI as plmxml_api::String
	plmxml_api::String GetPlainURI() const;

	//! Set Plain URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetPlainURI( const plmxml_api::String& );
	
	//! Get the handle of Plain URI. Does not resolve the URI.
	plmxml_api::Result GetPlainURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Plain URI. URI string is unchanged.
	plmxml_api::Result SetPlainURI( const plmxml_api::Handle& );
	
	//! Resolve Plain URI and return an object (handle) it points to.
	plmxml_api::Result ResolvePlainURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Plain URI. Clears URI string and handle.
	plmxml_api::Result DeletePlainURI();
	
	//! Check if Plain URI is set
	plmxml_api::logical HasPlainURI( ) const;
	

	//! Get PlainText of this RequirementRevision
	plmxml_api::String GetPlainText() const;

	//! Set PlainText of this RequirementRevision
	plmxml_api::Result SetPlainText( const plmxml_api::String &s );
	
	//! Check if PlainText is set
	plmxml_api::logical HasPlainText( ) const;
	
	//! Unset PlainText
	plmxml_api::Result UnsetPlainText( );
 
// <PLMXML_UserCode type="functionHeaderRequirementRevision" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassRequirementRevision;


////////////////////////////////////////////////////////////////////////////////////
//! GeometrySet class
/*!
\verbatim

      Specifies the Geometry Set of an element for display purposes.

      Attributes:

      name:             Inherited from PropertyBase. This is the name of the
                        Geometry Set. When it is referenced by the propertyRefs
                        attribute of shareable elements, such as the
                        Representations, CompoundReps, construction geometry
                        elements or Ann3DInstances of a ProductRevisionView, it
                        indicates that the elements are members of the
                        GeometrySet. When it is referenced from a
                        ProductInstance or an Occurrence of a
                        ProductRevisionView, it indicates that the element is
                        selecting the GeometrySet for display purposes.
      
\endverbatim
*/
class PLMXML60_API GeometrySet : public Property
{
public:
     
    //! Default constructor
    GeometrySet( );
     
    //! Constructs a GeometrySet with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    GeometrySet( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~GeometrySet();

private:

	//! Assignment operator
	GeometrySet& operator=( const GeometrySet& iSrc );

	//! Copy constructor
	GeometrySet( const GeometrySet& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderGeometrySet" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassGeometrySet;


////////////////////////////////////////////////////////////////////////////////////
//! MultipleLanguageItem class
/*!
\verbatim

      Text in a particular language.

      Attributes:
      
      language:         The language of the text.
      
\endverbatim
*/
class PLMXML60_API MultipleLanguageItem : public plmxml_api::Object
{
public:
     
    //! Default constructor
    MultipleLanguageItem( );
     
    //! Constructs a MultipleLanguageItem with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    MultipleLanguageItem( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~MultipleLanguageItem();

private:

	//! Assignment operator
	MultipleLanguageItem& operator=( const MultipleLanguageItem& iSrc );

	//! Copy constructor
	MultipleLanguageItem( const MultipleLanguageItem& original );
     
public:

	//! Get Language of this MultipleLanguageItem
	plmxml_api::String GetLanguage() const;

	//! Set Language of this MultipleLanguageItem
	plmxml_api::Result SetLanguage( const plmxml_api::String &s );
	
	//! Check if Language is set
	plmxml_api::logical HasLanguage( ) const;
	
	//! Unset Language
	plmxml_api::Result UnsetLanguage( );
 
// <PLMXML_UserCode type="functionHeaderMultipleLanguageItem" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassMultipleLanguageItem;


////////////////////////////////////////////////////////////////////////////////////
//! MultipleLanguageText class
/*!
\verbatim

      A container that represents text in multiple languages.

      Attributes:

      primary:          Indicates the language that is preferred in some way. It
                        also overrides the language attribute on the PLMXML
                        element. The override applies to the single language
                        versions of the attributes that correspond to the
                        referencing multiple language attributes.

      Sub-elements:

      Item:             Text in a particular language. Only Item per language
                        should be used.
      
\endverbatim
*/
class PLMXML60_API MultipleLanguageText : public IdObject
{
public:
     
    //! Default constructor
    MultipleLanguageText( );
     
    //! Constructs a MultipleLanguageText with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    MultipleLanguageText( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~MultipleLanguageText();

private:

	//! Assignment operator
	MultipleLanguageText& operator=( const MultipleLanguageText& iSrc );

	//! Copy constructor
	MultipleLanguageText( const MultipleLanguageText& original );
     
public:

	//! Get Primary of this MultipleLanguageText
	plmxml_api::String GetPrimary() const;

	//! Set Primary of this MultipleLanguageText
	plmxml_api::Result SetPrimary( const plmxml_api::String &s );
	
	//! Check if Primary is set
	plmxml_api::logical HasPrimary( ) const;
	
	//! Unset Primary
	plmxml_api::Result UnsetPrimary( );

	//! Add Item child element to this MultipleLanguageText. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	MultipleLanguageItem *AddItem();
     
	//! Add 'arg' as Item child element to this MultipleLanguageText.
	plmxml_api::Result AddItem( MultipleLanguageItem *arg );

	//! Detach and delete all Item child elements.
	void DeleteItems();
     
	//! Get number of Item child elements.
	int NumberOfItems() const;
     
	//! Get i'th Item child element.
	MultipleLanguageItem *GetItem( int i ) const;
     
	//! Get all Item child element as an array
	void GetItems( plmxml_api::Array<MultipleLanguageItem*> &array ) const;
	     
	//! Detach and delete i'th Item child element
	void DeleteItem( int i );
     
	//! Detach and delete 'arg' if it's one of the Item child elements
	void DeleteItem( MultipleLanguageItem *arg );
 
// <PLMXML_UserCode type="functionHeaderMultipleLanguageText" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassMultipleLanguageText;


////////////////////////////////////////////////////////////////////////////////////
//! GeneralExpression class
/*!
\verbatim

      The base for expressions.

      Attributes:

      expression:     The expression in the syntax given by the format attribute
                      as a string.
      format:         The format of the expression as an ExpressionFormatEnum.
      
\endverbatim
*/
class PLMXML60_API GeneralExpression : public AttribOwner
{
public:
     
    //! Default constructor
    GeneralExpression( );
     
    //! Constructs a GeneralExpression with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    GeneralExpression( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~GeneralExpression();

private:

	//! Assignment operator
	GeneralExpression& operator=( const GeneralExpression& iSrc );

	//! Copy constructor
	GeneralExpression( const GeneralExpression& original );
     
public:

	//! Set Format
	plmxml_api::Result SetFormat( const eExpressionFormatEnum& arg );

	//! Get Format
	eExpressionFormatEnum GetFormat() const;

	//! Get Expression of this GeneralExpression
	plmxml_api::String GetExpression() const;

	//! Set Expression of this GeneralExpression
	plmxml_api::Result SetExpression( const plmxml_api::String &s );
	
	//! Check if Expression is set
	plmxml_api::logical HasExpression( ) const;
	
	//! Unset Expression
	plmxml_api::Result UnsetExpression( );
 
// <PLMXML_UserCode type="functionHeaderGeneralExpression" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassGeneralExpression;


////////////////////////////////////////////////////////////////////////////////////
//! Money class
/*!
\verbatim

      Represents an amount of money in any currency.

      Attributes:

      value:          The amount of money.
      currency:       The 3 (capital) letter currency code according to ISO
                      4217.
      
\endverbatim
*/
class PLMXML60_API Money : public AttribOwner
{
public:
     
    //! Default constructor
    Money( );
     
    //! Constructs a Money with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Money( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Money();

private:

	//! Assignment operator
	Money& operator=( const Money& iSrc );

	//! Copy constructor
	Money( const Money& original );
     
public:

	//! Set Value
	plmxml_api::Result SetValue( double arg );

     //! Get Value
	double GetValue() const;

	//! Check if Value is set
	plmxml_api::logical HasValue() const;

	//! Unset Value
	plmxml_api::Result UnsetValue();

	//! Get Currency of this Money
	plmxml_api::String GetCurrency() const;

	//! Set Currency of this Money
	plmxml_api::Result SetCurrency( const plmxml_api::String &s );
	
	//! Check if Currency is set
	plmxml_api::logical HasCurrency( ) const;
	
	//! Unset Currency
	plmxml_api::Result UnsetCurrency( );
 
// <PLMXML_UserCode type="functionHeaderMoney" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassMoney;


////////////////////////////////////////////////////////////////////////////////////
//! FeatureInstance class
/*!
\verbatim

      An instance of a Feature.

      Sub-elements:

      Parameter:   Overrides the Parameters on features.
      
\endverbatim
*/
class PLMXML60_API FeatureInstance : public GDEInstance
{
public:
     
    //! Default constructor
    FeatureInstance( );
     
    //! Constructs a FeatureInstance with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    FeatureInstance( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~FeatureInstance();

private:

	//! Assignment operator
	FeatureInstance& operator=( const FeatureInstance& iSrc );

	//! Copy constructor
	FeatureInstance( const FeatureInstance& original );
     
public:

	//! Add Parameter child element to this FeatureInstance. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	UserValue *AddParameter();
     
	//! Add 'arg' as Parameter child element to this FeatureInstance.
	plmxml_api::Result AddParameter( UserValue *arg );

	//! Detach and delete all Parameter child elements.
	void DeleteParameters();
     
	//! Get number of Parameter child elements.
	int NumberOfParameters() const;
     
	//! Get i'th Parameter child element.
	UserValue *GetParameter( int i ) const;
     
	//! Get all Parameter child element as an array
	void GetParameters( plmxml_api::Array<UserValue*> &array ) const;
	     
	//! Detach and delete i'th Parameter child element
	void DeleteParameter( int i );
     
	//! Detach and delete 'arg' if it's one of the Parameter child elements
	void DeleteParameter( UserValue *arg );
 
// <PLMXML_UserCode type="functionHeaderFeatureInstance" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassFeatureInstance;


////////////////////////////////////////////////////////////////////////////////////
//! FeatureOccurrence class
/*!
\verbatim

      An occurrence of a Feature.

      Sub-elements:

      Parameter:   Overrides the Parameters on features.
      
\endverbatim
*/
class PLMXML60_API FeatureOccurrence : public Occurrence
{
public:
     
    //! Default constructor
    FeatureOccurrence( );
     
    //! Constructs a FeatureOccurrence with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    FeatureOccurrence( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~FeatureOccurrence();

private:

	//! Assignment operator
	FeatureOccurrence& operator=( const FeatureOccurrence& iSrc );

	//! Copy constructor
	FeatureOccurrence( const FeatureOccurrence& original );
     
public:

	//! Add Parameter child element to this FeatureOccurrence. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	UserValue *AddParameter();
     
	//! Add 'arg' as Parameter child element to this FeatureOccurrence.
	plmxml_api::Result AddParameter( UserValue *arg );

	//! Detach and delete all Parameter child elements.
	void DeleteParameters();
     
	//! Get number of Parameter child elements.
	int NumberOfParameters() const;
     
	//! Get i'th Parameter child element.
	UserValue *GetParameter( int i ) const;
     
	//! Get all Parameter child element as an array
	void GetParameters( plmxml_api::Array<UserValue*> &array ) const;
	     
	//! Detach and delete i'th Parameter child element
	void DeleteParameter( int i );
     
	//! Detach and delete 'arg' if it's one of the Parameter child elements
	void DeleteParameter( UserValue *arg );
 
// <PLMXML_UserCode type="functionHeaderFeatureOccurrence" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassFeatureOccurrence;


////////////////////////////////////////////////////////////////////////////////////
//! BudgetExpression class
/*!
\verbatim

      An expression for a budget definition.

      Attributes:

      expression:       Inherited from GeneralExpression. Takes values like SUM,
                        MIN, MAX or AVG.
      format:           Inherited from GeneralExpression. Must be set to
                        "excel" in this context.
      
\endverbatim
*/
class PLMXML60_API BudgetExpression : public GeneralExpression
{
public:
     
    //! Default constructor
    BudgetExpression( );
     
    //! Constructs a BudgetExpression with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    BudgetExpression( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~BudgetExpression();

private:

	//! Assignment operator
	BudgetExpression& operator=( const BudgetExpression& iSrc );

	//! Copy constructor
	BudgetExpression( const BudgetExpression& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderBudgetExpression" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassBudgetExpression;


////////////////////////////////////////////////////////////////////////////////////
//! BudgetDefinition class
/*!
\verbatim

      Represents a measurable property of a part or assembly like cost, weight
      or power.

      Attributes:

      name:             Inherited from ManagedBase. The name of the
                        BudgetDefinition. Required in this context.
      unitRef:          References the Unit or the Money for the
                        BudgetDefinition.
      expressionRef:    References the BudgetExpression used for the roll-up
                        calculations.

      Sub-elements:

      AssociatedDataSet: Inherited from ManagedBase. References the template
                        spreadsheet.
      
\endverbatim
*/
class PLMXML60_API BudgetDefinition : public Managed
{
public:
     
    //! Default constructor
    BudgetDefinition( );
     
    //! Constructs a BudgetDefinition with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    BudgetDefinition( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~BudgetDefinition();

private:

	//! Assignment operator
	BudgetDefinition& operator=( const BudgetDefinition& iSrc );

	//! Copy constructor
	BudgetDefinition( const BudgetDefinition& original );
     
public:

	//! Get Expression URI as plmxml_api::String
	plmxml_api::String GetExpressionURI() const;

	//! Set Expression URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetExpressionURI( const plmxml_api::String& );
	
	//! Get the handle of Expression URI. Does not resolve the URI.
	plmxml_api::Result GetExpressionURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Expression URI. URI string is unchanged.
	plmxml_api::Result SetExpressionURI( const plmxml_api::Handle& );
	
	//! Resolve Expression URI and return an object (handle) it points to.
	plmxml_api::Result ResolveExpressionURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Expression URI. Clears URI string and handle.
	plmxml_api::Result DeleteExpressionURI();
	
	//! Check if Expression URI is set
	plmxml_api::logical HasExpressionURI( ) const;
	

	//! Get Unit URI as plmxml_api::String
	plmxml_api::String GetUnitURI() const;

	//! Set Unit URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetUnitURI( const plmxml_api::String& );
	
	//! Get the handle of Unit URI. Does not resolve the URI.
	plmxml_api::Result GetUnitURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Unit URI. URI string is unchanged.
	plmxml_api::Result SetUnitURI( const plmxml_api::Handle& );
	
	//! Resolve Unit URI and return an object (handle) it points to.
	plmxml_api::Result ResolveUnitURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Unit URI. Clears URI string and handle.
	plmxml_api::Result DeleteUnitURI();
	
	//! Check if Unit URI is set
	plmxml_api::logical HasUnitURI( ) const;
	
 
// <PLMXML_UserCode type="functionHeaderBudgetDefinition" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassBudgetDefinition;


////////////////////////////////////////////////////////////////////////////////////
//! Budget class
/*!
\verbatim

      Represents the actual allocation or distribution of values to a part or
      assembly for a BudgetDefinition.

      Attributes:

      estimatedValue:   The estimated value for the Budget.
      actualValue:      The actual value for the Budget.
      calculatedValue:  The calculated value for the Budget.
      expressionRef:    References the BudgetExpression used for the roll-up
                        calculations.
      definitionRef:    References the BudgetDefinition for the Budget.
      
\endverbatim
*/
class PLMXML60_API Budget : public Managed
{
public:
     
    //! Default constructor
    Budget( );
     
    //! Constructs a Budget with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Budget( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Budget();

private:

	//! Assignment operator
	Budget& operator=( const Budget& iSrc );

	//! Copy constructor
	Budget( const Budget& original );
     
public:

	//! Get Expression URI as plmxml_api::String
	plmxml_api::String GetExpressionURI() const;

	//! Set Expression URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetExpressionURI( const plmxml_api::String& );
	
	//! Get the handle of Expression URI. Does not resolve the URI.
	plmxml_api::Result GetExpressionURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Expression URI. URI string is unchanged.
	plmxml_api::Result SetExpressionURI( const plmxml_api::Handle& );
	
	//! Resolve Expression URI and return an object (handle) it points to.
	plmxml_api::Result ResolveExpressionURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Expression URI. Clears URI string and handle.
	plmxml_api::Result DeleteExpressionURI();
	
	//! Check if Expression URI is set
	plmxml_api::logical HasExpressionURI( ) const;
	

	//! Set ActualValue
	plmxml_api::Result SetActualValue( double arg );

     //! Get ActualValue
	double GetActualValue() const;

	//! Check if ActualValue is set
	plmxml_api::logical HasActualValue() const;

	//! Unset ActualValue
	plmxml_api::Result UnsetActualValue();

	//! Set CalculatedValue
	plmxml_api::Result SetCalculatedValue( double arg );

     //! Get CalculatedValue
	double GetCalculatedValue() const;

	//! Check if CalculatedValue is set
	plmxml_api::logical HasCalculatedValue() const;

	//! Unset CalculatedValue
	plmxml_api::Result UnsetCalculatedValue();

	//! Get Definition URI as plmxml_api::String
	plmxml_api::String GetDefinitionURI() const;

	//! Set Definition URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetDefinitionURI( const plmxml_api::String& );
	
	//! Get the handle of Definition URI. Does not resolve the URI.
	plmxml_api::Result GetDefinitionURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Definition URI. URI string is unchanged.
	plmxml_api::Result SetDefinitionURI( const plmxml_api::Handle& );
	
	//! Resolve Definition URI and return an object (handle) it points to.
	plmxml_api::Result ResolveDefinitionURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Definition URI. Clears URI string and handle.
	plmxml_api::Result DeleteDefinitionURI();
	
	//! Check if Definition URI is set
	plmxml_api::logical HasDefinitionURI( ) const;
	

	//! Set EstimatedValue
	plmxml_api::Result SetEstimatedValue( double arg );

     //! Get EstimatedValue
	double GetEstimatedValue() const;

	//! Check if EstimatedValue is set
	plmxml_api::logical HasEstimatedValue() const;

	//! Unset EstimatedValue
	plmxml_api::Result UnsetEstimatedValue();
 
// <PLMXML_UserCode type="functionHeaderBudget" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassBudget;


////////////////////////////////////////////////////////////////////////////////////
//! LineWidth class
/*!
\verbatim

      A definition of a line width.

      Attributes:

      name:             Inherited from AttribOwner.
      meters:           The line width in meters.
      pixels:           The line width in pixels.
      
\endverbatim
*/
class PLMXML60_API LineWidth : public AttribOwner
{
public:
     
    //! Default constructor
    LineWidth( );
     
    //! Constructs a LineWidth with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    LineWidth( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~LineWidth();

private:

	//! Assignment operator
	LineWidth& operator=( const LineWidth& iSrc );

	//! Copy constructor
	LineWidth( const LineWidth& original );
     
public:

	//! Set Pixels
	plmxml_api::Result SetPixels( double arg );

     //! Get Pixels
	double GetPixels() const;

	//! Check if Pixels is set
	plmxml_api::logical HasPixels() const;

	//! Unset Pixels
	plmxml_api::Result UnsetPixels();

	//! Set Meters
	plmxml_api::Result SetMeters( double arg );

     //! Get Meters
	double GetMeters() const;

	//! Check if Meters is set
	plmxml_api::logical HasMeters() const;

	//! Unset Meters
	plmxml_api::Result UnsetMeters();
 
// <PLMXML_UserCode type="functionHeaderLineWidth" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassLineWidth;


////////////////////////////////////////////////////////////////////////////////////
//! LineWidthList class
/*!
\verbatim

      An ordered list of line widths. The first width is the thinnest.

      Sub-elements:

      LineWidth:        The line width definitions.
      
\endverbatim
*/
class PLMXML60_API LineWidthList : public AttribOwner
{
public:
     
    //! Default constructor
    LineWidthList( );
     
    //! Constructs a LineWidthList with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    LineWidthList( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~LineWidthList();

private:

	//! Assignment operator
	LineWidthList& operator=( const LineWidthList& iSrc );

	//! Copy constructor
	LineWidthList( const LineWidthList& original );
     
public:

	//! Add LineWidth child element to this LineWidthList. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	LineWidth *AddLineWidth();
     
	//! Add 'arg' as LineWidth child element to this LineWidthList.
	plmxml_api::Result AddLineWidth( LineWidth *arg );

	//! Detach and delete all LineWidth child elements.
	void DeleteLineWidths();
     
	//! Get number of LineWidth child elements.
	int NumberOfLineWidths() const;
     
	//! Get i'th LineWidth child element.
	LineWidth *GetLineWidth( int i ) const;
     
	//! Get all LineWidth child element as an array
	void GetLineWidths( plmxml_api::Array<LineWidth*> &array ) const;
	     
	//! Detach and delete i'th LineWidth child element
	void DeleteLineWidth( int i );
     
	//! Detach and delete 'arg' if it's one of the LineWidth child elements
	void DeleteLineWidth( LineWidth *arg );
 
// <PLMXML_UserCode type="functionHeaderLineWidthList" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassLineWidthList;


////////////////////////////////////////////////////////////////////////////////////
//! DefaultSortOrder class
/*!
\verbatim

      The default sort order for lists of Elements.

      Attributes:

      sortOrder:      The default sort order.
      ascending:      Whether the order is ascending or descending. The default
                      is ascending.
      
\endverbatim
*/
class PLMXML60_API DefaultSortOrder : public Property
{
public:
     
    //! Default constructor
    DefaultSortOrder( );
     
    //! Constructs a DefaultSortOrder with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    DefaultSortOrder( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~DefaultSortOrder();

private:

	//! Assignment operator
	DefaultSortOrder& operator=( const DefaultSortOrder& iSrc );

	//! Copy constructor
	DefaultSortOrder( const DefaultSortOrder& original );
     
public:

	//! Set SortOrder
	plmxml_api::Result SetSortOrder( const eSortOrderEnum& arg );

	//! Get SortOrder
	eSortOrderEnum GetSortOrder() const;

	//! Set Ascending
	plmxml_api::Result SetAscending( plmxml_api::logical arg );

	//! Get Ascending
	plmxml_api::logical GetAscending() const;

	//! Check if Ascending is set
	plmxml_api::logical HasAscending() const;

	//! Unset Ascending
	plmxml_api::Result UnsetAscending();
 
// <PLMXML_UserCode type="functionHeaderDefaultSortOrder" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassDefaultSortOrder;


////////////////////////////////////////////////////////////////////////////////////
//! PointCloud class
/*!
\verbatim

      A set of points.

      Attributes:

      cloudRefs:        References other point clouds contained in this point
                        cloud.

      Sub-elements:

      P:                The co-ordinates of the point.
      
\endverbatim
*/
class PLMXML60_API PointCloud : public InternalRep
{
public:
     
    //! Default constructor
    PointCloud( );
     
    //! Constructs a PointCloud with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    PointCloud( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~PointCloud();

private:

	//! Assignment operator
	PointCloud& operator=( const PointCloud& iSrc );

	//! Copy constructor
	PointCloud( const PointCloud& original );
     
public:

	//! Get number of URIs in Cloud
	int NumberOfCloudURIs() const;

	//! Get i'th URI in Cloud
	plmxml_api::String GetCloudURI( int i ) const;

	//! Add a URI to Cloud array. Call ResolveCloudURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddCloudURI( const plmxml_api::String& u );

	//! Set i'th URI in Cloud array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetCloudURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Cloud URI. Does not resolve the URI.
	plmxml_api::Result GetCloudURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Cloud array.
	plmxml_api::Result AddCloudURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Cloud array to point to 'handle'.
	plmxml_api::Result SetCloudURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Cloud points to.
	plmxml_api::Result ResolveCloudURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Cloud array.
	plmxml_api::Result DeleteCloudURI( int i );

	//! Remove all URIs from Cloud array.
	plmxml_api::Result DeleteCloudURIs( );
	
	//! Check if Cloud is set
	plmxml_api::logical HasCloudURIs( ) const;

	//! Add P child element to this PointCloud. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	VectorField *AddP();
     
	//! Add 'arg' as P child element to this PointCloud.
	plmxml_api::Result AddP( VectorField *arg );

	//! Detach and delete all P child elements.
	void DeletePs();
     
	//! Get number of P child elements.
	int NumberOfPs() const;
     
	//! Get i'th P child element.
	VectorField *GetP( int i ) const;
     
	//! Get all P child element as an array
	void GetPs( plmxml_api::Array<VectorField*> &array ) const;
	     
	//! Detach and delete i'th P child element
	void DeleteP( int i );
     
	//! Detach and delete 'arg' if it's one of the P child elements
	void DeleteP( VectorField *arg );
 
// <PLMXML_UserCode type="functionHeaderPointCloud" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassPointCloud;


////////////////////////////////////////////////////////////////////////////////////
//! MaterialThickness class
/*!
\verbatim

      Specifies the thickness of the material used to manufacture sheet parts.

      Sub-elements:

      ValueWithUnit:    The thickness of the material. If this sub-element is
                        present, RangeWithUnit should not be present.
      RangeWithUnit:    The range of thicknesses of the material. If this
                        sub-element is present, ValueWithUnit should not be
                        present.
      
\endverbatim
*/
class PLMXML60_API MaterialThickness : public Property
{
public:
     
    //! Default constructor
    MaterialThickness( );
     
    //! Constructs a MaterialThickness with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    MaterialThickness( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~MaterialThickness();

private:

	//! Assignment operator
	MaterialThickness& operator=( const MaterialThickness& iSrc );

	//! Copy constructor
	MaterialThickness( const MaterialThickness& original );
     
public:

	//! Add ValueWithUnit child element to this MaterialThickness. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	ValueWithUnit *AddValueWithUnit();
     
	//! Set ValueWithUnit child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetValueWithUnit( ValueWithUnit *arg );
     
	//! Get ValueWithUnit child element of this MaterialThickness.
	ValueWithUnit *GetValueWithUnit() const;
     
	//! Detach and delete ValueWithUnit child element tree from this MaterialThickness.
	void DeleteValueWithUnit();

	//! Add RangeWithUnit child element to this MaterialThickness. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	RangeWithUnit *AddRangeWithUnit();
     
	//! Set RangeWithUnit child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetRangeWithUnit( RangeWithUnit *arg );
     
	//! Get RangeWithUnit child element of this MaterialThickness.
	RangeWithUnit *GetRangeWithUnit() const;
     
	//! Detach and delete RangeWithUnit child element tree from this MaterialThickness.
	void DeleteRangeWithUnit();
 
// <PLMXML_UserCode type="functionHeaderMaterialThickness" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassMaterialThickness;


////////////////////////////////////////////////////////////////////////////////////
//! GeneralAttribute class
/*!
\verbatim

      Can indicate the usage for elements representing data associated with real
      objects. For elements representing real objects themselves, Property's
      should be used instead.

      Attributes:

      name:             Inherited from Attribute. The title of the
                        GeneralAttribute.
      type:             The type of the GeneralAttribute.
      value:            The value of the GeneralAttribute if it is a scalar
                        value.
      dimensionality:   The physical quantity that the GeneralAttribute
                        represents.
      unitRef:          References a Unit.
      category:         The category of the GeneralAttribute.
      editable:         Whether the receiving application may modify the
                        GeneralAttribute.

      Sub-elements:

      ValueList:        The value of the GeneralAttribute if it is a vector
                        value.
      
\endverbatim
*/
class PLMXML60_API GeneralAttribute : public Attribute
{
public:
     
    //! Default constructor
    GeneralAttribute( );
     
    //! Constructs a GeneralAttribute with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    GeneralAttribute( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~GeneralAttribute();

private:

	//! Assignment operator
	GeneralAttribute& operator=( const GeneralAttribute& iSrc );

	//! Copy constructor
	GeneralAttribute( const GeneralAttribute& original );
     
public:

	//! Get Category of this GeneralAttribute
	plmxml_api::String GetCategory() const;

	//! Set Category of this GeneralAttribute
	plmxml_api::Result SetCategory( const plmxml_api::String &s );
	
	//! Check if Category is set
	plmxml_api::logical HasCategory( ) const;
	
	//! Unset Category
	plmxml_api::Result UnsetCategory( );

	//! Set Dimensionality
	plmxml_api::Result SetDimensionality( const eMeasureEnum& arg );

	//! Get Dimensionality
	eMeasureEnum GetDimensionality() const;

	//! Get Unit URI as plmxml_api::String
	plmxml_api::String GetUnitURI() const;

	//! Set Unit URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetUnitURI( const plmxml_api::String& );
	
	//! Get the handle of Unit URI. Does not resolve the URI.
	plmxml_api::Result GetUnitURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Unit URI. URI string is unchanged.
	plmxml_api::Result SetUnitURI( const plmxml_api::Handle& );
	
	//! Resolve Unit URI and return an object (handle) it points to.
	plmxml_api::Result ResolveUnitURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Unit URI. Clears URI string and handle.
	plmxml_api::Result DeleteUnitURI();
	
	//! Check if Unit URI is set
	plmxml_api::logical HasUnitURI( ) const;
	

	//! Get Value of this GeneralAttribute
	plmxml_api::String GetValue() const;

	//! Set Value of this GeneralAttribute
	plmxml_api::Result SetValue( const plmxml_api::String &s );
	
	//! Check if Value is set
	plmxml_api::logical HasValue( ) const;
	
	//! Unset Value
	plmxml_api::Result UnsetValue( );

	//! Set Type
	plmxml_api::Result SetType( const eUserValueDataType& arg );

	//! Get Type
	eUserValueDataType GetType() const;

	//! Set Editable
	plmxml_api::Result SetEditable( plmxml_api::logical arg );

	//! Get Editable
	plmxml_api::logical GetEditable() const;

	//! Check if Editable is set
	plmxml_api::logical HasEditable() const;

	//! Unset Editable
	plmxml_api::Result UnsetEditable();

	//! Add ValueList child element to this GeneralAttribute. A pointer to added element is returned. 
	/*!
		Returns NULL if such element already exists.
	*/
	UserList *AddValueList();
     
	//! Set ValueList child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetValueList( UserList *arg );
     
	//! Get ValueList child element of this GeneralAttribute.
	UserList *GetValueList() const;
     
	//! Detach and delete ValueList child element tree from this GeneralAttribute.
	void DeleteValueList();
 
// <PLMXML_UserCode type="functionHeaderGeneralAttribute" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassGeneralAttribute;


////////////////////////////////////////////////////////////////////////////////////
//! TableRow class
/*!
\verbatim

      Represents custom data assigned to some object when the data is owned by
      the object and cannot be shared. A TableRow represents a single row of
      data in an ordered table according to some schema.

      Attributes:

      subType:          The sub-type of the table property.
      tablePropertyName: The name of the table property.
      index:            The number of the row in the ordered table.

      Sub-elements:

      TableColumn:      The individual values in the columns of the table row.
      
\endverbatim
*/
class PLMXML60_API TableRow : public Attribute
{
public:
     
    //! Default constructor
    TableRow( );
     
    //! Constructs a TableRow with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    TableRow( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~TableRow();

private:

	//! Assignment operator
	TableRow& operator=( const TableRow& iSrc );

	//! Copy constructor
	TableRow( const TableRow& original );
     
public:

	//! Set Index
	plmxml_api::Result SetIndex( int arg );
     
	//! Get Index
	int GetIndex() const;
     
	//! Check if Index is set
	plmxml_api::logical HasIndex() const;
     
	//! Unset Index
	plmxml_api::Result UnsetIndex();

	//! Get TablePropertyName of this TableRow
	plmxml_api::String GetTablePropertyName() const;

	//! Set TablePropertyName of this TableRow
	plmxml_api::Result SetTablePropertyName( const plmxml_api::String &s );
	
	//! Check if TablePropertyName is set
	plmxml_api::logical HasTablePropertyName( ) const;
	
	//! Unset TablePropertyName
	plmxml_api::Result UnsetTablePropertyName( );

	//! Get SubType of this TableRow
	plmxml_api::String GetSubType() const;

	//! Set SubType of this TableRow
	plmxml_api::Result SetSubType( const plmxml_api::String &s );
	
	//! Check if SubType is set
	plmxml_api::logical HasSubType( ) const;
	
	//! Unset SubType
	plmxml_api::Result UnsetSubType( );

	//! Add TableColumn child element to this TableRow. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	UserValue *AddTableColumn();
     
	//! Add 'arg' as TableColumn child element to this TableRow.
	plmxml_api::Result AddTableColumn( UserValue *arg );

	//! Detach and delete all TableColumn child elements.
	void DeleteTableColumns();
     
	//! Get number of TableColumn child elements.
	int NumberOfTableColumns() const;
     
	//! Get i'th TableColumn child element.
	UserValue *GetTableColumn( int i ) const;
     
	//! Get all TableColumn child element as an array
	void GetTableColumns( plmxml_api::Array<UserValue*> &array ) const;
	     
	//! Detach and delete i'th TableColumn child element
	void DeleteTableColumn( int i );
     
	//! Detach and delete 'arg' if it's one of the TableColumn child elements
	void DeleteTableColumn( UserValue *arg );
 
// <PLMXML_UserCode type="functionHeaderTableRow" >
	//! Set TableColumn child element to 'arg'. 'arg' will be managed by the PLMXML toolkit.
	plmxml_api::Result SetTableColumn( UserValue *arg );

	//! Get TableColumn child element of this TableRow.
	UserValue *GetTableColumn( ) const;

	//! Detach and delete TableColumn child element tree from this TableRow.
	void DeleteTableColumn( );
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassTableRow;


////////////////////////////////////////////////////////////////////////////////////
//! CollaborativeDesign class
/*!
\verbatim

      A 4GD Collaborative Design.

      Attributes:

      modelId:          The identifier of the Collaborative Design.
      
\endverbatim
*/
class PLMXML60_API CollaborativeDesign : public Structure
{
public:
     
    //! Default constructor
    CollaborativeDesign( );
     
    //! Constructs a CollaborativeDesign with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    CollaborativeDesign( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~CollaborativeDesign();

private:

	//! Assignment operator
	CollaborativeDesign& operator=( const CollaborativeDesign& iSrc );

	//! Copy constructor
	CollaborativeDesign( const CollaborativeDesign& original );
     
public:

	//! Get ModelId of this CollaborativeDesign
	plmxml_api::String GetModelId() const;

	//! Set ModelId of this CollaborativeDesign
	plmxml_api::Result SetModelId( const plmxml_api::String &s );
	
	//! Check if ModelId is set
	plmxml_api::logical HasModelId( ) const;
	
	//! Unset ModelId
	plmxml_api::Result UnsetModelId( );
 
// <PLMXML_UserCode type="functionHeaderCollaborativeDesign" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassCollaborativeDesign;


////////////////////////////////////////////////////////////////////////////////////
//! CollaborativeDesignStructureView class
/*!
\verbatim

      A view of a 4GD Collaborative Design.
      
\endverbatim
*/
class PLMXML60_API CollaborativeDesignStructureView : public StructureView
{
public:
     
    //! Default constructor
    CollaborativeDesignStructureView( );
     
    //! Constructs a CollaborativeDesignStructureView with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    CollaborativeDesignStructureView( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~CollaborativeDesignStructureView();

private:

	//! Assignment operator
	CollaborativeDesignStructureView& operator=( const CollaborativeDesignStructureView& iSrc );

	//! Copy constructor
	CollaborativeDesignStructureView( const CollaborativeDesignStructureView& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderCollaborativeDesignStructureView" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassCollaborativeDesignStructureView;


////////////////////////////////////////////////////////////////////////////////////
//! CollaborativeDesignRevision class
/*!
\verbatim

      A revision of a 4GD Collaborative Design.
      
\endverbatim
*/
class PLMXML60_API CollaborativeDesignRevision : public StructureRevision
{
public:
     
    //! Default constructor
    CollaborativeDesignRevision( );
     
    //! Constructs a CollaborativeDesignRevision with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    CollaborativeDesignRevision( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~CollaborativeDesignRevision();

private:

	//! Assignment operator
	CollaborativeDesignRevision& operator=( const CollaborativeDesignRevision& iSrc );

	//! Copy constructor
	CollaborativeDesignRevision( const CollaborativeDesignRevision& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderCollaborativeDesignRevision" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassCollaborativeDesignRevision;


//! Forward class declarations
class ModelElement;

////////////////////////////////////////////////////////////////////////////////////
//! CollaborativeDesignRevisionView class
/*!
\verbatim

      A view of a revision of a 4GD Collaborative Design.

      Attributes:

      partitionRefs:    References nested 4GD Partitions.

      Sub-elements:

      ModelElement:     4GD Model Elements.
      
\endverbatim
*/
class PLMXML60_API CollaborativeDesignRevisionView : public StructureRevisionView
{
public:
     
    //! Default constructor
    CollaborativeDesignRevisionView( );
     
    //! Constructs a CollaborativeDesignRevisionView with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    CollaborativeDesignRevisionView( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~CollaborativeDesignRevisionView();

private:

	//! Assignment operator
	CollaborativeDesignRevisionView& operator=( const CollaborativeDesignRevisionView& iSrc );

	//! Copy constructor
	CollaborativeDesignRevisionView( const CollaborativeDesignRevisionView& original );
     
public:

	//! Get number of URIs in Partition
	int NumberOfPartitionURIs() const;

	//! Get i'th URI in Partition
	plmxml_api::String GetPartitionURI( int i ) const;

	//! Add a URI to Partition array. Call ResolvePartitionURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddPartitionURI( const plmxml_api::String& u );

	//! Set i'th URI in Partition array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetPartitionURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Partition URI. Does not resolve the URI.
	plmxml_api::Result GetPartitionURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Partition array.
	plmxml_api::Result AddPartitionURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Partition array to point to 'handle'.
	plmxml_api::Result SetPartitionURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Partition points to.
	plmxml_api::Result ResolvePartitionURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Partition array.
	plmxml_api::Result DeletePartitionURI( int i );

	//! Remove all URIs from Partition array.
	plmxml_api::Result DeletePartitionURIs( );
	
	//! Check if Partition is set
	plmxml_api::logical HasPartitionURIs( ) const;

	//! Add ModelElement child element to this CollaborativeDesignRevisionView. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	ModelElement *AddModelElement();
     
	//! Add 'arg' as ModelElement child element to this CollaborativeDesignRevisionView.
	plmxml_api::Result AddModelElement( ModelElement *arg );

	//! Detach and delete all ModelElement child elements.
	void DeleteModelElements();
     
	//! Get number of ModelElement child elements.
	int NumberOfModelElements() const;
     
	//! Get i'th ModelElement child element.
	ModelElement *GetModelElement( int i ) const;
     
	//! Get all ModelElement child element as an array
	void GetModelElements( plmxml_api::Array<ModelElement*> &array ) const;
	     
	//! Detach and delete i'th ModelElement child element
	void DeleteModelElement( int i );
     
	//! Detach and delete 'arg' if it's one of the ModelElement child elements
	void DeleteModelElement( ModelElement *arg );
 
// <PLMXML_UserCode type="functionHeaderCollaborativeDesignRevisionView" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassCollaborativeDesignRevisionView;


////////////////////////////////////////////////////////////////////////////////////
//! ModelElement class
/*!
\verbatim

      A 4GD Model Element.

      Attributes:

      revision:         The revision of the Model Element, which may be
                        different to the revision of the traditional Product.
      elementThread:    The identifier of the element thread of the Model
                        Element.
      
\endverbatim
*/
class PLMXML60_API ModelElement : public Instance
{
public:
     
    //! Default constructor
    ModelElement( );
     
    //! Constructs a ModelElement with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ModelElement( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ModelElement();

private:

	//! Assignment operator
	ModelElement& operator=( const ModelElement& iSrc );

	//! Copy constructor
	ModelElement( const ModelElement& original );
     
public:

	//! Get Revision of this ModelElement
	plmxml_api::String GetRevision() const;

	//! Set Revision of this ModelElement
	plmxml_api::Result SetRevision( const plmxml_api::String &s );
	
	//! Check if Revision is set
	plmxml_api::logical HasRevision( ) const;
	
	//! Unset Revision
	plmxml_api::Result UnsetRevision( );

	//! Get ElementThread of this ModelElement
	plmxml_api::String GetElementThread() const;

	//! Set ElementThread of this ModelElement
	plmxml_api::Result SetElementThread( const plmxml_api::String &s );
	
	//! Check if ElementThread is set
	plmxml_api::logical HasElementThread( ) const;
	
	//! Unset ElementThread
	plmxml_api::Result UnsetElementThread( );
 
// <PLMXML_UserCode type="functionHeaderModelElement" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassModelElement;


////////////////////////////////////////////////////////////////////////////////////
//! DesignElement class
/*!
\verbatim

      A 4GD Design Element.

      Attributes:

      category:         Whether shape, reuse, subordinate or promissory.
      designElementId:  The identifier of the Design Element.
      parentRef:        References the Design Element corresponding to the
                        traditional product structure parent.
      
\endverbatim
*/
class PLMXML60_API DesignElement : public ModelElement
{
public:
     
    //! Default constructor
    DesignElement( );
     
    //! Constructs a DesignElement with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    DesignElement( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~DesignElement();

private:

	//! Assignment operator
	DesignElement& operator=( const DesignElement& iSrc );

	//! Copy constructor
	DesignElement( const DesignElement& original );
     
public:

	//! Set Category
	plmxml_api::Result SetCategory( const eDesignElementEnum& arg );

	//! Get Category
	eDesignElementEnum GetCategory() const;

	//! Get DesignElementId of this DesignElement
	plmxml_api::String GetDesignElementId() const;

	//! Set DesignElementId of this DesignElement
	plmxml_api::Result SetDesignElementId( const plmxml_api::String &s );
	
	//! Check if DesignElementId is set
	plmxml_api::logical HasDesignElementId( ) const;
	
	//! Unset DesignElementId
	plmxml_api::Result UnsetDesignElementId( );

	//! Get Parent URI as plmxml_api::String
	plmxml_api::String GetParentURI() const;

	//! Set Parent URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetParentURI( const plmxml_api::String& );
	
	//! Get the handle of Parent URI. Does not resolve the URI.
	plmxml_api::Result GetParentURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Parent URI. URI string is unchanged.
	plmxml_api::Result SetParentURI( const plmxml_api::Handle& );
	
	//! Resolve Parent URI and return an object (handle) it points to.
	plmxml_api::Result ResolveParentURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Parent URI. Clears URI string and handle.
	plmxml_api::Result DeleteParentURI();
	
	//! Check if Parent URI is set
	plmxml_api::logical HasParentURI( ) const;
	
 
// <PLMXML_UserCode type="functionHeaderDesignElement" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassDesignElement;


////////////////////////////////////////////////////////////////////////////////////
//! DesignFeature class
/*!
\verbatim

      A 4GD Design Feature.

      Attributes:

      designFeatureId:  The identifier of the Design Feature.
      
\endverbatim
*/
class PLMXML60_API DesignFeature : public ModelElement
{
public:
     
    //! Default constructor
    DesignFeature( );
     
    //! Constructs a DesignFeature with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    DesignFeature( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~DesignFeature();

private:

	//! Assignment operator
	DesignFeature& operator=( const DesignFeature& iSrc );

	//! Copy constructor
	DesignFeature( const DesignFeature& original );
     
public:

	//! Get DesignFeatureId of this DesignFeature
	plmxml_api::String GetDesignFeatureId() const;

	//! Set DesignFeatureId of this DesignFeature
	plmxml_api::Result SetDesignFeatureId( const plmxml_api::String &s );
	
	//! Check if DesignFeatureId is set
	plmxml_api::logical HasDesignFeatureId( ) const;
	
	//! Unset DesignFeatureId
	plmxml_api::Result UnsetDesignFeatureId( );
 
// <PLMXML_UserCode type="functionHeaderDesignFeature" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassDesignFeature;


////////////////////////////////////////////////////////////////////////////////////
//! ContinuousJoinDesignFeature class
/*!
\verbatim

      A 4GD continuous join Design Feature.
      
\endverbatim
*/
class PLMXML60_API ContinuousJoinDesignFeature : public DesignFeature
{
public:
     
    //! Default constructor
    ContinuousJoinDesignFeature( );
     
    //! Constructs a ContinuousJoinDesignFeature with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ContinuousJoinDesignFeature( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ContinuousJoinDesignFeature();

private:

	//! Assignment operator
	ContinuousJoinDesignFeature& operator=( const ContinuousJoinDesignFeature& iSrc );

	//! Copy constructor
	ContinuousJoinDesignFeature( const ContinuousJoinDesignFeature& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderContinuousJoinDesignFeature" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassContinuousJoinDesignFeature;


////////////////////////////////////////////////////////////////////////////////////
//! ArcWeldDesignFeature class
/*!
\verbatim

      A 4GD arc weld Design Feature.

      Attributes:

      weldProcess:      The weld process such as SMAW.
      contour:          The type of contour.
      hasFillet:        Whether the arc weld has a fillet.
      grooveType:       The type of groove.
      jointType:        The type of joint.
      continuous:       Whether the arc weld is continuous.
      beadRadius:       The radius of a cylindrical weld bead in metres.
      length:           The total length of a continuous weld. The length of a
                        segment of a non-continuous weld. Distances in metres.
      pitch:            The repeat distance of segments of a non-continuous weld
                        in metres.
      staggered:        Whether the segments of a non-continuous weld are
                        staggered between the arrow side and the other side.
      tangentialPropagation: Whether the weld propagates along G1-continuous
                        edges.
      
\endverbatim
*/
class PLMXML60_API ArcWeldDesignFeature : public ContinuousJoinDesignFeature
{
public:
     
    //! Default constructor
    ArcWeldDesignFeature( );
     
    //! Constructs a ArcWeldDesignFeature with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ArcWeldDesignFeature( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ArcWeldDesignFeature();

private:

	//! Assignment operator
	ArcWeldDesignFeature& operator=( const ArcWeldDesignFeature& iSrc );

	//! Copy constructor
	ArcWeldDesignFeature( const ArcWeldDesignFeature& original );
     
public:

	//! Set Continuous
	plmxml_api::Result SetContinuous( plmxml_api::logical arg );

	//! Get Continuous
	plmxml_api::logical GetContinuous() const;

	//! Check if Continuous is set
	plmxml_api::logical HasContinuous() const;

	//! Unset Continuous
	plmxml_api::Result UnsetContinuous();

	//! Get WeldProcess of this ArcWeldDesignFeature
	plmxml_api::String GetWeldProcess() const;

	//! Set WeldProcess of this ArcWeldDesignFeature
	plmxml_api::Result SetWeldProcess( const plmxml_api::String &s );
	
	//! Check if WeldProcess is set
	plmxml_api::logical HasWeldProcess( ) const;
	
	//! Unset WeldProcess
	plmxml_api::Result UnsetWeldProcess( );

	//! Set BeadRadius
	plmxml_api::Result SetBeadRadius( double arg );

     //! Get BeadRadius
	double GetBeadRadius() const;

	//! Check if BeadRadius is set
	plmxml_api::logical HasBeadRadius() const;

	//! Unset BeadRadius
	plmxml_api::Result UnsetBeadRadius();

	//! Set TangentialPropagation
	plmxml_api::Result SetTangentialPropagation( plmxml_api::logical arg );

	//! Get TangentialPropagation
	plmxml_api::logical GetTangentialPropagation() const;

	//! Check if TangentialPropagation is set
	plmxml_api::logical HasTangentialPropagation() const;

	//! Unset TangentialPropagation
	plmxml_api::Result UnsetTangentialPropagation();

	//! Set GrooveType
	plmxml_api::Result SetGrooveType( const eGrooveEnum& arg );

	//! Get GrooveType
	eGrooveEnum GetGrooveType() const;

	//! Set Length
	plmxml_api::Result SetLength( double arg );

     //! Get Length
	double GetLength() const;

	//! Check if Length is set
	plmxml_api::logical HasLength() const;

	//! Unset Length
	plmxml_api::Result UnsetLength();

	//! Set Pitch
	plmxml_api::Result SetPitch( double arg );

     //! Get Pitch
	double GetPitch() const;

	//! Check if Pitch is set
	plmxml_api::logical HasPitch() const;

	//! Unset Pitch
	plmxml_api::Result UnsetPitch();

	//! Set HasFillet
	plmxml_api::Result SetHasFillet( plmxml_api::logical arg );

	//! Get HasFillet
	plmxml_api::logical GetHasFillet() const;

	//! Check if HasFillet is set
	plmxml_api::logical HasHasFillet() const;

	//! Unset HasFillet
	plmxml_api::Result UnsetHasFillet();

	//! Set JointType
	plmxml_api::Result SetJointType( const eArcWeldJointEnum& arg );

	//! Get JointType
	eArcWeldJointEnum GetJointType() const;

	//! Set Staggered
	plmxml_api::Result SetStaggered( plmxml_api::logical arg );

	//! Get Staggered
	plmxml_api::logical GetStaggered() const;

	//! Check if Staggered is set
	plmxml_api::logical HasStaggered() const;

	//! Unset Staggered
	plmxml_api::Result UnsetStaggered();

	//! Set Contour
	plmxml_api::Result SetContour( const eContourEnum& arg );

	//! Get Contour
	eContourEnum GetContour() const;
 
// <PLMXML_UserCode type="functionHeaderArcWeldDesignFeature" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassArcWeldDesignFeature;


////////////////////////////////////////////////////////////////////////////////////
//! DatumDesignFeature class
/*!
\verbatim

      A 4GD datum Design Feature.

      Attributes:

      controlDirections: Whether the datum controls movement in the X, Y and Z
                        directions of the collaborative design.
      derived:          Whether this datum is derived from another.
      sectionRef:       References a Section that the datum lies on.
      
\endverbatim
*/
class PLMXML60_API DatumDesignFeature : public DesignFeature
{
public:
     
    //! Default constructor
    DatumDesignFeature( );
     
    //! Constructs a DatumDesignFeature with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    DatumDesignFeature( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~DatumDesignFeature();

private:

	//! Assignment operator
	DatumDesignFeature& operator=( const DatumDesignFeature& iSrc );

	//! Copy constructor
	DatumDesignFeature( const DatumDesignFeature& original );
     
public:

	//! Set Derived
	plmxml_api::Result SetDerived( plmxml_api::logical arg );

	//! Get Derived
	plmxml_api::logical GetDerived() const;

	//! Check if Derived is set
	plmxml_api::logical HasDerived() const;

	//! Unset Derived
	plmxml_api::Result UnsetDerived();

	//! Set ControlDirections array
	plmxml_api::Result SetControlDirections( const plmxml_api::logical *arg );

	//! Get ControlDirections array
	plmxml_api::Result GetControlDirections( plmxml_api::logical *arg ) const;

	//! Check if ControlDirections array is set
	plmxml_api::logical HasControlDirections() const;

	//! Unset ControlDirections array
	plmxml_api::Result UnsetControlDirections();

	//! Get Section URI as plmxml_api::String
	plmxml_api::String GetSectionURI() const;

	//! Set Section URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetSectionURI( const plmxml_api::String& );
	
	//! Get the handle of Section URI. Does not resolve the URI.
	plmxml_api::Result GetSectionURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Section URI. URI string is unchanged.
	plmxml_api::Result SetSectionURI( const plmxml_api::Handle& );
	
	//! Resolve Section URI and return an object (handle) it points to.
	plmxml_api::Result ResolveSectionURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Section URI. Clears URI string and handle.
	plmxml_api::Result DeleteSectionURI();
	
	//! Check if Section URI is set
	plmxml_api::logical HasSectionURI( ) const;
	
 
// <PLMXML_UserCode type="functionHeaderDatumDesignFeature" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassDatumDesignFeature;


////////////////////////////////////////////////////////////////////////////////////
//! DiscreteJoinDesignFeature class
/*!
\verbatim

      A 4GD discrete join Design Feature.

      Attributes:

      groupId:          An identifier for a group of discrete join Design
                        Features.
      numberOfSheetsJoined: The number of sheets of material joined together.
      numberOfJoinsInGroup: The number of joins in the group.
      associative:      Whether the discrete join Design Feature updates when
                        the joined geometry changes.
      checked:          Whether the discrete join Design Feature has been
                        checked.
      
\endverbatim
*/
class PLMXML60_API DiscreteJoinDesignFeature : public DesignFeature
{
public:
     
    //! Default constructor
    DiscreteJoinDesignFeature( );
     
    //! Constructs a DiscreteJoinDesignFeature with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    DiscreteJoinDesignFeature( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~DiscreteJoinDesignFeature();

private:

	//! Assignment operator
	DiscreteJoinDesignFeature& operator=( const DiscreteJoinDesignFeature& iSrc );

	//! Copy constructor
	DiscreteJoinDesignFeature( const DiscreteJoinDesignFeature& original );
     
public:

	//! Set NumberOfJoinsInGroup
	plmxml_api::Result SetNumberOfJoinsInGroup( int arg );
     
	//! Get NumberOfJoinsInGroup
	int GetNumberOfJoinsInGroup() const;
     
	//! Check if NumberOfJoinsInGroup is set
	plmxml_api::logical HasNumberOfJoinsInGroup() const;
     
	//! Unset NumberOfJoinsInGroup
	plmxml_api::Result UnsetNumberOfJoinsInGroup();

	//! Set Associative
	plmxml_api::Result SetAssociative( plmxml_api::logical arg );

	//! Get Associative
	plmxml_api::logical GetAssociative() const;

	//! Check if Associative is set
	plmxml_api::logical HasAssociative() const;

	//! Unset Associative
	plmxml_api::Result UnsetAssociative();

	//! Set Checked
	plmxml_api::Result SetChecked( plmxml_api::logical arg );

	//! Get Checked
	plmxml_api::logical GetChecked() const;

	//! Check if Checked is set
	plmxml_api::logical HasChecked() const;

	//! Unset Checked
	plmxml_api::Result UnsetChecked();

	//! Get GroupId of this DiscreteJoinDesignFeature
	plmxml_api::String GetGroupId() const;

	//! Set GroupId of this DiscreteJoinDesignFeature
	plmxml_api::Result SetGroupId( const plmxml_api::String &s );
	
	//! Check if GroupId is set
	plmxml_api::logical HasGroupId( ) const;
	
	//! Unset GroupId
	plmxml_api::Result UnsetGroupId( );

	//! Set NumberOfSheetsJoined
	plmxml_api::Result SetNumberOfSheetsJoined( int arg );
     
	//! Get NumberOfSheetsJoined
	int GetNumberOfSheetsJoined() const;
     
	//! Check if NumberOfSheetsJoined is set
	plmxml_api::logical HasNumberOfSheetsJoined() const;
     
	//! Unset NumberOfSheetsJoined
	plmxml_api::Result UnsetNumberOfSheetsJoined();
 
// <PLMXML_UserCode type="functionHeaderDiscreteJoinDesignFeature" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassDiscreteJoinDesignFeature;


////////////////////////////////////////////////////////////////////////////////////
//! ResistanceWeldDesignFeature class
/*!
\verbatim

      A 4GD resistance weld Design Feature.

      Attributes:

      governingMetalThickness: The code for the governing metal thickness.
      metalCombination: The code for the metal combination.
      resistance:       The resistance of the weld in ohms.
      spotDimensionalControl: Whether the spot is dimensional control.
      spotKeyProductCharacteristic: Whether the spot is a key product
                        characteristic.
      spotKPCJustification: The justification for the spot being a key product
                        characteristic.
      spotProcessControl: Whether the spot is process control.
      stackup:          The code for the stackup.
      symbolRef:        References the geometry holding the name of the symbol.
      tolerance:        The tolerance in the number of spots.
      weldClass:        The class of the weld such as I, II or III.
      weldForce:        The resistance weld force in newtons.
      
\endverbatim
*/
class PLMXML60_API ResistanceWeldDesignFeature : public DiscreteJoinDesignFeature
{
public:
     
    //! Default constructor
    ResistanceWeldDesignFeature( );
     
    //! Constructs a ResistanceWeldDesignFeature with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ResistanceWeldDesignFeature( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ResistanceWeldDesignFeature();

private:

	//! Assignment operator
	ResistanceWeldDesignFeature& operator=( const ResistanceWeldDesignFeature& iSrc );

	//! Copy constructor
	ResistanceWeldDesignFeature( const ResistanceWeldDesignFeature& original );
     
public:

	//! Set SpotDimensionalControl
	plmxml_api::Result SetSpotDimensionalControl( plmxml_api::logical arg );

	//! Get SpotDimensionalControl
	plmxml_api::logical GetSpotDimensionalControl() const;

	//! Check if SpotDimensionalControl is set
	plmxml_api::logical HasSpotDimensionalControl() const;

	//! Unset SpotDimensionalControl
	plmxml_api::Result UnsetSpotDimensionalControl();

	//! Get MetalCombination of this ResistanceWeldDesignFeature
	plmxml_api::String GetMetalCombination() const;

	//! Set MetalCombination of this ResistanceWeldDesignFeature
	plmxml_api::Result SetMetalCombination( const plmxml_api::String &s );
	
	//! Check if MetalCombination is set
	plmxml_api::logical HasMetalCombination( ) const;
	
	//! Unset MetalCombination
	plmxml_api::Result UnsetMetalCombination( );

	//! Set WeldForce
	plmxml_api::Result SetWeldForce( double arg );

     //! Get WeldForce
	double GetWeldForce() const;

	//! Check if WeldForce is set
	plmxml_api::logical HasWeldForce() const;

	//! Unset WeldForce
	plmxml_api::Result UnsetWeldForce();

	//! Get SpotKPCJustification of this ResistanceWeldDesignFeature
	plmxml_api::String GetSpotKPCJustification() const;

	//! Set SpotKPCJustification of this ResistanceWeldDesignFeature
	plmxml_api::Result SetSpotKPCJustification( const plmxml_api::String &s );
	
	//! Check if SpotKPCJustification is set
	plmxml_api::logical HasSpotKPCJustification( ) const;
	
	//! Unset SpotKPCJustification
	plmxml_api::Result UnsetSpotKPCJustification( );

	//! Get GoverningMetalThickness of this ResistanceWeldDesignFeature
	plmxml_api::String GetGoverningMetalThickness() const;

	//! Set GoverningMetalThickness of this ResistanceWeldDesignFeature
	plmxml_api::Result SetGoverningMetalThickness( const plmxml_api::String &s );
	
	//! Check if GoverningMetalThickness is set
	plmxml_api::logical HasGoverningMetalThickness( ) const;
	
	//! Unset GoverningMetalThickness
	plmxml_api::Result UnsetGoverningMetalThickness( );

	//! Get Stackup of this ResistanceWeldDesignFeature
	plmxml_api::String GetStackup() const;

	//! Set Stackup of this ResistanceWeldDesignFeature
	plmxml_api::Result SetStackup( const plmxml_api::String &s );
	
	//! Check if Stackup is set
	plmxml_api::logical HasStackup( ) const;
	
	//! Unset Stackup
	plmxml_api::Result UnsetStackup( );

	//! Set Resistance
	plmxml_api::Result SetResistance( double arg );

     //! Get Resistance
	double GetResistance() const;

	//! Check if Resistance is set
	plmxml_api::logical HasResistance() const;

	//! Unset Resistance
	plmxml_api::Result UnsetResistance();

	//! Set Tolerance
	plmxml_api::Result SetTolerance( int arg );
     
	//! Get Tolerance
	int GetTolerance() const;
     
	//! Check if Tolerance is set
	plmxml_api::logical HasTolerance() const;
     
	//! Unset Tolerance
	plmxml_api::Result UnsetTolerance();

	//! Set SpotKeyProductCharacteristic
	plmxml_api::Result SetSpotKeyProductCharacteristic( plmxml_api::logical arg );

	//! Get SpotKeyProductCharacteristic
	plmxml_api::logical GetSpotKeyProductCharacteristic() const;

	//! Check if SpotKeyProductCharacteristic is set
	plmxml_api::logical HasSpotKeyProductCharacteristic() const;

	//! Unset SpotKeyProductCharacteristic
	plmxml_api::Result UnsetSpotKeyProductCharacteristic();

	//! Get WeldClass of this ResistanceWeldDesignFeature
	plmxml_api::String GetWeldClass() const;

	//! Set WeldClass of this ResistanceWeldDesignFeature
	plmxml_api::Result SetWeldClass( const plmxml_api::String &s );
	
	//! Check if WeldClass is set
	plmxml_api::logical HasWeldClass( ) const;
	
	//! Unset WeldClass
	plmxml_api::Result UnsetWeldClass( );

	//! Set SpotProcessControl
	plmxml_api::Result SetSpotProcessControl( plmxml_api::logical arg );

	//! Get SpotProcessControl
	plmxml_api::logical GetSpotProcessControl() const;

	//! Check if SpotProcessControl is set
	plmxml_api::logical HasSpotProcessControl() const;

	//! Unset SpotProcessControl
	plmxml_api::Result UnsetSpotProcessControl();

	//! Get Symbol URI as plmxml_api::String
	plmxml_api::String GetSymbolURI() const;

	//! Set Symbol URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetSymbolURI( const plmxml_api::String& );
	
	//! Get the handle of Symbol URI. Does not resolve the URI.
	plmxml_api::Result GetSymbolURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Symbol URI. URI string is unchanged.
	plmxml_api::Result SetSymbolURI( const plmxml_api::Handle& );
	
	//! Resolve Symbol URI and return an object (handle) it points to.
	plmxml_api::Result ResolveSymbolURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Symbol URI. Clears URI string and handle.
	plmxml_api::Result DeleteSymbolURI();
	
	//! Check if Symbol URI is set
	plmxml_api::logical HasSymbolURI( ) const;
	
 
// <PLMXML_UserCode type="functionHeaderResistanceWeldDesignFeature" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassResistanceWeldDesignFeature;


////////////////////////////////////////////////////////////////////////////////////
//! SurfaceAddDesignFeature class
/*!
\verbatim

      A 4GD surface add Design Feature.
      
\endverbatim
*/
class PLMXML60_API SurfaceAddDesignFeature : public DesignFeature
{
public:
     
    //! Default constructor
    SurfaceAddDesignFeature( );
     
    //! Constructs a SurfaceAddDesignFeature with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    SurfaceAddDesignFeature( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~SurfaceAddDesignFeature();

private:

	//! Assignment operator
	SurfaceAddDesignFeature& operator=( const SurfaceAddDesignFeature& iSrc );

	//! Copy constructor
	SurfaceAddDesignFeature( const SurfaceAddDesignFeature& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderSurfaceAddDesignFeature" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassSurfaceAddDesignFeature;


////////////////////////////////////////////////////////////////////////////////////
//! AdhesiveFillDesignFeature class
/*!
\verbatim

      A 4GD adhesive fill Design Feature.
      
\endverbatim
*/
class PLMXML60_API AdhesiveFillDesignFeature : public SurfaceAddDesignFeature
{
public:
     
    //! Default constructor
    AdhesiveFillDesignFeature( );
     
    //! Constructs a AdhesiveFillDesignFeature with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    AdhesiveFillDesignFeature( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~AdhesiveFillDesignFeature();

private:

	//! Assignment operator
	AdhesiveFillDesignFeature& operator=( const AdhesiveFillDesignFeature& iSrc );

	//! Copy constructor
	AdhesiveFillDesignFeature( const AdhesiveFillDesignFeature& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderAdhesiveFillDesignFeature" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassAdhesiveFillDesignFeature;


////////////////////////////////////////////////////////////////////////////////////
//! SurfaceWeldDesignFeature class
/*!
\verbatim

      A 4GD surface weld Design Feature.

      Attributes:

      surfacingType:    The type of surfacing.
      weldProcess:      The weld process such as SMAW.
      
\endverbatim
*/
class PLMXML60_API SurfaceWeldDesignFeature : public SurfaceAddDesignFeature
{
public:
     
    //! Default constructor
    SurfaceWeldDesignFeature( );
     
    //! Constructs a SurfaceWeldDesignFeature with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    SurfaceWeldDesignFeature( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~SurfaceWeldDesignFeature();

private:

	//! Assignment operator
	SurfaceWeldDesignFeature& operator=( const SurfaceWeldDesignFeature& iSrc );

	//! Copy constructor
	SurfaceWeldDesignFeature( const SurfaceWeldDesignFeature& original );
     
public:

	//! Set SurfacingType
	plmxml_api::Result SetSurfacingType( const eSurfacingEnum& arg );

	//! Get SurfacingType
	eSurfacingEnum GetSurfacingType() const;

	//! Get WeldProcess of this SurfaceWeldDesignFeature
	plmxml_api::String GetWeldProcess() const;

	//! Set WeldProcess of this SurfaceWeldDesignFeature
	plmxml_api::Result SetWeldProcess( const plmxml_api::String &s );
	
	//! Check if WeldProcess is set
	plmxml_api::logical HasWeldProcess( ) const;
	
	//! Unset WeldProcess
	plmxml_api::Result UnsetWeldProcess( );
 
// <PLMXML_UserCode type="functionHeaderSurfaceWeldDesignFeature" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassSurfaceWeldDesignFeature;


////////////////////////////////////////////////////////////////////////////////////
//! PartitionItem class
/*!
\verbatim

      A 4GD Partition Item.
      
\endverbatim
*/
class PLMXML60_API PartitionItem : public Structure
{
public:
     
    //! Default constructor
    PartitionItem( );
     
    //! Constructs a PartitionItem with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    PartitionItem( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~PartitionItem();

private:

	//! Assignment operator
	PartitionItem& operator=( const PartitionItem& iSrc );

	//! Copy constructor
	PartitionItem( const PartitionItem& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderPartitionItem" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassPartitionItem;


////////////////////////////////////////////////////////////////////////////////////
//! PartitionItemRevision class
/*!
\verbatim

      A revision of a 4GD Partition Item.
      
\endverbatim
*/
class PLMXML60_API PartitionItemRevision : public StructureRevision
{
public:
     
    //! Default constructor
    PartitionItemRevision( );
     
    //! Constructs a PartitionItemRevision with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    PartitionItemRevision( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~PartitionItemRevision();

private:

	//! Assignment operator
	PartitionItemRevision& operator=( const PartitionItemRevision& iSrc );

	//! Copy constructor
	PartitionItemRevision( const PartitionItemRevision& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderPartitionItemRevision" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassPartitionItemRevision;


////////////////////////////////////////////////////////////////////////////////////
//! AllowedPartition class
/*!
\verbatim

      A type of Partition allowed in a Partition Scheme.
      
\endverbatim
*/
class PLMXML60_API AllowedPartition : public Attribute
{
public:
     
    //! Default constructor
    AllowedPartition( );
     
    //! Constructs a AllowedPartition with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    AllowedPartition( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~AllowedPartition();

private:

	//! Assignment operator
	AllowedPartition& operator=( const AllowedPartition& iSrc );

	//! Copy constructor
	AllowedPartition( const AllowedPartition& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderAllowedPartition" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassAllowedPartition;


////////////////////////////////////////////////////////////////////////////////////
//! PartitionScheme class
/*!
\verbatim

      A 4GD Partition Scheme.

      Attributes:

      type:             The type of Partition Scheme.

      Sub-elements:

      AllowedPartition: The types of Partition allowed in the Partition Scheme.
      
\endverbatim
*/
class PLMXML60_API PartitionScheme : public View
{
public:
     
    //! Default constructor
    PartitionScheme( );
     
    //! Constructs a PartitionScheme with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    PartitionScheme( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~PartitionScheme();

private:

	//! Assignment operator
	PartitionScheme& operator=( const PartitionScheme& iSrc );

	//! Copy constructor
	PartitionScheme( const PartitionScheme& original );
     
public:

	//! Get Type of this PartitionScheme
	plmxml_api::String GetType() const;

	//! Set Type of this PartitionScheme
	plmxml_api::Result SetType( const plmxml_api::String &s );
	
	//! Check if Type is set
	plmxml_api::logical HasType( ) const;
	
	//! Unset Type
	plmxml_api::Result UnsetType( );

	//! Add AllowedPartition child element to this PartitionScheme. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	AllowedPartition *AddAllowedPartition();
     
	//! Add 'arg' as AllowedPartition child element to this PartitionScheme.
	plmxml_api::Result AddAllowedPartition( AllowedPartition *arg );

	//! Detach and delete all AllowedPartition child elements.
	void DeleteAllowedPartitions();
     
	//! Get number of AllowedPartition child elements.
	int NumberOfAllowedPartitions() const;
     
	//! Get i'th AllowedPartition child element.
	AllowedPartition *GetAllowedPartition( int i ) const;
     
	//! Get all AllowedPartition child element as an array
	void GetAllowedPartitions( plmxml_api::Array<AllowedPartition*> &array ) const;
	     
	//! Detach and delete i'th AllowedPartition child element
	void DeleteAllowedPartition( int i );
     
	//! Detach and delete 'arg' if it's one of the AllowedPartition child elements
	void DeleteAllowedPartition( AllowedPartition *arg );
 
// <PLMXML_UserCode type="functionHeaderPartitionScheme" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassPartitionScheme;


////////////////////////////////////////////////////////////////////////////////////
//! PartitionMember class
/*!
\verbatim

      A member of a 4GD Partition.

      Attributes:

      membershipOwner:  The owner of the membership of the Design Element in a Partition.
      
\endverbatim
*/
class PLMXML60_API PartitionMember : public Occurrence
{
public:
     
    //! Default constructor
    PartitionMember( );
     
    //! Constructs a PartitionMember with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    PartitionMember( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~PartitionMember();

private:

	//! Assignment operator
	PartitionMember& operator=( const PartitionMember& iSrc );

	//! Copy constructor
	PartitionMember( const PartitionMember& original );
     
public:

	//! Set MembershipOwner
	plmxml_api::Result SetMembershipOwner( const eMembershipOwnerEnum& arg );

	//! Get MembershipOwner
	eMembershipOwnerEnum GetMembershipOwner() const;
 
// <PLMXML_UserCode type="functionHeaderPartitionMember" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassPartitionMember;


////////////////////////////////////////////////////////////////////////////////////
//! Partition class
/*!
\verbatim

      A 4GD Partition.

      Attributes:

      subType:          Inherited from Managed. The subclass of the Partition.
      partitionId:      The identifier of the Partition.
      revision:         The revision of the Partition.
      partitionItemRef: References a 4GD PartitionItem or PartitionItemRevision.
      schemeRef:        References a 4GD PartitionScheme.
      membershipOwner:  The owner of the membership of the Design Elements in a
                        4GD Partition.
      partitionRefs:    References nested 4GD Partitions.
      elementThreadRef: References the InstanceThread in which the 4GD Partition
                        is included, if any.
      elementThread:    The identifier of the element thread of the Partition.

      Sub-elements:

      Member:           Members of a 4GD Partition.
      
\endverbatim
*/
class PLMXML60_API Partition : public Managed
{
public:
     
    //! Default constructor
    Partition( );
     
    //! Constructs a Partition with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Partition( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Partition();

private:

	//! Assignment operator
	Partition& operator=( const Partition& iSrc );

	//! Copy constructor
	Partition( const Partition& original );
     
public:

	//! Get PartitionItem URI as plmxml_api::String
	plmxml_api::String GetPartitionItemURI() const;

	//! Set PartitionItem URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetPartitionItemURI( const plmxml_api::String& );
	
	//! Get the handle of PartitionItem URI. Does not resolve the URI.
	plmxml_api::Result GetPartitionItemURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of PartitionItem URI. URI string is unchanged.
	plmxml_api::Result SetPartitionItemURI( const plmxml_api::Handle& );
	
	//! Resolve PartitionItem URI and return an object (handle) it points to.
	plmxml_api::Result ResolvePartitionItemURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset PartitionItem URI. Clears URI string and handle.
	plmxml_api::Result DeletePartitionItemURI();
	
	//! Check if PartitionItem URI is set
	plmxml_api::logical HasPartitionItemURI( ) const;
	

	//! Get ElementThread of this Partition
	plmxml_api::String GetElementThread() const;

	//! Set ElementThread of this Partition
	plmxml_api::Result SetElementThread( const plmxml_api::String &s );
	
	//! Check if ElementThread is set
	plmxml_api::logical HasElementThread( ) const;
	
	//! Unset ElementThread
	plmxml_api::Result UnsetElementThread( );

	//! Get number of URIs in Partition
	int NumberOfPartitionURIs() const;

	//! Get i'th URI in Partition
	plmxml_api::String GetPartitionURI( int i ) const;

	//! Add a URI to Partition array. Call ResolvePartitionURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddPartitionURI( const plmxml_api::String& u );

	//! Set i'th URI in Partition array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetPartitionURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Partition URI. Does not resolve the URI.
	plmxml_api::Result GetPartitionURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Partition array.
	plmxml_api::Result AddPartitionURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Partition array to point to 'handle'.
	plmxml_api::Result SetPartitionURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Partition points to.
	plmxml_api::Result ResolvePartitionURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Partition array.
	plmxml_api::Result DeletePartitionURI( int i );

	//! Remove all URIs from Partition array.
	plmxml_api::Result DeletePartitionURIs( );
	
	//! Check if Partition is set
	plmxml_api::logical HasPartitionURIs( ) const;

	//! Get Scheme URI as plmxml_api::String
	plmxml_api::String GetSchemeURI() const;

	//! Set Scheme URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetSchemeURI( const plmxml_api::String& );
	
	//! Get the handle of Scheme URI. Does not resolve the URI.
	plmxml_api::Result GetSchemeURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Scheme URI. URI string is unchanged.
	plmxml_api::Result SetSchemeURI( const plmxml_api::Handle& );
	
	//! Resolve Scheme URI and return an object (handle) it points to.
	plmxml_api::Result ResolveSchemeURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Scheme URI. Clears URI string and handle.
	plmxml_api::Result DeleteSchemeURI();
	
	//! Check if Scheme URI is set
	plmxml_api::logical HasSchemeURI( ) const;
	

	//! Get PartitionId of this Partition
	plmxml_api::String GetPartitionId() const;

	//! Set PartitionId of this Partition
	plmxml_api::Result SetPartitionId( const plmxml_api::String &s );
	
	//! Check if PartitionId is set
	plmxml_api::logical HasPartitionId( ) const;
	
	//! Unset PartitionId
	plmxml_api::Result UnsetPartitionId( );

	//! Set MembershipOwner
	plmxml_api::Result SetMembershipOwner( const eMembershipOwnerEnum& arg );

	//! Get MembershipOwner
	eMembershipOwnerEnum GetMembershipOwner() const;

	//! Get Revision of this Partition
	plmxml_api::String GetRevision() const;

	//! Set Revision of this Partition
	plmxml_api::Result SetRevision( const plmxml_api::String &s );
	
	//! Check if Revision is set
	plmxml_api::logical HasRevision( ) const;
	
	//! Unset Revision
	plmxml_api::Result UnsetRevision( );

	//! Get ElementThread URI as plmxml_api::String
	plmxml_api::String GetElementThreadURI() const;

	//! Set ElementThread URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetElementThreadURI( const plmxml_api::String& );
	
	//! Get the handle of ElementThread URI. Does not resolve the URI.
	plmxml_api::Result GetElementThreadURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of ElementThread URI. URI string is unchanged.
	plmxml_api::Result SetElementThreadURI( const plmxml_api::Handle& );
	
	//! Resolve ElementThread URI and return an object (handle) it points to.
	plmxml_api::Result ResolveElementThreadURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset ElementThread URI. Clears URI string and handle.
	plmxml_api::Result DeleteElementThreadURI();
	
	//! Check if ElementThread URI is set
	plmxml_api::logical HasElementThreadURI( ) const;
	

	//! Add Member child element to this Partition. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	PartitionMember *AddMember();
     
	//! Add 'arg' as Member child element to this Partition.
	plmxml_api::Result AddMember( PartitionMember *arg );

	//! Detach and delete all Member child elements.
	void DeleteMembers();
     
	//! Get number of Member child elements.
	int NumberOfMembers() const;
     
	//! Get i'th Member child element.
	PartitionMember *GetMember( int i ) const;
     
	//! Get all Member child element as an array
	void GetMembers( plmxml_api::Array<PartitionMember*> &array ) const;
	     
	//! Detach and delete i'th Member child element
	void DeleteMember( int i );
     
	//! Detach and delete 'arg' if it's one of the Member child elements
	void DeleteMember( PartitionMember *arg );
 
// <PLMXML_UserCode type="functionHeaderPartition" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassPartition;


////////////////////////////////////////////////////////////////////////////////////
//! Workset class
/*!
\verbatim

      A 4GD Workset.
      
\endverbatim
*/
class PLMXML60_API Workset : public Structure
{
public:
     
    //! Default constructor
    Workset( );
     
    //! Constructs a Workset with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Workset( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Workset();

private:

	//! Assignment operator
	Workset& operator=( const Workset& iSrc );

	//! Copy constructor
	Workset( const Workset& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderWorkset" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassWorkset;


////////////////////////////////////////////////////////////////////////////////////
//! WorksetRevision class
/*!
\verbatim

      A revision of a 4GD Workset.
      
\endverbatim
*/
class PLMXML60_API WorksetRevision : public StructureRevision
{
public:
     
    //! Default constructor
    WorksetRevision( );
     
    //! Constructs a WorksetRevision with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    WorksetRevision( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~WorksetRevision();

private:

	//! Assignment operator
	WorksetRevision& operator=( const WorksetRevision& iSrc );

	//! Copy constructor
	WorksetRevision( const WorksetRevision& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderWorksetRevision" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassWorksetRevision;


////////////////////////////////////////////////////////////////////////////////////
//! WorksetRevisionView class
/*!
\verbatim

      A view of a revision of a 4GD Workset.

      Attributes:

      subsetInstanceRefs: References the ProductInstances and SubsetInstances
                        that comprise the 4GD Workset.
      
\endverbatim
*/
class PLMXML60_API WorksetRevisionView : public StructureRevisionView
{
public:
     
    //! Default constructor
    WorksetRevisionView( );
     
    //! Constructs a WorksetRevisionView with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    WorksetRevisionView( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~WorksetRevisionView();

private:

	//! Assignment operator
	WorksetRevisionView& operator=( const WorksetRevisionView& iSrc );

	//! Copy constructor
	WorksetRevisionView( const WorksetRevisionView& original );
     
public:

	//! Get number of URIs in SubsetInstance
	int NumberOfSubsetInstanceURIs() const;

	//! Get i'th URI in SubsetInstance
	plmxml_api::String GetSubsetInstanceURI( int i ) const;

	//! Add a URI to SubsetInstance array. Call ResolveSubsetInstanceURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddSubsetInstanceURI( const plmxml_api::String& u );

	//! Set i'th URI in SubsetInstance array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetSubsetInstanceURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of SubsetInstance URI. Does not resolve the URI.
	plmxml_api::Result GetSubsetInstanceURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to SubsetInstance array.
	plmxml_api::Result AddSubsetInstanceURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in SubsetInstance array to point to 'handle'.
	plmxml_api::Result SetSubsetInstanceURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in SubsetInstance points to.
	plmxml_api::Result ResolveSubsetInstanceURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from SubsetInstance array.
	plmxml_api::Result DeleteSubsetInstanceURI( int i );

	//! Remove all URIs from SubsetInstance array.
	plmxml_api::Result DeleteSubsetInstanceURIs( );
	
	//! Check if SubsetInstance is set
	plmxml_api::logical HasSubsetInstanceURIs( ) const;
 
// <PLMXML_UserCode type="functionHeaderWorksetRevisionView" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassWorksetRevisionView;


////////////////////////////////////////////////////////////////////////////////////
//! GeometricConstraint class
/*!
\verbatim

      A 4GD Search Criteria Geometric Constraint.

      Attributes:

      searchCriteriaRef: References a Search Criteria.
      searchCriteriaAction: Whether the Design Elements and Design Features
                        resulting from the Search Criteria should be regarded as
                        foreground, background or both.
      geometricConstraintAction: Whether the foreground, background or both
                        Design Elements and Design Features owing to the
                        Geometric Constraint should be appended to the result.
      
\endverbatim
*/
class PLMXML60_API GeometricConstraint : public OccurrenceFilter
{
public:
     
    //! Default constructor
    GeometricConstraint( );
     
    //! Constructs a GeometricConstraint with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    GeometricConstraint( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~GeometricConstraint();

private:

	//! Assignment operator
	GeometricConstraint& operator=( const GeometricConstraint& iSrc );

	//! Copy constructor
	GeometricConstraint( const GeometricConstraint& original );
     
public:

	//! Get SearchCriteria URI as plmxml_api::String
	plmxml_api::String GetSearchCriteriaURI() const;

	//! Set SearchCriteria URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetSearchCriteriaURI( const plmxml_api::String& );
	
	//! Get the handle of SearchCriteria URI. Does not resolve the URI.
	plmxml_api::Result GetSearchCriteriaURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of SearchCriteria URI. URI string is unchanged.
	plmxml_api::Result SetSearchCriteriaURI( const plmxml_api::Handle& );
	
	//! Resolve SearchCriteria URI and return an object (handle) it points to.
	plmxml_api::Result ResolveSearchCriteriaURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset SearchCriteria URI. Clears URI string and handle.
	plmxml_api::Result DeleteSearchCriteriaURI();
	
	//! Check if SearchCriteria URI is set
	plmxml_api::logical HasSearchCriteriaURI( ) const;
	

	//! Set SearchCriteriaAction
	plmxml_api::Result SetSearchCriteriaAction( const eGeometricConstraintActionEnum& arg );

	//! Get SearchCriteriaAction
	eGeometricConstraintActionEnum GetSearchCriteriaAction() const;

	//! Set GeometricConstraintAction
	plmxml_api::Result SetGeometricConstraintAction( const eGeometricConstraintActionEnum& arg );

	//! Get GeometricConstraintAction
	eGeometricConstraintActionEnum GetGeometricConstraintAction() const;
 
// <PLMXML_UserCode type="functionHeaderGeometricConstraint" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassGeometricConstraint;


////////////////////////////////////////////////////////////////////////////////////
//! OptionSet class
/*!
\verbatim

      A 4GD Search Criteria Option Set.

      Sub-elements:

      Option:           The options in the Search Criteria Option Set.
      
\endverbatim
*/
class PLMXML60_API OptionSet : public OccurrenceFilter
{
public:
     
    //! Default constructor
    OptionSet( );
     
    //! Constructs a OptionSet with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    OptionSet( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~OptionSet();

private:

	//! Assignment operator
	OptionSet& operator=( const OptionSet& iSrc );

	//! Copy constructor
	OptionSet( const OptionSet& original );
     
public:

	//! Add Option child element to this OptionSet. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	UserValue *AddOption();
     
	//! Add 'arg' as Option child element to this OptionSet.
	plmxml_api::Result AddOption( UserValue *arg );

	//! Detach and delete all Option child elements.
	void DeleteOptions();
     
	//! Get number of Option child elements.
	int NumberOfOptions() const;
     
	//! Get i'th Option child element.
	UserValue *GetOption( int i ) const;
     
	//! Get all Option child element as an array
	void GetOptions( plmxml_api::Array<UserValue*> &array ) const;
	     
	//! Detach and delete i'th Option child element
	void DeleteOption( int i );
     
	//! Detach and delete 'arg' if it's one of the Option child elements
	void DeleteOption( UserValue *arg );
 
// <PLMXML_UserCode type="functionHeaderOptionSet" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassOptionSet;


////////////////////////////////////////////////////////////////////////////////////
//! PartitionSearchCriteria class
/*!
\verbatim

      A 4GD Search Criteria Partition.

      Attributes:

      recursive:        Whether to include the contents of child Partitions.
      searchCriteriaRefs: References one or more Search Criteria. There is an
                        implicit union operation among these Search Criteria.
      revisionSearchCriteriaRefs: References one or more Search Criteria that
                        determine the set of revisions. There is an implicit
                        union operation among these Search Criteria.
      
\endverbatim
*/
class PLMXML60_API PartitionSearchCriteria : public OccurrenceFilter
{
public:
     
    //! Default constructor
    PartitionSearchCriteria( );
     
    //! Constructs a PartitionSearchCriteria with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    PartitionSearchCriteria( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~PartitionSearchCriteria();

private:

	//! Assignment operator
	PartitionSearchCriteria& operator=( const PartitionSearchCriteria& iSrc );

	//! Copy constructor
	PartitionSearchCriteria( const PartitionSearchCriteria& original );
     
public:

	//! Set Recursive
	plmxml_api::Result SetRecursive( plmxml_api::logical arg );

	//! Get Recursive
	plmxml_api::logical GetRecursive() const;

	//! Check if Recursive is set
	plmxml_api::logical HasRecursive() const;

	//! Unset Recursive
	plmxml_api::Result UnsetRecursive();

	//! Get number of URIs in SearchCriteria
	int NumberOfSearchCriteriaURIs() const;

	//! Get i'th URI in SearchCriteria
	plmxml_api::String GetSearchCriteriaURI( int i ) const;

	//! Add a URI to SearchCriteria array. Call ResolveSearchCriteriaURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddSearchCriteriaURI( const plmxml_api::String& u );

	//! Set i'th URI in SearchCriteria array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetSearchCriteriaURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of SearchCriteria URI. Does not resolve the URI.
	plmxml_api::Result GetSearchCriteriaURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to SearchCriteria array.
	plmxml_api::Result AddSearchCriteriaURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in SearchCriteria array to point to 'handle'.
	plmxml_api::Result SetSearchCriteriaURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in SearchCriteria points to.
	plmxml_api::Result ResolveSearchCriteriaURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from SearchCriteria array.
	plmxml_api::Result DeleteSearchCriteriaURI( int i );

	//! Remove all URIs from SearchCriteria array.
	plmxml_api::Result DeleteSearchCriteriaURIs( );
	
	//! Check if SearchCriteria is set
	plmxml_api::logical HasSearchCriteriaURIs( ) const;

	//! Get number of URIs in RevisionSearchCriteria
	int NumberOfRevisionSearchCriteriaURIs() const;

	//! Get i'th URI in RevisionSearchCriteria
	plmxml_api::String GetRevisionSearchCriteriaURI( int i ) const;

	//! Add a URI to RevisionSearchCriteria array. Call ResolveRevisionSearchCriteriaURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddRevisionSearchCriteriaURI( const plmxml_api::String& u );

	//! Set i'th URI in RevisionSearchCriteria array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetRevisionSearchCriteriaURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of RevisionSearchCriteria URI. Does not resolve the URI.
	plmxml_api::Result GetRevisionSearchCriteriaURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to RevisionSearchCriteria array.
	plmxml_api::Result AddRevisionSearchCriteriaURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in RevisionSearchCriteria array to point to 'handle'.
	plmxml_api::Result SetRevisionSearchCriteriaURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in RevisionSearchCriteria points to.
	plmxml_api::Result ResolveRevisionSearchCriteriaURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from RevisionSearchCriteria array.
	plmxml_api::Result DeleteRevisionSearchCriteriaURI( int i );

	//! Remove all URIs from RevisionSearchCriteria array.
	plmxml_api::Result DeleteRevisionSearchCriteriaURIs( );
	
	//! Check if RevisionSearchCriteria is set
	plmxml_api::logical HasRevisionSearchCriteriaURIs( ) const;
 
// <PLMXML_UserCode type="functionHeaderPartitionSearchCriteria" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassPartitionSearchCriteria;


////////////////////////////////////////////////////////////////////////////////////
//! SavedQuery class
/*!
\verbatim

      A 4GD Search Criteria Saved Query.

      Sub-elements:

      Entry:            The entries in the Search Criteria Saved Query.
      
\endverbatim
*/
class PLMXML60_API SavedQuery : public SetFilter
{
public:
     
    //! Default constructor
    SavedQuery( );
     
    //! Constructs a SavedQuery with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    SavedQuery( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~SavedQuery();

private:

	//! Assignment operator
	SavedQuery& operator=( const SavedQuery& iSrc );

	//! Copy constructor
	SavedQuery( const SavedQuery& original );
     
public:

	//! Add Entry child element to this SavedQuery. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	UserValue *AddEntry();
     
	//! Add 'arg' as Entry child element to this SavedQuery.
	plmxml_api::Result AddEntry( UserValue *arg );

	//! Detach and delete all Entry child elements.
	void DeleteEntries();
     
	//! Get number of Entry child elements.
	int NumberOfEntries() const;
     
	//! Get i'th Entry child element.
	UserValue *GetEntry( int i ) const;
     
	//! Get all Entry child element as an array
	void GetEntries( plmxml_api::Array<UserValue*> &array ) const;
	     
	//! Detach and delete i'th Entry child element
	void DeleteEntry( int i );
     
	//! Detach and delete 'arg' if it's one of the Entry child elements
	void DeleteEntry( UserValue *arg );
 
// <PLMXML_UserCode type="functionHeaderSavedQuery" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassSavedQuery;


////////////////////////////////////////////////////////////////////////////////////
//! TypeSearchCriteria class
/*!
\verbatim

      A 4GD Search Criteria Type.

      Sub-elements:

      ValueList:        The search types in the Search Criteria Type.
      
\endverbatim
*/
class PLMXML60_API TypeSearchCriteria : public OccurrenceFilter
{
public:
     
    //! Default constructor
    TypeSearchCriteria( );
     
    //! Constructs a TypeSearchCriteria with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    TypeSearchCriteria( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~TypeSearchCriteria();

private:

	//! Assignment operator
	TypeSearchCriteria& operator=( const TypeSearchCriteria& iSrc );

	//! Copy constructor
	TypeSearchCriteria( const TypeSearchCriteria& original );
     
public:

	//! Add ValueList child element to this TypeSearchCriteria. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	UserList *AddValueList();
     
	//! Add 'arg' as ValueList child element to this TypeSearchCriteria.
	plmxml_api::Result AddValueList( UserList *arg );

	//! Detach and delete all ValueList child elements.
	void DeleteValueLists();
     
	//! Get number of ValueList child elements.
	int NumberOfValueLists() const;
     
	//! Get i'th ValueList child element.
	UserList *GetValueList( int i ) const;
     
	//! Get all ValueList child element as an array
	void GetValueLists( plmxml_api::Array<UserList*> &array ) const;
	     
	//! Detach and delete i'th ValueList child element
	void DeleteValueList( int i );
     
	//! Detach and delete 'arg' if it's one of the ValueList child elements
	void DeleteValueList( UserList *arg );
 
// <PLMXML_UserCode type="functionHeaderTypeSearchCriteria" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassTypeSearchCriteria;


////////////////////////////////////////////////////////////////////////////////////
//! Subset class
/*!
\verbatim

      A 4GD Subset Definition or Subset.
      A Subset Definition is like a Subset before the Search Criteria is executed.

      subsetId:         The identifier of the Subset.
      revision:         The revision of the Subset.
      contextRef:       References the owning Collaborative Design.

      Sub-elements:

      Occurrence:       The contents of the 4GD Subset.
      
\endverbatim
*/
class PLMXML60_API Subset : public Managed
{
public:
     
    //! Default constructor
    Subset( );
     
    //! Constructs a Subset with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Subset( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Subset();

private:

	//! Assignment operator
	Subset& operator=( const Subset& iSrc );

	//! Copy constructor
	Subset( const Subset& original );
     
public:

	//! Get Revision of this Subset
	plmxml_api::String GetRevision() const;

	//! Set Revision of this Subset
	plmxml_api::Result SetRevision( const plmxml_api::String &s );
	
	//! Check if Revision is set
	plmxml_api::logical HasRevision( ) const;
	
	//! Unset Revision
	plmxml_api::Result UnsetRevision( );

	//! Get SubsetId of this Subset
	plmxml_api::String GetSubsetId() const;

	//! Set SubsetId of this Subset
	plmxml_api::Result SetSubsetId( const plmxml_api::String &s );
	
	//! Check if SubsetId is set
	plmxml_api::logical HasSubsetId( ) const;
	
	//! Unset SubsetId
	plmxml_api::Result UnsetSubsetId( );

	//! Get Context URI as plmxml_api::String
	plmxml_api::String GetContextURI() const;

	//! Set Context URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetContextURI( const plmxml_api::String& );
	
	//! Get the handle of Context URI. Does not resolve the URI.
	plmxml_api::Result GetContextURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Context URI. URI string is unchanged.
	plmxml_api::Result SetContextURI( const plmxml_api::Handle& );
	
	//! Resolve Context URI and return an object (handle) it points to.
	plmxml_api::Result ResolveContextURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Context URI. Clears URI string and handle.
	plmxml_api::Result DeleteContextURI();
	
	//! Check if Context URI is set
	plmxml_api::logical HasContextURI( ) const;
	

	//! Add Occurrence child element to this Subset. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Occurrence *AddOccurrence();
     
	//! Add 'arg' as Occurrence child element to this Subset.
	plmxml_api::Result AddOccurrence( Occurrence *arg );

	//! Detach and delete all Occurrence child elements.
	void DeleteOccurrences();
     
	//! Get number of Occurrence child elements.
	int NumberOfOccurrences() const;
     
	//! Get i'th Occurrence child element.
	Occurrence *GetOccurrence( int i ) const;
     
	//! Get all Occurrence child element as an array
	void GetOccurrences( plmxml_api::Array<Occurrence*> &array ) const;
	     
	//! Detach and delete i'th Occurrence child element
	void DeleteOccurrence( int i );
     
	//! Detach and delete 'arg' if it's one of the Occurrence child elements
	void DeleteOccurrence( Occurrence *arg );
 
// <PLMXML_UserCode type="functionHeaderSubset" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassSubset;


////////////////////////////////////////////////////////////////////////////////////
//! SubsetInstance class
/*!
\verbatim

      A 4GD Subset Instance.

      Attributes:

      elementThread:    The identifier of the element thread of the Subset
                        Instance.
      
\endverbatim
*/
class PLMXML60_API SubsetInstance : public Instance
{
public:
     
    //! Default constructor
    SubsetInstance( );
     
    //! Constructs a SubsetInstance with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    SubsetInstance( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~SubsetInstance();

private:

	//! Assignment operator
	SubsetInstance& operator=( const SubsetInstance& iSrc );

	//! Copy constructor
	SubsetInstance( const SubsetInstance& original );
     
public:

	//! Get ElementThread of this SubsetInstance
	plmxml_api::String GetElementThread() const;

	//! Set ElementThread of this SubsetInstance
	plmxml_api::Result SetElementThread( const plmxml_api::String &s );
	
	//! Check if ElementThread is set
	plmxml_api::logical HasElementThread( ) const;
	
	//! Unset ElementThread
	plmxml_api::Result UnsetElementThread( );
 
// <PLMXML_UserCode type="functionHeaderSubsetInstance" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassSubsetInstance;


////////////////////////////////////////////////////////////////////////////////////
//! AspectScheme class
/*!
\verbatim

      A 4GD Aspect Scheme.

      Attributes:

      prefix:           The prefix designator of the Aspect Scheme.
      rootRef:          References the root 4GD Aspect.
      unassignedRef:    References the root unassigned 4GD Aspect.
      
\endverbatim
*/
class PLMXML60_API AspectScheme : public View
{
public:
     
    //! Default constructor
    AspectScheme( );
     
    //! Constructs a AspectScheme with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    AspectScheme( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~AspectScheme();

private:

	//! Assignment operator
	AspectScheme& operator=( const AspectScheme& iSrc );

	//! Copy constructor
	AspectScheme( const AspectScheme& original );
     
public:

	//! Get Prefix of this AspectScheme
	plmxml_api::String GetPrefix() const;

	//! Set Prefix of this AspectScheme
	plmxml_api::Result SetPrefix( const plmxml_api::String &s );
	
	//! Check if Prefix is set
	plmxml_api::logical HasPrefix( ) const;
	
	//! Unset Prefix
	plmxml_api::Result UnsetPrefix( );

	//! Get Root URI as plmxml_api::String
	plmxml_api::String GetRootURI() const;

	//! Set Root URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetRootURI( const plmxml_api::String& );
	
	//! Get the handle of Root URI. Does not resolve the URI.
	plmxml_api::Result GetRootURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Root URI. URI string is unchanged.
	plmxml_api::Result SetRootURI( const plmxml_api::Handle& );
	
	//! Resolve Root URI and return an object (handle) it points to.
	plmxml_api::Result ResolveRootURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Root URI. Clears URI string and handle.
	plmxml_api::Result DeleteRootURI();
	
	//! Check if Root URI is set
	plmxml_api::logical HasRootURI( ) const;
	

	//! Get Unassigned URI as plmxml_api::String
	plmxml_api::String GetUnassignedURI() const;

	//! Set Unassigned URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetUnassignedURI( const plmxml_api::String& );
	
	//! Get the handle of Unassigned URI. Does not resolve the URI.
	plmxml_api::Result GetUnassignedURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Unassigned URI. URI string is unchanged.
	plmxml_api::Result SetUnassignedURI( const plmxml_api::Handle& );
	
	//! Resolve Unassigned URI and return an object (handle) it points to.
	plmxml_api::Result ResolveUnassignedURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Unassigned URI. Clears URI string and handle.
	plmxml_api::Result DeleteUnassignedURI();
	
	//! Check if Unassigned URI is set
	plmxml_api::logical HasUnassignedURI( ) const;
	
 
// <PLMXML_UserCode type="functionHeaderAspectScheme" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassAspectScheme;


////////////////////////////////////////////////////////////////////////////////////
//! Aspect class
/*!
\verbatim

      A 4GD Aspect.

      Attributes:

      subType:          Inherited from Managed. The subclass of the Aspect.
      designator:       The designator of the Aspect.
      revision:         The revision of the Aspect.
      aspectRefs:       References nested 4GD Aspects.
      modelElementRef:  References the Model Element that implements the Aspect.
      
\endverbatim
*/
class PLMXML60_API Aspect : public Managed
{
public:
     
    //! Default constructor
    Aspect( );
     
    //! Constructs a Aspect with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Aspect( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Aspect();

private:

	//! Assignment operator
	Aspect& operator=( const Aspect& iSrc );

	//! Copy constructor
	Aspect( const Aspect& original );
     
public:

	//! Get Designator of this Aspect
	plmxml_api::String GetDesignator() const;

	//! Set Designator of this Aspect
	plmxml_api::Result SetDesignator( const plmxml_api::String &s );
	
	//! Check if Designator is set
	plmxml_api::logical HasDesignator( ) const;
	
	//! Unset Designator
	plmxml_api::Result UnsetDesignator( );

	//! Get Revision of this Aspect
	plmxml_api::String GetRevision() const;

	//! Set Revision of this Aspect
	plmxml_api::Result SetRevision( const plmxml_api::String &s );
	
	//! Check if Revision is set
	plmxml_api::logical HasRevision( ) const;
	
	//! Unset Revision
	plmxml_api::Result UnsetRevision( );

	//! Get number of URIs in Aspect
	int NumberOfAspectURIs() const;

	//! Get i'th URI in Aspect
	plmxml_api::String GetAspectURI( int i ) const;

	//! Add a URI to Aspect array. Call ResolveAspectURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddAspectURI( const plmxml_api::String& u );

	//! Set i'th URI in Aspect array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetAspectURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of Aspect URI. Does not resolve the URI.
	plmxml_api::Result GetAspectURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to Aspect array.
	plmxml_api::Result AddAspectURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in Aspect array to point to 'handle'.
	plmxml_api::Result SetAspectURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in Aspect points to.
	plmxml_api::Result ResolveAspectURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from Aspect array.
	plmxml_api::Result DeleteAspectURI( int i );

	//! Remove all URIs from Aspect array.
	plmxml_api::Result DeleteAspectURIs( );
	
	//! Check if Aspect is set
	plmxml_api::logical HasAspectURIs( ) const;

	//! Get ModelElement URI as plmxml_api::String
	plmxml_api::String GetModelElementURI() const;

	//! Set ModelElement URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetModelElementURI( const plmxml_api::String& );
	
	//! Get the handle of ModelElement URI. Does not resolve the URI.
	plmxml_api::Result GetModelElementURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of ModelElement URI. URI string is unchanged.
	plmxml_api::Result SetModelElementURI( const plmxml_api::Handle& );
	
	//! Resolve ModelElement URI and return an object (handle) it points to.
	plmxml_api::Result ResolveModelElementURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset ModelElement URI. Clears URI string and handle.
	plmxml_api::Result DeleteModelElementURI();
	
	//! Check if ModelElement URI is set
	plmxml_api::logical HasModelElementURI( ) const;
	
 
// <PLMXML_UserCode type="functionHeaderAspect" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassAspect;


////////////////////////////////////////////////////////////////////////////////////
//! Composition class
/*!
\verbatim

      A 4GD Composition.

      Attributes:

      subsetInstanceRefs: References the SubsetInstances that comprise the
                        Composition.
      
\endverbatim
*/
class PLMXML60_API Composition : public ModelElement
{
public:
     
    //! Default constructor
    Composition( );
     
    //! Constructs a Composition with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    Composition( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~Composition();

private:

	//! Assignment operator
	Composition& operator=( const Composition& iSrc );

	//! Copy constructor
	Composition( const Composition& original );
     
public:

	//! Get number of URIs in SubsetInstance
	int NumberOfSubsetInstanceURIs() const;

	//! Get i'th URI in SubsetInstance
	plmxml_api::String GetSubsetInstanceURI( int i ) const;

	//! Add a URI to SubsetInstance array. Call ResolveSubsetInstanceURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddSubsetInstanceURI( const plmxml_api::String& u );

	//! Set i'th URI in SubsetInstance array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetSubsetInstanceURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of SubsetInstance URI. Does not resolve the URI.
	plmxml_api::Result GetSubsetInstanceURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to SubsetInstance array.
	plmxml_api::Result AddSubsetInstanceURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in SubsetInstance array to point to 'handle'.
	plmxml_api::Result SetSubsetInstanceURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in SubsetInstance points to.
	plmxml_api::Result ResolveSubsetInstanceURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from SubsetInstance array.
	plmxml_api::Result DeleteSubsetInstanceURI( int i );

	//! Remove all URIs from SubsetInstance array.
	plmxml_api::Result DeleteSubsetInstanceURIs( );
	
	//! Check if SubsetInstance is set
	plmxml_api::logical HasSubsetInstanceURIs( ) const;
 
// <PLMXML_UserCode type="functionHeaderComposition" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassComposition;


////////////////////////////////////////////////////////////////////////////////////
//! ProductMasterPart class
/*!
\verbatim

      A 4G Product Master Part.

      Attributes:

      revision:         The revision of the Product Master Part.
      productMasterPartThreadRef: References the Product Master Part Thread.
      
\endverbatim
*/
class PLMXML60_API ProductMasterPart : public Managed
{
public:
     
    //! Default constructor
    ProductMasterPart( );
     
    //! Constructs a ProductMasterPart with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ProductMasterPart( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ProductMasterPart();

private:

	//! Assignment operator
	ProductMasterPart& operator=( const ProductMasterPart& iSrc );

	//! Copy constructor
	ProductMasterPart( const ProductMasterPart& original );
     
public:

	//! Get ProductMasterPartThread URI as plmxml_api::String
	plmxml_api::String GetProductMasterPartThreadURI() const;

	//! Set ProductMasterPartThread URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetProductMasterPartThreadURI( const plmxml_api::String& );
	
	//! Get the handle of ProductMasterPartThread URI. Does not resolve the URI.
	plmxml_api::Result GetProductMasterPartThreadURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of ProductMasterPartThread URI. URI string is unchanged.
	plmxml_api::Result SetProductMasterPartThreadURI( const plmxml_api::Handle& );
	
	//! Resolve ProductMasterPartThread URI and return an object (handle) it points to.
	plmxml_api::Result ResolveProductMasterPartThreadURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset ProductMasterPartThread URI. Clears URI string and handle.
	plmxml_api::Result DeleteProductMasterPartThreadURI();
	
	//! Check if ProductMasterPartThread URI is set
	plmxml_api::logical HasProductMasterPartThreadURI( ) const;
	

	//! Get Revision of this ProductMasterPart
	plmxml_api::String GetRevision() const;

	//! Set Revision of this ProductMasterPart
	plmxml_api::Result SetRevision( const plmxml_api::String &s );
	
	//! Check if Revision is set
	plmxml_api::logical HasRevision( ) const;
	
	//! Unset Revision
	plmxml_api::Result UnsetRevision( );
 
// <PLMXML_UserCode type="functionHeaderProductMasterPart" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassProductMasterPart;


////////////////////////////////////////////////////////////////////////////////////
//! ProductMasterPartThread class
/*!
\verbatim

      A 4G Product Master Part Thread.
      
\endverbatim
*/
class PLMXML60_API ProductMasterPartThread : public InstanceThread
{
public:
     
    //! Default constructor
    ProductMasterPartThread( );
     
    //! Constructs a ProductMasterPartThread with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ProductMasterPartThread( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ProductMasterPartThread();

private:

	//! Assignment operator
	ProductMasterPartThread& operator=( const ProductMasterPartThread& iSrc );

	//! Copy constructor
	ProductMasterPartThread( const ProductMasterPartThread& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderProductMasterPartThread" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassProductMasterPartThread;


////////////////////////////////////////////////////////////////////////////////////
//! PartUsage class
/*!
\verbatim

      A 4G Part Usage.

      Attributes:

      revision:         Inherited from ModelElement. The revision of the Part
                        Usage.
      instanceThreadRef: Inherited from ModelElement. References the Part Usage
                        Thread.
      quantity:         Inherited from ModelElement. The quantity.
      unitRef:          Inherited from ModelElement. References the Unit for the
                        quantity.
      productMasterPartThreadRef: References the Product Master Part Thread.
      
\endverbatim
*/
class PLMXML60_API PartUsage : public ModelElement
{
public:
     
    //! Default constructor
    PartUsage( );
     
    //! Constructs a PartUsage with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    PartUsage( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~PartUsage();

private:

	//! Assignment operator
	PartUsage& operator=( const PartUsage& iSrc );

	//! Copy constructor
	PartUsage( const PartUsage& original );
     
public:

	//! Get ProductMasterPartThread URI as plmxml_api::String
	plmxml_api::String GetProductMasterPartThreadURI() const;

	//! Set ProductMasterPartThread URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetProductMasterPartThreadURI( const plmxml_api::String& );
	
	//! Get the handle of ProductMasterPartThread URI. Does not resolve the URI.
	plmxml_api::Result GetProductMasterPartThreadURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of ProductMasterPartThread URI. URI string is unchanged.
	plmxml_api::Result SetProductMasterPartThreadURI( const plmxml_api::Handle& );
	
	//! Resolve ProductMasterPartThread URI and return an object (handle) it points to.
	plmxml_api::Result ResolveProductMasterPartThreadURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset ProductMasterPartThread URI. Clears URI string and handle.
	plmxml_api::Result DeleteProductMasterPartThreadURI();
	
	//! Check if ProductMasterPartThread URI is set
	plmxml_api::logical HasProductMasterPartThreadURI( ) const;
	
 
// <PLMXML_UserCode type="functionHeaderPartUsage" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassPartUsage;


////////////////////////////////////////////////////////////////////////////////////
//! PartUsageThread class
/*!
\verbatim

      A 4G Part Usage Thread.
      
\endverbatim
*/
class PLMXML60_API PartUsageThread : public InstanceThread
{
public:
     
    //! Default constructor
    PartUsageThread( );
     
    //! Constructs a PartUsageThread with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    PartUsageThread( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~PartUsageThread();

private:

	//! Assignment operator
	PartUsageThread& operator=( const PartUsageThread& iSrc );

	//! Copy constructor
	PartUsageThread( const PartUsageThread& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderPartUsageThread" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassPartUsageThread;


////////////////////////////////////////////////////////////////////////////////////
//! PartUsageAlignment class
/*!
\verbatim

      A 4G Part Usage Alignment.

      Attributes:

      revision:         The revision of the Part Usage Alignment.
      partUsageAlignmentThreadRef: References the Part Usage Alignment Thread.
      elementThreadRefs: References the InstanceThread elements representing the
                        Element Threads of the DesignElements.
      
\endverbatim
*/
class PLMXML60_API PartUsageAlignment : public Managed
{
public:
     
    //! Default constructor
    PartUsageAlignment( );
     
    //! Constructs a PartUsageAlignment with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    PartUsageAlignment( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~PartUsageAlignment();

private:

	//! Assignment operator
	PartUsageAlignment& operator=( const PartUsageAlignment& iSrc );

	//! Copy constructor
	PartUsageAlignment( const PartUsageAlignment& original );
     
public:

	//! Get Revision of this PartUsageAlignment
	plmxml_api::String GetRevision() const;

	//! Set Revision of this PartUsageAlignment
	plmxml_api::Result SetRevision( const plmxml_api::String &s );
	
	//! Check if Revision is set
	plmxml_api::logical HasRevision( ) const;
	
	//! Unset Revision
	plmxml_api::Result UnsetRevision( );

	//! Get number of URIs in ElementThread
	int NumberOfElementThreadURIs() const;

	//! Get i'th URI in ElementThread
	plmxml_api::String GetElementThreadURI( int i ) const;

	//! Add a URI to ElementThread array. Call ResolveElementThreadURI to obtain the handle pointed to by 'u'.
	plmxml_api::Result AddElementThreadURI( const plmxml_api::String& u );

	//! Set i'th URI in ElementThread array to 'u'. The array must be big enough for 'i' to be a valid index.
	plmxml_api::Result SetElementThreadURI( int i, const plmxml_api::String& u );

	//! Get the i'th handle of ElementThread URI. Does not resolve the URI.
	plmxml_api::Result GetElementThreadURI( int i, plmxml_api::Handle& ) const;
     
	//! Add a URI pointing to 'handle' to ElementThread array.
	plmxml_api::Result AddElementThreadURI( const plmxml_api::Handle& handle );

	//! Set i'th URI in ElementThread array to point to 'handle'.
	plmxml_api::Result SetElementThreadURI( int i, const plmxml_api::Handle& handle );
     
	//! Obtain the handle i'th URI in ElementThread points to.
	plmxml_api::Result ResolveElementThreadURI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );

	//! Remove i'th URI from ElementThread array.
	plmxml_api::Result DeleteElementThreadURI( int i );

	//! Remove all URIs from ElementThread array.
	plmxml_api::Result DeleteElementThreadURIs( );
	
	//! Check if ElementThread is set
	plmxml_api::logical HasElementThreadURIs( ) const;

	//! Get PartUsageAlignmentThread URI as plmxml_api::String
	plmxml_api::String GetPartUsageAlignmentThreadURI() const;

	//! Set PartUsageAlignmentThread URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetPartUsageAlignmentThreadURI( const plmxml_api::String& );
	
	//! Get the handle of PartUsageAlignmentThread URI. Does not resolve the URI.
	plmxml_api::Result GetPartUsageAlignmentThreadURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of PartUsageAlignmentThread URI. URI string is unchanged.
	plmxml_api::Result SetPartUsageAlignmentThreadURI( const plmxml_api::Handle& );
	
	//! Resolve PartUsageAlignmentThread URI and return an object (handle) it points to.
	plmxml_api::Result ResolvePartUsageAlignmentThreadURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset PartUsageAlignmentThread URI. Clears URI string and handle.
	plmxml_api::Result DeletePartUsageAlignmentThreadURI();
	
	//! Check if PartUsageAlignmentThread URI is set
	plmxml_api::logical HasPartUsageAlignmentThreadURI( ) const;
	
 
// <PLMXML_UserCode type="functionHeaderPartUsageAlignment" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassPartUsageAlignment;


////////////////////////////////////////////////////////////////////////////////////
//! PartUsageAlignmentThread class
/*!
\verbatim

      A 4G Part Usage Alignment Thread.

      Attributes:

      partUsageThreadRef: References the InstanceThread representing the Part
                        Usage Thread.
      
\endverbatim
*/
class PLMXML60_API PartUsageAlignmentThread : public InstanceThread
{
public:
     
    //! Default constructor
    PartUsageAlignmentThread( );
     
    //! Constructs a PartUsageAlignmentThread with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    PartUsageAlignmentThread( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~PartUsageAlignmentThread();

private:

	//! Assignment operator
	PartUsageAlignmentThread& operator=( const PartUsageAlignmentThread& iSrc );

	//! Copy constructor
	PartUsageAlignmentThread( const PartUsageAlignmentThread& original );
     
public:

	//! Get PartUsageThread URI as plmxml_api::String
	plmxml_api::String GetPartUsageThreadURI() const;

	//! Set PartUsageThread URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetPartUsageThreadURI( const plmxml_api::String& );
	
	//! Get the handle of PartUsageThread URI. Does not resolve the URI.
	plmxml_api::Result GetPartUsageThreadURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of PartUsageThread URI. URI string is unchanged.
	plmxml_api::Result SetPartUsageThreadURI( const plmxml_api::Handle& );
	
	//! Resolve PartUsageThread URI and return an object (handle) it points to.
	plmxml_api::Result ResolvePartUsageThreadURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset PartUsageThread URI. Clears URI string and handle.
	plmxml_api::Result DeletePartUsageThreadURI();
	
	//! Check if PartUsageThread URI is set
	plmxml_api::logical HasPartUsageThreadURI( ) const;
	
 
// <PLMXML_UserCode type="functionHeaderPartUsageAlignmentThread" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassPartUsageAlignmentThread;


////////////////////////////////////////////////////////////////////////////////////
//! PartBreakdownElement class
/*!
\verbatim

      A 4G Part Breakdown Element.

      Attributes:

      revision:         The revision of the Part Breakdown Element.
      partBreakdownElementThreadRef: References the Part Breakdown Element
                        Thread.
      quantity:         The quantity.
      unitRef:          References the Unit for the quantity.
      parentRef:        References the parent Product Master Part Thread.
      childRef:         References the child Product Master Part Thread.
      sequence:         Indicates the order of the Part Breakdown Elements (and
                        hence the children) in the context of a common parent.
      
\endverbatim
*/
class PLMXML60_API PartBreakdownElement : public Managed
{
public:
     
    //! Default constructor
    PartBreakdownElement( );
     
    //! Constructs a PartBreakdownElement with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    PartBreakdownElement( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~PartBreakdownElement();

private:

	//! Assignment operator
	PartBreakdownElement& operator=( const PartBreakdownElement& iSrc );

	//! Copy constructor
	PartBreakdownElement( const PartBreakdownElement& original );
     
public:

	//! Get Child URI as plmxml_api::String
	plmxml_api::String GetChildURI() const;

	//! Set Child URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetChildURI( const plmxml_api::String& );
	
	//! Get the handle of Child URI. Does not resolve the URI.
	plmxml_api::Result GetChildURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Child URI. URI string is unchanged.
	plmxml_api::Result SetChildURI( const plmxml_api::Handle& );
	
	//! Resolve Child URI and return an object (handle) it points to.
	plmxml_api::Result ResolveChildURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Child URI. Clears URI string and handle.
	plmxml_api::Result DeleteChildURI();
	
	//! Check if Child URI is set
	plmxml_api::logical HasChildURI( ) const;
	

	//! Set Sequence
	plmxml_api::Result SetSequence( int arg );
     
	//! Get Sequence
	int GetSequence() const;
     
	//! Check if Sequence is set
	plmxml_api::logical HasSequence() const;
     
	//! Unset Sequence
	plmxml_api::Result UnsetSequence();

	//! Get Unit URI as plmxml_api::String
	plmxml_api::String GetUnitURI() const;

	//! Set Unit URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetUnitURI( const plmxml_api::String& );
	
	//! Get the handle of Unit URI. Does not resolve the URI.
	plmxml_api::Result GetUnitURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Unit URI. URI string is unchanged.
	plmxml_api::Result SetUnitURI( const plmxml_api::Handle& );
	
	//! Resolve Unit URI and return an object (handle) it points to.
	plmxml_api::Result ResolveUnitURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Unit URI. Clears URI string and handle.
	plmxml_api::Result DeleteUnitURI();
	
	//! Check if Unit URI is set
	plmxml_api::logical HasUnitURI( ) const;
	

	//! Get PartBreakdownElementThread URI as plmxml_api::String
	plmxml_api::String GetPartBreakdownElementThreadURI() const;

	//! Set PartBreakdownElementThread URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetPartBreakdownElementThreadURI( const plmxml_api::String& );
	
	//! Get the handle of PartBreakdownElementThread URI. Does not resolve the URI.
	plmxml_api::Result GetPartBreakdownElementThreadURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of PartBreakdownElementThread URI. URI string is unchanged.
	plmxml_api::Result SetPartBreakdownElementThreadURI( const plmxml_api::Handle& );
	
	//! Resolve PartBreakdownElementThread URI and return an object (handle) it points to.
	plmxml_api::Result ResolvePartBreakdownElementThreadURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset PartBreakdownElementThread URI. Clears URI string and handle.
	plmxml_api::Result DeletePartBreakdownElementThreadURI();
	
	//! Check if PartBreakdownElementThread URI is set
	plmxml_api::logical HasPartBreakdownElementThreadURI( ) const;
	

	//! Get Revision of this PartBreakdownElement
	plmxml_api::String GetRevision() const;

	//! Set Revision of this PartBreakdownElement
	plmxml_api::Result SetRevision( const plmxml_api::String &s );
	
	//! Check if Revision is set
	plmxml_api::logical HasRevision( ) const;
	
	//! Unset Revision
	plmxml_api::Result UnsetRevision( );

	//! Get Parent URI as plmxml_api::String
	plmxml_api::String GetParentURI() const;

	//! Set Parent URI using plmxml_api::String. The handle is unchanged.
	plmxml_api::Result SetParentURI( const plmxml_api::String& );
	
	//! Get the handle of Parent URI. Does not resolve the URI.
	plmxml_api::Result GetParentURI( plmxml_api::Handle& ) const;
	
	//! Set the handle of Parent URI. URI string is unchanged.
	plmxml_api::Result SetParentURI( const plmxml_api::Handle& );
	
	//! Resolve Parent URI and return an object (handle) it points to.
	plmxml_api::Result ResolveParentURI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL );
	
	//! Reset Parent URI. Clears URI string and handle.
	plmxml_api::Result DeleteParentURI();
	
	//! Check if Parent URI is set
	plmxml_api::logical HasParentURI( ) const;
	

	//! Set Quantity
	plmxml_api::Result SetQuantity( double arg );

     //! Get Quantity
	double GetQuantity() const;

	//! Check if Quantity is set
	plmxml_api::logical HasQuantity() const;

	//! Unset Quantity
	plmxml_api::Result UnsetQuantity();
 
// <PLMXML_UserCode type="functionHeaderPartBreakdownElement" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassPartBreakdownElement;


////////////////////////////////////////////////////////////////////////////////////
//! PartBreakdownElementThread class
/*!
\verbatim

      A 4G Part Breakdown Element Thread.
      
\endverbatim
*/
class PLMXML60_API PartBreakdownElementThread : public InstanceThread
{
public:
     
    //! Default constructor
    PartBreakdownElementThread( );
     
    //! Constructs a PartBreakdownElementThread with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    PartBreakdownElementThread( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~PartBreakdownElementThread();

private:

	//! Assignment operator
	PartBreakdownElementThread& operator=( const PartBreakdownElementThread& iSrc );

	//! Copy constructor
	PartBreakdownElementThread( const PartBreakdownElementThread& original );
     
public:
 
// <PLMXML_UserCode type="functionHeaderPartBreakdownElementThread" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassPartBreakdownElementThread;


////////////////////////////////////////////////////////////////////////////////////
//! ValidationPropertyGroup class
/*!
\verbatim

      Contains properties intended to validate the contents of a document rather
      than definitive properties.
      
\endverbatim
*/
class PLMXML60_API ValidationPropertyGroup : public PropertyGroup
{
public:
     
    //! Default constructor
    ValidationPropertyGroup( );
     
    //! Constructs a ValidationPropertyGroup with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ValidationPropertyGroup( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ValidationPropertyGroup();

private:

	//! Assignment operator
	ValidationPropertyGroup& operator=( const ValidationPropertyGroup& iSrc );

	//! Copy constructor
	ValidationPropertyGroup( const ValidationPropertyGroup& original );
     
public:

	//! Get Version of this ValidationPropertyGroup
	plmxml_api::String GetVersion() const;

	//! Set Version of this ValidationPropertyGroup
	plmxml_api::Result SetVersion( const plmxml_api::String &s );
	
	//! Check if Version is set
	plmxml_api::logical HasVersion( ) const;
	
	//! Unset Version
	plmxml_api::Result UnsetVersion( );
 
// <PLMXML_UserCode type="functionHeaderValidationPropertyGroup" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassValidationPropertyGroup;


////////////////////////////////////////////////////////////////////////////////////
//! ValidationLength class
/*!
\verbatim

      Represents a length intended to validate the contents of a document rather
      than a definitive length.

      Attributes:

      validation:               The type of length that the property validates.
      
\endverbatim
*/
class PLMXML60_API ValidationLength : public LengthProperty
{
public:
     
    //! Default constructor
    ValidationLength( );
     
    //! Constructs a ValidationLength with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ValidationLength( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ValidationLength();

private:

	//! Assignment operator
	ValidationLength& operator=( const ValidationLength& iSrc );

	//! Copy constructor
	ValidationLength( const ValidationLength& original );
     
public:

	//! Set Validation
	plmxml_api::Result SetValidation( const eValidationLengthEnum& arg );

	//! Get Validation
	eValidationLengthEnum GetValidation() const;
 
// <PLMXML_UserCode type="functionHeaderValidationLength" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassValidationLength;


////////////////////////////////////////////////////////////////////////////////////
//! ValidationSurfaceArea class
/*!
\verbatim

      Represents a surface area intended to validate the contents of a document
      rather than a definitive surface area.

      Attributes:

      validation:               The type of surface area that the property
                                validates.
      
\endverbatim
*/
class PLMXML60_API ValidationSurfaceArea : public SurfaceArea
{
public:
     
    //! Default constructor
    ValidationSurfaceArea( );
     
    //! Constructs a ValidationSurfaceArea with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ValidationSurfaceArea( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ValidationSurfaceArea();

private:

	//! Assignment operator
	ValidationSurfaceArea& operator=( const ValidationSurfaceArea& iSrc );

	//! Copy constructor
	ValidationSurfaceArea( const ValidationSurfaceArea& original );
     
public:

	//! Set Validation
	plmxml_api::Result SetValidation( const eValidationSurfaceAreaEnum& arg );

	//! Get Validation
	eValidationSurfaceAreaEnum GetValidation() const;
 
// <PLMXML_UserCode type="functionHeaderValidationSurfaceArea" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassValidationSurfaceArea;


////////////////////////////////////////////////////////////////////////////////////
//! ValidationCentroid class
/*!
\verbatim

      Represents a centroid intended to validate the contents of a document
      rather than a definitive centroid.

      Attributes:

      validation:               The type of centroid that the property
                                validates.
      
\endverbatim
*/
class PLMXML60_API ValidationCentroid : public CentreOfMass
{
public:
     
    //! Default constructor
    ValidationCentroid( );
     
    //! Constructs a ValidationCentroid with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ValidationCentroid( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ValidationCentroid();

private:

	//! Assignment operator
	ValidationCentroid& operator=( const ValidationCentroid& iSrc );

	//! Copy constructor
	ValidationCentroid( const ValidationCentroid& original );
     
public:

	//! Set Validation
	plmxml_api::Result SetValidation( const eValidationCentroidEnum& arg );

	//! Get Validation
	eValidationCentroidEnum GetValidation() const;
 
// <PLMXML_UserCode type="functionHeaderValidationCentroid" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassValidationCentroid;


////////////////////////////////////////////////////////////////////////////////////
//! ValidationCount class
/*!
\verbatim

      Represents a count of objects such as annotations, curve segments or
      surface facets to validate the contents of a document.

      Attributes:

      count:                    The type of objects that the property counts.
      value:                    The validation count of objects.
      
\endverbatim
*/
class PLMXML60_API ValidationCount : public Property
{
public:
     
    //! Default constructor
    ValidationCount( );
     
    //! Constructs a ValidationCount with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ValidationCount( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ValidationCount();

private:

	//! Assignment operator
	ValidationCount& operator=( const ValidationCount& iSrc );

	//! Copy constructor
	ValidationCount( const ValidationCount& original );
     
public:

	//! Set Count
	plmxml_api::Result SetCount( const eValidationCountEnum& arg );

	//! Get Count
	eValidationCountEnum GetCount() const;

	//! Set Value
	plmxml_api::Result SetValue( int arg );
     
	//! Get Value
	int GetValue() const;
     
	//! Check if Value is set
	plmxml_api::logical HasValue() const;
     
	//! Unset Value
	plmxml_api::Result UnsetValue();
 
// <PLMXML_UserCode type="functionHeaderValidationCount" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassValidationCount;


////////////////////////////////////////////////////////////////////////////////////
//! ValidationChecksum class
/*!
\verbatim

      Represents a validation checksum of an object such as an annotation.

      Attributes:

      value:                    The validation checksum.
      
\endverbatim
*/
class PLMXML60_API ValidationChecksum : public Property
{
public:
     
    //! Default constructor
    ValidationChecksum( );
     
    //! Constructs a ValidationChecksum with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ValidationChecksum( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ValidationChecksum();

private:

	//! Assignment operator
	ValidationChecksum& operator=( const ValidationChecksum& iSrc );

	//! Copy constructor
	ValidationChecksum( const ValidationChecksum& original );
     
public:

	//! Get Value of this ValidationChecksum
	plmxml_api::String GetValue() const;

	//! Set Value of this ValidationChecksum
	plmxml_api::Result SetValue( const plmxml_api::String &s );
	
	//! Check if Value is set
	plmxml_api::logical HasValue( ) const;
	
	//! Unset Value
	plmxml_api::Result UnsetValue( );
 
// <PLMXML_UserCode type="functionHeaderValidationChecksum" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassValidationChecksum;


////////////////////////////////////////////////////////////////////////////////////
//! ValidationOrigin class
/*!
\verbatim

      Represents an origin intended to validate the contents of a document
      rather than a definitive origin.

      Attributes:

      validation:               The type of origin that the property validates.
      origin:                   The validation origin.
      
\endverbatim
*/
class PLMXML60_API ValidationOrigin : public Property
{
public:
     
    //! Default constructor
    ValidationOrigin( );
     
    //! Constructs a ValidationOrigin with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ValidationOrigin( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ValidationOrigin();

private:

	//! Assignment operator
	ValidationOrigin& operator=( const ValidationOrigin& iSrc );

	//! Copy constructor
	ValidationOrigin( const ValidationOrigin& original );
     
public:

	//! Set Validation
	plmxml_api::Result SetValidation( const eValidationOriginEnum& arg );

	//! Get Validation
	eValidationOriginEnum GetValidation() const;

	//! Set Origin using plmxml_api::Vector components
	plmxml_api::Result SetOrigin( const plmxml_api::Vector& arg );

	//! Get Origin as plmxml_api::Vector
	plmxml_api::Result GetOrigin( plmxml_api::Vector& arg ) const;

	//! Check if Origin is set
	plmxml_api::logical HasOrigin() const;

	//! Unset Origin
	plmxml_api::Result UnsetOrigin();
 
// <PLMXML_UserCode type="functionHeaderValidationOrigin" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassValidationOrigin;


////////////////////////////////////////////////////////////////////////////////////
//! ValidationPoint class
/*!
\verbatim

      Represents the mapping for a single point from the world coordinate system
      to a model view coordinate system.

      Attributes:

      from:             The coordinates of the point in the world coordinate
                        system.
      to:               The coordinates of the point in the model view
                        coordinate system.
      
\endverbatim
*/
class PLMXML60_API ValidationPoint : public Attribute
{
public:
     
    //! Default constructor
    ValidationPoint( );
     
    //! Constructs a ValidationPoint with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ValidationPoint( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ValidationPoint();

private:

	//! Assignment operator
	ValidationPoint& operator=( const ValidationPoint& iSrc );

	//! Copy constructor
	ValidationPoint( const ValidationPoint& original );
     
public:

	//! Set From using plmxml_api::Vector components
	plmxml_api::Result SetFrom( const plmxml_api::Vector& arg );

	//! Get From as plmxml_api::Vector
	plmxml_api::Result GetFrom( plmxml_api::Vector& arg ) const;

	//! Check if From is set
	plmxml_api::logical HasFrom() const;

	//! Unset From
	plmxml_api::Result UnsetFrom();

	//! Set To using plmxml_api::Vector components
	plmxml_api::Result SetTo( const plmxml_api::Vector& arg );

	//! Get To as plmxml_api::Vector
	plmxml_api::Result GetTo( plmxml_api::Vector& arg ) const;

	//! Check if To is set
	plmxml_api::logical HasTo() const;

	//! Unset To
	plmxml_api::Result UnsetTo();
 
// <PLMXML_UserCode type="functionHeaderValidationPoint" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassValidationPoint;


////////////////////////////////////////////////////////////////////////////////////
//! ValidationPointMap class
/*!
\verbatim

      Represents a map of points from the world coordinate system to a model
      view coordinate system.

      Sub-elements:

      Point:            The mapping for a single point.
      
\endverbatim
*/
class PLMXML60_API ValidationPointMap : public Property
{
public:
     
    //! Default constructor
    ValidationPointMap( );
     
    //! Constructs a ValidationPointMap with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    ValidationPointMap( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~ValidationPointMap();

private:

	//! Assignment operator
	ValidationPointMap& operator=( const ValidationPointMap& iSrc );

	//! Copy constructor
	ValidationPointMap( const ValidationPointMap& original );
     
public:

	//! Add Point child element to this ValidationPointMap. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	ValidationPoint *AddPoint();
     
	//! Add 'arg' as Point child element to this ValidationPointMap.
	plmxml_api::Result AddPoint( ValidationPoint *arg );

	//! Detach and delete all Point child elements.
	void DeletePoints();
     
	//! Get number of Point child elements.
	int NumberOfPoints() const;
     
	//! Get i'th Point child element.
	ValidationPoint *GetPoint( int i ) const;
     
	//! Get all Point child element as an array
	void GetPoints( plmxml_api::Array<ValidationPoint*> &array ) const;
	     
	//! Detach and delete i'th Point child element
	void DeletePoint( int i );
     
	//! Detach and delete 'arg' if it's one of the Point child elements
	void DeletePoint( ValidationPoint *arg );
 
// <PLMXML_UserCode type="functionHeaderValidationPointMap" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassValidationPointMap;


////////////////////////////////////////////////////////////////////////////////////
//! DeterminedPropertyGroup class
/*!
\verbatim

      A group of Property elements determined by a specific method.

      Sub-elements:

      Property:         The individual Property elements.
      
\endverbatim
*/
class PLMXML60_API DeterminedPropertyGroup : public AttribOwner
{
public:
     
    //! Default constructor
    DeterminedPropertyGroup( );
     
    //! Constructs a DeterminedPropertyGroup with the specified parent
    /*!
		If the parent of this object cannot be set a plmxml_api::Exception
		is thrown.
    */
    DeterminedPropertyGroup( plmxml_api::Object* parent );
         
    //! Destructor
    virtual ~DeterminedPropertyGroup();

private:

	//! Assignment operator
	DeterminedPropertyGroup& operator=( const DeterminedPropertyGroup& iSrc );

	//! Copy constructor
	DeterminedPropertyGroup( const DeterminedPropertyGroup& original );
     
public:

	//! Add Property child element to this DeterminedPropertyGroup. A pointer to added element is returned.
	/*!
		Returns NULL if such element already exists.
	*/
	Property *AddProperty();
     
	//! Add 'arg' as Property child element to this DeterminedPropertyGroup.
	plmxml_api::Result AddProperty( Property *arg );

	//! Detach and delete all Property child elements.
	void DeleteProperties();
     
	//! Get number of Property child elements.
	int NumberOfProperties() const;
     
	//! Get i'th Property child element.
	Property *GetProperty( int i ) const;
     
	//! Get all Property child element as an array
	void GetProperties( plmxml_api::Array<Property*> &array ) const;
	     
	//! Detach and delete i'th Property child element
	void DeleteProperty( int i );
     
	//! Detach and delete 'arg' if it's one of the Property child elements
	void DeleteProperty( Property *arg );
 
// <PLMXML_UserCode type="functionHeaderDeterminedPropertyGroup" >
     // TODO: Add extra function headers within this block
// </PLMXML_UserCode>
};
extern PLMXML60_API plmxml_api::plmxmlClass plmxmlClassDeterminedPropertyGroup;

 
// <PLMXML_UserCode type="fieldMacros" >
// these macros make the 'users' code look tidier by avoiding all those
// nasty x, x, 1 stuff:

#define PLMXML_STRING_FIELD( action, Class, name, opt ) \
	action( Class, String, name, x, x, 1, opt )

#define PLMXML_DOUBLE_FIELD( action, Class, name, opt ) \
	action( Class, Double, name, x, x, 1, opt )

#define PLMXML_INT_FIELD( action, Class, name, opt ) \
	action( Class, Int, name, x, x, 1, opt )

#define PLMXML_LOGICAL_FIELD( action, Class, name, opt ) \
	action( Class, Logical, name, x, x, 1, opt )

///////////////////

#define PLMXML_DOUBLE_ARRAY_FIELD( action, Class, name, length, opt ) \
	action( Class, MultipleDouble, name, x, x, length, opt )

#define PLMXML_INT_ARRAY_FIELD( action, Class, name, length, opt ) \
	action( Class, MultipleInt, name, x, x, length, opt )

#define PLMXML_LOGICAL_ARRAY_FIELD( action, Class, name, length, opt ) \
	action( Class, MultipleLogical, name, x, x, length, opt )

//////////////////

#define PLMXML_DOUBLE_VARIABLE_FIELD( action, Class, name, opt ) \
	action( Class, VariableDouble, name, x, x, 1, opt )

#define PLMXML_INT_VARIABLE_FIELD( action, Class, name, opt ) \
	action( Class, VariableInt, name, x, x, 1, opt )

#define PLMXML_LOGICAL_VARIABLE_FIELD( action, Class, name, opt ) \
	action( Class, VariableLogical, name, x, x, 1, opt )

//////////////////

#define PLMXML_REFERENCE_FIELD( action, Class, name, type, opt ) \
	action( Class, SingleReference, name, name##Ref, type, 1, opt )

// this one is for fields with non-standard xml attribute names
#define PLMXML_REFERENCE_FIELD_A( action, Class, name, attribname, type, opt ) \
	action( Class, SingleReference, name, attribname, type, 1, opt )

// no field name or opt
#define PLMXML_EXTERNAL_REFERENCE_FIELD( action, Class, type ) \
	action( Class, ExternalReference, x, x, type, 1, plmxmlOptional )

#define PLMXML_REFERENCE_ARRAY_FIELD( action, Class, name, type, opt ) \
	action( Class, MultipleReference, name, name##Refs, type, 1, opt )

// this one is for fields with non-standard xml attribute names
#define PLMXML_REFERENCE_ARRAY_FIELD_A( action, Class, name, attribname, type, opt ) \
	action( Class, MultipleReference, name, attribname, type, 1, opt )

///////////////////////

#define PLMXML_URI_FIELD( action, Class, name, type, opt ) \
	action( Class, SingleURI, name, name##Ref, type, 1, opt )

#define PLMXML_URI_ARRAY_FIELD( action, Class, name, type, opt ) \
	action( Class, MultipleURI, name, name##Refs, type, 1, opt )

//////////////////

#define PLMXML_ELEMENT_FIELD( action, Class, name, type ) \
	action( Class, SingleElement, name, x, type, 1, plmxmlOptional )

#define PLMXML_ELEMENT_ARRAY_FIELD( action, Class, name, nameplural, type ) \
	action( Class, MultipleElement, name, nameplural, type, 1, plmxmlOptional )

//////////////////

#define PLMXML_INTERNAL_FIELD( action, Class, name ) \
	action( Class, Internal, name, x, x, 1, plmxmlOptional )

///////////////////////////////////////////////////////////////////////////////////

// headers of field functions, goes in .h file
// Class is e.g. ProductDef
#define PLMXML_FIELD_HEADER( Class ) \
	PLMXML_##Class##_FIELDS( PLMXML_FIELD_HEADER0 )

// fieldtype is e.g. MultipleInt
// reftype is class of referenced object if any, e.g Part
// n is length if MultipleInt etc, else 1
// opt is default for XML attribute fields
#define PLMXML_FIELD_HEADER0( Class, fieldtype, fieldname, fieldnames, reftype, n, opt ) \
	PLMXML_##fieldtype##_HEADER( Class, fieldname, fieldnames, reftype, n, opt )

// implementation of field functions, goes in .cpp file
#define PLMXML_FIELD_CODE( Class ) \
	PLMXML_##Class##_FIELDS( PLMXML_FIELD_CODE0 )

#define PLMXML_FIELD_CODE0( Class, fieldtype, fieldname, fieldnames, reftype, n, opt ) \
	PLMXML_##fieldtype##_CODE( Class, fieldname, fieldnames, reftype, n, opt )

// initialisation of field data members, goes in .cpp file (constructor)
#define PLMXML_FIELD_INIT( Class ) \
	PLMXML_##Class##_FIELDS( PLMXML_FIELD_INIT0 )

#define PLMXML_FIELD_INIT0( Class, fieldtype, fieldname, fieldnames, reftype, n, opt ) \
	PLMXML_##fieldtype##_INIT( Class, fieldname, fieldnames, reftype, n, opt )

// parsing of field data members for XML attributes, goes in .cpp file
#define PLMXML_FIELD_PARSE( Class ) \
	PLMXML_##Class##_FIELDS( PLMXML_FIELD_PARSE0 )

#define PLMXML_FIELD_PARSE0( Class, fieldtype, fieldname, fieldnames, reftype, n, opt ) \
	PLMXML_##fieldtype##_PARSE( Class, fieldname, fieldnames, reftype, n, opt )

// deletion of field data members, goes in .cpp file (destructor)
#define PLMXML_FIELD_DELETE( Class ) \
	PLMXML_##Class##_FIELDS( PLMXML_FIELD_DELETE0 )

#define PLMXML_FIELD_DELETE0( Class, fieldtype, fieldname, fieldnames, reftype, n, opt ) \
	PLMXML_##fieldtype##_DELETE( Class, fieldname, fieldnames, reftype, n, opt )

// building field descriptors, goes in toolkit initialisation
#define PLMXML_FIELD_DESCRIPTOR( Class ) \
	PLMXML_##Class##_FIELDS( PLMXML_FIELD_DESCRIPTOR0 )

#define PLMXML_FIELD_DESCRIPTOR0( Class, fieldtype, fieldname, fieldnames, reftype, n, opt ) \
	PLMXML_##fieldtype##_DESCRIPTOR( Class, fieldname, fieldnames, reftype, n, opt )

// Set scanner ('code' must not contain commas)

#define all_in_set_m( set, type, item, code ) \
{ \
	int n = set.GetSize(); \
	for ( int i = 0; i < n; i++ ) \
	{ \
		type item = set[i]; \
		code; \
	} \
}

#define OffsetOfField_m( name, member ) \
	(int)(((char *) &(member)) - ((char *) this))

///////////////////////////////////////////////////////////////////////////
/////////////////////////// Internal //////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

// Internal fields are things like the Points and Normals fields in a Mesh -
// they are not represented as standard fields, but by case-by-case data
// structures. The purpose of doing it this way is to ensure that the 
// save-as-plmxml code outputs things in the correct order (derived class followed
// by base class).

#define PLMXML_Internal_HEADER( Class, name, pluralname, type, n, opt )

/////////////////////////////

#define PLMXML_Internal_INIT( Class, name, pluralname, type, n, opt )

/////////////////////////////

#define PLMXML_Internal_PARSE( Class, name, pluralname, type, n, opt )

/////////////////////////////

#define PLMXML_Internal_CODE( Class, name, pluralname, type, n, opt )

//////////////////////////////

#define PLMXML_Internal_DESCRIPTOR( Class, name, pluralname, type, n, opt ) \
	m_Class.AddFieldDescriptor( #name, NULL, \
	    plmxmlFieldInternal, plmxmlClassUnset, n, 0, opt );
	
//////////////////////////////

#define PLMXML_Internal_DELETE( Class, name, pluralname, type, n, opt )

///////////////////////////////////////////////////////////////////////////
/////////////////////////// SingleElement ////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


#define PLMXML_SingleElement_HEADER( Class, name, names, type, n, opt ) \
 \
/*!
Returns NULL if such element already exists.
*/ \
type *Add##name(); \
 \
plmxml_api::Result Set##name( type *arg ); \
 \
type *Get##name() const; \
 \
void Delete##name(); \
//////////////////////////////////////////////////

#define PLMXML_SingleElement_INIT( Class, name, names, type, n, opt ) \
 \
//////////////////////////////////////////////////

#define PLMXML_SingleElement_CODE( Class, name, names, type, n, opt ) \
type *Class::Add##name() \
{ \
	if ( Object::HasField( #name, PLMXML_FIELD_ELEMENT ) ) \
return NULL; \
else \
{ \
static plmxml_api::String clazz( #type ); \
Object* pObject = NULL; \
Object::AddElement( clazz, #name, pObject ); \
 \
return (type*)pObject; \
} \
} \
plmxml_api::Result Class::Set##name( type *arg ) \
{ \
if ( arg != NULL ) \
return arg->SetOwner( this, #name ); \
else \
return plmxml_api::Result( plmxml_api::ErrorCodeFailed ); \
} \
type *Class::Get##name() const \
{ \
plmxml_api::Array<Object*> childElements; \
childElements.RemoveAll( ); \
 \
Object::GetElementsByField( #name, childElements ); \
 \
if ( childElements.GetSize( ) < 1 ) \
return NULL; \
else \
return (type*)childElements[ 0 ]; \
} \
void Class::Delete##name() \
{ \
Object::DeleteElementsByField( #name ); \
} \
//////////////////////////////////////////////////

#define PLMXML_SingleElement_DELETE( Class, name, names, type, n, opt ) \
 \
//////////////////////////////////////////////////

#define PLMXML_SingleElement_DESCRIPTOR( Class, name, names, type, n, opt ) \
 \
pDescriptor->RegisterField( #name, plmxml_api::plmxmlFieldSingleElement ); \
pDescriptor->SetFieldClass( #name, #type, TRUE ); \
//////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
/////////////////////////// SingleReference ////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


#define PLMXML_SingleReference_HEADER( Class, name, names, type, n, opt ) \
 \
/*!
Returns FALSE if 'arg's Id is unset otherwise TRUE.
*/ \
plmxml_api::logical Set##name##Ref( plmxml60::IdObject *arg ); \
 \
void Remove##name##Ref( ); \
 \
plmxml60::IdObject *Resolve##name##Ref( plmxml_api::Configuration* config = NULL ); \
 \
plmxml_api::String Get##name##Id() const; \
 \
/*!
Returns FALSE if input String is empty otherwise TRUE.
*/ \
plmxml_api::logical Set##name##Id( const plmxml_api::String& u ); \
 \
plmxml_api::logical Has##name##Ref( ) const; \
//////////////////////////////////////////////////

#define PLMXML_SingleReference_INIT( Class, name, names, type, n, opt ) \
 \
//////////////////////////////////////////////////

#define PLMXML_SingleReference_CODE( Class, name, names, type, n, opt ) \
plmxml60::IdObject *Class::Resolve##name##Ref( plmxml_api::Configuration* config ) \
{ \
plmxml_api::Array<plmxml_api::Reference> resolvedHandles; \
 \
if ( Object::ResolveAttributeValue( #names, resolvedHandles, config ).Ok( ) \
&& resolvedHandles.GetSize() > 0 ) \
return (plmxml60::IdObject*)resolvedHandles[0].GetHandle( ).GetObject( ); \
else \
return NULL; \
} \
plmxml_api::logical Class::Set##name##Ref( plmxml60::IdObject *arg ) \
{ \
if ( arg == NULL ) \
{ \
Remove##name##Ref( ); \
return TRUE; \
} \
else \
return Object::SetAttributeValue( #names, plmxml_api::Reference( arg ) ).Ok( ); \
} \
void Class::Remove##name##Ref( ) \
{ \
Object::ResetAttributeValue( #names ); \
} \
plmxml_api::String Class::Get##name##Id() const \
{ \
plmxml_api::Reference value; \
Object::GetAttributeValue( #names, value ); \
 \
return value.GetString( ); \
} \
plmxml_api::logical Class::Set##name##Id( const plmxml_api::String& u ) \
{ \
return Object::SetAttributeValue( #names, u ).Ok( ); \
} \
plmxml_api::logical Class::Has##name##Ref( ) const \
{ \
return Object::HasField( #names, PLMXML_FIELD_ATTRIBUTE ); \
} \
//////////////////////////////////////////////////

#define PLMXML_SingleReference_DELETE( Class, name, names, type, n, opt ) \
 \
//////////////////////////////////////////////////

#define PLMXML_SingleReference_DESCRIPTOR( Class, name, names, type, n, opt ) \
 \
pDescriptor->RegisterField( #names, plmxml_api::plmxmlFieldSingleReference ); \
pDescriptor->SetFieldClass( #names, #type ); \
//////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
/////////////////////////// MultipleURI ////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


#define PLMXML_MultipleURI_HEADER( Class, name, names, type, n, opt ) \
 \
int NumberOf##name##URIs() const; \
 \
plmxml_api::String Get##name##URI( int i ) const; \
 \
plmxml_api::Result Add##name##URI( const plmxml_api::String& u ); \
 \
plmxml_api::Result Set##name##URI( int i, const plmxml_api::String& u ); \
 \
plmxml_api::Result Get##name##URI( int i, plmxml_api::Handle& ) const; \
 \
plmxml_api::Result Add##name##URI( const plmxml_api::Handle& handle ); \
 \
plmxml_api::Result Set##name##URI( int i, const plmxml_api::Handle& handle ); \
 \
plmxml_api::Result Resolve##name##URI( int i, plmxml_api::Handle&, plmxml_api::Configuration* config = NULL ); \
 \
plmxml_api::Result Delete##name##URI( int i ); \
 \
plmxml_api::Result Delete##name##URIs( ); \
 \
plmxml_api::logical Has##name##URIs( ) const; \
//////////////////////////////////////////////////

#define PLMXML_MultipleURI_INIT( Class, name, names, type, n, opt ) \
 \
//////////////////////////////////////////////////

#define PLMXML_MultipleURI_CODE( Class, name, names, type, n, opt ) \
int Class::NumberOf##name##URIs() const \
{ \
plmxml_api::Array<plmxml_api::Reference> refs; \
Object::GetAttributeValue( #names, refs ); \
 \
return refs.GetSize( ); \
} \
plmxml_api::String Class::Get##name##URI( int i ) const \
{ \
if ( i < 0 ) \
throw plmxml_api::Exception( plmxml_api::ErrorCodeInvalidIndex ); \
 \
plmxml_api::Array<plmxml_api::Reference> refs; \
Object::GetAttributeValue( #names, refs ); \
 \
if ( i <refs.GetSize( ) ) \
return refs[ i ].GetString( ); \
else \
throw plmxml_api::Exception( plmxml_api::ErrorCodeInvalidIndex ); \
} \
plmxml_api::Result Class::Add##name##URI( const plmxml_api::String &u ) \
{ \
plmxml_api::Result result; \
plmxml_api::Array<plmxml_api::Reference> refs; \
result = Object::GetAttributeValue( #names, refs ); \
if ( result.Ok( ) ) \
{ \
refs.Add( plmxml_api::Reference( u ) ); \
result = Object::SetAttributeValue( #names, refs ); \
} \
return result; \
} \
plmxml_api::Result Class::Set##name##URI( int i, const plmxml_api::String &u ) \
{ \
plmxml_api::Array<plmxml_api::Reference> refs; \
plmxml_api::Result result = Object::GetAttributeValue( #names, refs ); \
 \
if ( i >= 0 && i <refs.GetSize( ) ) \
{ \
refs[ i ].SetString( u ); \
result = Object::SetAttributeValue( #names, refs ); \
} \
else \
result.AddError( plmxml_api::ErrorCodeInvalidIndex ); \
 \
return result; \
} \
plmxml_api::Result Class::Get##name##URI( int i, plmxml_api::Handle& h ) const \
{ \
plmxml_api::Array<plmxml_api::Reference> refs; \
plmxml_api::Result result = Object::GetAttributeValue( #names, refs ); \
 \
if ( i >= 0 && i <refs.GetSize( ) ) \
h = refs[ i ].GetHandle(); \
else \
result.AddError( plmxml_api::ErrorCodeInvalidIndex ); \
 \
return result; \
} \
plmxml_api::Result Class::Add##name##URI( const plmxml_api::Handle& h ) \
{ \
plmxml_api::Array<plmxml_api::Reference> refs; \
plmxml_api::Result result = Object::GetAttributeValue( #names, refs ); \
 \
refs.Add( plmxml_api::Reference( h ) ); \
 \
result.Merge( Object::SetAttributeValue( #names, refs ) ); \
return result; \
} \
plmxml_api::Result Class::Set##name##URI( int i, const plmxml_api::Handle& h ) \
{ \
plmxml_api::Array<plmxml_api::Reference> refs; \
plmxml_api::Result result = Object::GetAttributeValue( #names, refs ); \
 \
if ( i >= 0 && i <refs.GetSize( ) ) \
{ \
refs[i] = plmxml_api::Reference( h ); \
result = Object::SetAttributeValue( #names, refs ); \
} \
else \
result.AddError( plmxml_api::ErrorCodeInvalidIndex ); \
 \
return result; \
} \
plmxml_api::Result Class::Resolve##name##URI( int i, plmxml_api::Handle& h, plmxml_api::Configuration* config ) \
{ \
plmxml_api::Array<plmxml_api::Reference> refs; \
plmxml_api::Result result = Object::ResolveAttributeValue( #names, refs, config ); \
if ( result.HasError( ) ) \
return result; \
 \
if ( i >= 0 && i <refs.GetSize( ) ) \
h = refs[i].GetHandle( ); \
else \
result.AddError( plmxml_api::ErrorCodeInvalidIndex ); \
 \
return result; \
} \
plmxml_api::Result Class::Delete##name##URI( int i ) \
{ \
plmxml_api::Array<plmxml_api::Reference> refs; \
plmxml_api::Result result = Object::GetAttributeValue( #names, refs ); \
 \
if ( i >= 0 && i <refs.GetSize( ) ) \
{ \
refs.RemoveAt( i ); \
result = Object::SetAttributeValue( #names, refs ); \
} \
else \
result.AddError( plmxml_api::ErrorCodeInvalidIndex ); \
 \
return result; \
} \
plmxml_api::Result Class::Delete##name##URIs( ) \
{ \
return Object::ResetAttributeValue( #names ); \
} \
plmxml_api::logical Class::Has##name##URIs( ) const \
{ \
return Object::HasField( #names, PLMXML_FIELD_ATTRIBUTE ); \
} \
//////////////////////////////////////////////////

#define PLMXML_MultipleURI_DELETE( Class, name, names, type, n, opt ) \
 \
//////////////////////////////////////////////////

#define PLMXML_MultipleURI_DESCRIPTOR( Class, name, names, type, n, opt ) \
 \
pDescriptor->RegisterField( #names, plmxml_api::plmxmlFieldMultipleURI ); \
//////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
/////////////////////////// MultipleDouble ////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


#define PLMXML_MultipleDouble_HEADER( Class, name, names, type, n, opt ) \
 \
plmxml_api::Result Set##name( const double *arg ); \
 \
plmxml_api::Result Get##name( double *arg ) const; \
 \
plmxml_api::logical Has##name() const; \
 \
plmxml_api::Result Unset##name(); \
//////////////////////////////////////////////////

#define PLMXML_MultipleDouble_INIT( Class, name, names, type, n, opt ) \
 \
//////////////////////////////////////////////////

#define PLMXML_MultipleDouble_CODE( Class, name, names, type, n, opt ) \
plmxml_api::Result Class::Set##name( const double *arg ) \
{ \
plmxml_api::Array<double> value( n ); \
 \
value.RemoveAll( ); \
value.Add( n, arg ); \
 \
return Object::SetAttributeValue( #name, value ); \
} \
plmxml_api::Result Class::Get##name( double *arg ) const \
{ \
plmxml_api::Array<double> value; \
value.RemoveAll( ); \
 \
plmxml_api::Result result = Object::GetAttributeValue( #name, value ); \
if ( result.Ok( ) ) \
memcpy( arg, value.GetData(), sizeof(double)*value.GetSize( ) ); \
return result; \
} \
plmxml_api::logical Class::Has##name() const \
{ \
return Object::HasField( #name, PLMXML_FIELD_ATTRIBUTE ); \
} \
plmxml_api::Result Class::Unset##name() \
{ \
return Object::ResetAttributeValue( #name ); \
} \
//////////////////////////////////////////////////

#define PLMXML_MultipleDouble_DELETE( Class, name, names, type, n, opt ) \
 \
//////////////////////////////////////////////////

#define PLMXML_MultipleDouble_DESCRIPTOR( Class, name, names, type, n, opt ) \
 \
pDescriptor->RegisterField( #name, plmxml_api::plmxmlFieldDouble ); \
pDescriptor->SetFieldLength( #name, n ); \
//////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
/////////////////////////// Enum ////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


#define PLMXML_Enum_HEADER( enumtype, Class, name, names, type, n, opt ) \
 \
plmxml_api::Result Set##name( const e##enumtype& arg ); \
 \
e##enumtype Get##name() const; \
//////////////////////////////////////////////////

#define PLMXML_Enum_INIT( enumtype, Class, name, names, type, n, opt ) \
 \
//////////////////////////////////////////////////

#define PLMXML_Enum_CODE( enumtype, Class, name, names, type, n, opt ) \
plmxml_api::Result Class::Set##name( const e##enumtype& arg ) \
{ \
return Object::SetAttributeValue( #name, arg.ToString( ) ); \
} \
e##enumtype Class::Get##name() const \
{ \
plmxml_api::String value; \
value.Empty( ); \
 \
Object::GetAttributeValue( #name, value ); \
 \
return e##enumtype( value ); \
} \
 \
//////////////////////////////////////////////////

#define PLMXML_Enum_DELETE( enumtype, Class, name, names, type, n, opt ) \
 \
//////////////////////////////////////////////////

#define PLMXML_Enum_DESCRIPTOR( enumtype, Class, name, names, type, n, opt ) \
	PLMXML_Enum_DESCRIPTOR_2( enumtype, Class, name, names, type, n, opt, NULL )

#define PLMXML_Enum_DESCRIPTOR_2( enumtype, Class, name, names, type, n, opt, enumvalues ) \
 \
pDescriptor->RegisterField( #name, plmxmlFieldEnum##enumtype ); \
pDescriptor->SetFieldClass( #name, #enumtype ); \
const char* _e##name[] = { \
"unset",enumvalues, \
NULL \
}; \
pDescriptor->SetFieldAllowedValues( #name, _e##name ); \
//////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
/////////////////////////// ExternalReference ////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


#define PLMXML_ExternalReference_HEADER( Class, name, names, type, n, opt ) \
 \
plmxml_api::String GetExternalRefURI() const; \
 \
plmxml_api::logical GetExternalRefLoad() const; \
 \
void SetExternalRefLoad( plmxml_api::logical load ); \
 \
plmxml_api::Result SetExternalRefURI( const plmxml_api::String& u ); \
 \
plmxml_api::Result SetExternalRef( const plmxml_api::Handle& handle ); \
 \
plmxml_api::Result SetExternalRef( const plmxml_api::Array<plmxml_api::Handle>& handles ); \
 \
plmxml_api::Result GetExternalRef( plmxml_api::Array<plmxml_api::Handle>& handles ) const; \
 \
plmxml_api::Result ResolveExternalRef( plmxml_api::Array<plmxml_api::Handle>&, plmxml_api::Configuration* config = NULL ); \
 \
plmxml_api::Result DeleteExternalRef(); \
 \
plmxml_api::logical HasExternalRefURI( ) const; \
//////////////////////////////////////////////////

#define PLMXML_ExternalReference_INIT( Class, name, names, type, n, opt ) \
 \
//////////////////////////////////////////////////

#define PLMXML_ExternalReference_CODE( Class, name, names, type, n, opt ) \
plmxml_api::String Class::GetExternalRefURI() const \
{ \
plmxml_api::String value; \
Object::GetAttributeValue( "location", value ); \
return value; \
} \
plmxml_api::logical Class::GetExternalRefLoad() const \
{ \
plmxml_api::logical value = FALSE; \
Object::GetAttributeValue( "load", value ); \
return value; \
} \
void Class::SetExternalRefLoad( plmxml_api::logical l ) \
{ \
Object::SetAttributeValue( "load", l ); \
} \
plmxml_api::Result Class::SetExternalRefURI( const plmxml_api::String &u ) \
{ \
return Object::SetAttributeValue( "location", u ); \
} \
plmxml_api::Result Class::SetExternalRef( const plmxml_api::Handle& handle ) \
{ \
return Object::SetAttributeValue( "location", plmxml_api::Reference( handle ) ); \
} \
plmxml_api::Result Class::SetExternalRef( const plmxml_api::Array<plmxml_api::Handle>& handles ) \
{ \
return Object::SetAttributeValue( "location", plmxml_api::Reference( handles ) ); \
} \
plmxml_api::Result Class::GetExternalRef( plmxml_api::Array<plmxml_api::Handle>& handles ) const \
{ \
plmxml_api::Reference ref; \
plmxml_api::Result result = Object::GetAttributeValue( "location", ref ); \
const plmxml_api::Array<plmxml_api::Handle>& _handles = ref.GetHandles( ); \
for ( int i = 0; i < _handles.GetSize( ); i++ ) \
handles.Add( _handles[ i ] ); \
return result; \
} \
plmxml_api::Result Class::DeleteExternalRef() \
{ \
return Object::ResetAttributeValue( "location" ); \
} \
plmxml_api::Result Class::ResolveExternalRef( plmxml_api::Array<plmxml_api::Handle>& handles, plmxml_api::Configuration* config ) \
{ \
plmxml_api::Reference ref; \
plmxml_api::Result result = Object::ResolveAttributeValue( "location", ref, config ); \
const plmxml_api::Array<plmxml_api::Handle>& _handles = ref.GetHandles( ); \
for ( int i = 0; i < _handles.GetSize( ); i++ ) \
handles.Add( _handles[ i ] ); \
return result; \
} \
plmxml_api::logical Class::HasExternalRefURI( ) const \
{ \
return Object::HasField( "location", PLMXML_FIELD_ATTRIBUTE ); \
} \
//////////////////////////////////////////////////

#define PLMXML_ExternalReference_DELETE( Class, name, names, type, n, opt ) \
 \
//////////////////////////////////////////////////

#define PLMXML_ExternalReference_DESCRIPTOR( Class, name, names, type, n, opt ) \
 \
pDescriptor->RegisterField( "location", plmxml_api::plmxmlFieldExternalReference ); \
pDescriptor->SetFieldClass( #name, "IdObject" ); \
pDescriptor->RegisterField( "load", plmxml_api::plmxmlFieldExternalReference ); \
pDescriptor->SetFieldClass( #name, "IdObject" ); \
//////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
/////////////////////////// MultipleElement ////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


#define PLMXML_MultipleElement_HEADER( Class, name, pluralname, type, n, opt ) \
 \
/*!
Returns NULL if such element already exists.
*/ \
type *Add##name(); \
 \
plmxml_api::Result Add##name( type *arg ); \
 \
void Delete##pluralname(); \
 \
int NumberOf##pluralname() const; \
 \
type *Get##name( int i ) const; \
 \
void Get##pluralname( plmxml_api::Array<type*> &array ) const; \
 \
void Delete##name( int i ); \
 \
void Delete##name( type *arg ); \
//////////////////////////////////////////////////

#define PLMXML_MultipleElement_INIT( Class, name, pluralname, type, n, opt ) \
 \
//////////////////////////////////////////////////

#define PLMXML_MultipleElement_CODE( Class, name, pluralname, type, n, opt ) \
type *Class::Add##name() \
{ \
Object* pObject = NULL; \
plmxml_api::String field1( #type ); \
 \
Object::AddElement( field1, #name, pObject ); \
 \
return (type*)pObject; \
} \
plmxml_api::Result Class::Add##name( type *arg ) \
{ \
if ( arg != NULL ) \
return arg->SetOwner( this, #name ); \
else \
return plmxml_api::Result( plmxml_api::ErrorCodeFailed ); \
} \
void Class::Get##pluralname( plmxml_api::Array<type*> &array ) const \
{ \
array.RemoveAll(); \
 \
plmxml_api::Array<Object*> values; \
values.RemoveAll( ); \
 \
Object::GetElementsByField( #name, values ); \
array.Add( values.GetSize(), (type**)values.GetData() ); \
} \
void Class::Delete##pluralname() \
{ \
Object::DeleteElementsByField( #name ); \
} \
void Class::Delete##name( type *arg ) \
{ \
Object::DeleteElement( arg ); \
} \
int Class::NumberOf##pluralname() const \
{ \
plmxml_api::Array<Object*> values; \
values.RemoveAll( ); \
 \
Object::GetElementsByField( #name, values ); \
 \
return values.GetSize( ); \
} \
type *Class::Get##name( int i ) const \
{ \
plmxml_api::Array<Object*> values; \
values.RemoveAll( ); \
 \
Object::GetElementsByField( #name, values ); \
if ( i >= 0 && i < values.GetSize( ) ) \
return (type*)values[i]; \
else \
return NULL; \
} \
void Class::Delete##name( int i ) \
{ \
plmxml_api::Array<Object*> values; \
values.RemoveAll( ); \
 \
Object::GetElementsByField( #name, values ); \
if ( i >= 0 && i < values.GetSize( ) ) \
Object::DeleteElement( values[i] ); \
else \
throw plmxml_api::Exception( plmxml_api::ErrorCodeInvalidIndex ); \
} \
//////////////////////////////////////////////////

#define PLMXML_MultipleElement_DELETE( Class, name, pluralname, type, n, opt ) \
 \
//////////////////////////////////////////////////

#define PLMXML_MultipleElement_DESCRIPTOR( Class, name, pluralname, type, n, opt ) \
 \
pDescriptor->RegisterField( #name, plmxml_api::plmxmlFieldMultipleElement ); \
pDescriptor->SetFieldClass( #name, #type, TRUE ); \
//////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
/////////////////////////// Double ////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


#define PLMXML_Double_HEADER( Class, name, names, type, n, opt ) \
 \
plmxml_api::Result Set##name( double arg ); \
 \
double Get##name() const; \
 \
plmxml_api::logical Has##name() const; \
 \
plmxml_api::Result Unset##name(); \
//////////////////////////////////////////////////

#define PLMXML_Double_INIT( Class, name, names, type, n, opt ) \
 \
//////////////////////////////////////////////////

#define PLMXML_Double_CODE( Class, name, names, type, n, opt ) \
plmxml_api::Result Class::Set##name( double arg ) \
{ \
return Object::SetAttributeValue( #name, arg ); \
} \
double Class::Get##name() const \
{ \
double value = 0.0; \
Object::GetAttributeValue( #name, value ); \
 \
return value; \
} \
plmxml_api::logical Class::Has##name() const \
{ \
return Object::HasField( #name, PLMXML_FIELD_ATTRIBUTE ); \
} \
plmxml_api::Result Class::Unset##name() \
{ \
return Object::ResetAttributeValue( #name ); \
} \
//////////////////////////////////////////////////

#define PLMXML_Double_DELETE( Class, name, names, type, n, opt ) \
 \
//////////////////////////////////////////////////

#define PLMXML_Double_DESCRIPTOR( Class, name, names, type, n, opt ) \
 \
pDescriptor->RegisterField( #name, plmxml_api::plmxmlFieldDouble ); \
//////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
/////////////////////////// SingleURI ////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


#define PLMXML_SingleURI_HEADER( Class, name, names, type, n, opt ) \
 \
plmxml_api::String Get##name##URI() const; \
 \
plmxml_api::Result Set##name##URI( const plmxml_api::String& ); \
 \
plmxml_api::Result Get##name##URI( plmxml_api::Handle& ) const; \
 \
plmxml_api::Result Set##name##URI( const plmxml_api::Handle& ); \
 \
plmxml_api::Result Resolve##name##URI( plmxml_api::Handle&, plmxml_api::Configuration* config = NULL ); \
 \
plmxml_api::Result Delete##name##URI(); \
 \
plmxml_api::logical Has##name##URI( ) const; \
 \
//////////////////////////////////////////////////

#define PLMXML_SingleURI_INIT( Class, name, names, type, n, opt ) \
 \
//////////////////////////////////////////////////

#define PLMXML_SingleURI_CODE( Class, name, names, type, n, opt ) \
plmxml_api::String Class::Get##name##URI() const \
{ \
plmxml_api::String value; \
if ( Object::GetAttributeValue( #names, value ).HasError( ) ) \
return plmxml_api::String::EmptyString( ); \
else \
return value; \
} \
plmxml_api::Result Class::Set##name##URI( const plmxml_api::String &u ) \
{ \
return Object::SetAttributeValue( #names, u ); \
} \
plmxml_api::Result Class::Get##name##URI( plmxml_api::Handle& h ) const \
{ \
plmxml_api::Reference ref; \
plmxml_api::Result result = Object::GetAttributeValue( #names, ref ); \
h = ref.GetHandle(); \
return result; \
} \
plmxml_api::Result Class::Set##name##URI( const plmxml_api::Handle& h ) \
{ \
return Object::SetAttributeValue( #names, plmxml_api::Reference( h ) ); \
} \
plmxml_api::Result Class::Resolve##name##URI( plmxml_api::Handle &h, plmxml_api::Configuration* config ) \
{ \
plmxml_api::Reference ref; \
plmxml_api::Result result = Object::ResolveAttributeValue( #names, ref, config ); \
h = ref.GetHandle(); \
return result; \
} \
plmxml_api::Result Class::Delete##name##URI( ) \
{ \
return Object::ResetAttributeValue( #names ); \
} \
plmxml_api::logical Class::Has##name##URI( ) const \
{ \
return Object::HasField( #names, PLMXML_FIELD_ATTRIBUTE ); \
} \
//////////////////////////////////////////////////

#define PLMXML_SingleURI_DELETE( Class, name, names, type, n, opt ) \
 \
//////////////////////////////////////////////////

#define PLMXML_SingleURI_DESCRIPTOR( Class, name, names, type, n, opt ) \
 \
pDescriptor->RegisterField( #names, plmxml_api::plmxmlFieldSingleURI ); \
//////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
/////////////////////////// String ////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


#define PLMXML_String_HEADER( Class, name, names, type, n, opt ) \
 \
plmxml_api::String Get##name() const; \
 \
plmxml_api::Result Set##name( const plmxml_api::String &s ); \
 \
plmxml_api::logical Has##name( ) const; \
 \
plmxml_api::Result Unset##name( ); \
//////////////////////////////////////////////////

#define PLMXML_String_INIT( Class, name, names, type, n, opt ) \
 \
//////////////////////////////////////////////////

#define PLMXML_String_CODE( Class, name, names, type, n, opt ) \
plmxml_api::String Class::Get##name() const \
{ \
plmxml_api::String value; \
if ( Object::GetAttributeValue( #name, value ).HasError( ) ) \
return plmxml_api::String::EmptyString( ); \
else \
return value; \
} \
plmxml_api::Result Class::Set##name( const plmxml_api::String &s ) \
{ \
return Object::SetAttributeValue( #name, s ); \
} \
plmxml_api::logical Class::Has##name( ) const \
{ \
return Object::HasField( #name, PLMXML_FIELD_ATTRIBUTE ); \
} \
plmxml_api::Result Class::Unset##name( ) \
{ \
return Object::ResetAttributeValue( #name ); \
} \
//////////////////////////////////////////////////

#define PLMXML_String_DELETE( Class, name, names, type, n, opt ) \
 \
//////////////////////////////////////////////////

#define PLMXML_String_DESCRIPTOR( Class, name, names, type, n, opt ) \
 \
pDescriptor->RegisterField( #name, plmxml_api::plmxmlFieldString ); \
 \
//////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
/////////////////////////// VariableInt ////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


#define PLMXML_VariableInt_HEADER( Class, name, names, type, n, opt ) \
 \
plmxml_api::Result Set##name( const plmxml_api::Array<int>& arg ); \
 \
plmxml_api::Result Get##name( plmxml_api::Array<int>& arg ) const; \
 \
plmxml_api::logical Has##name() const; \
 \
plmxml_api::Result Unset##name(); \
//////////////////////////////////////////////////

#define PLMXML_VariableInt_INIT( Class, name, names, type, n, opt ) \
 \
//////////////////////////////////////////////////

#define PLMXML_VariableInt_CODE( Class, name, names, type, n, opt ) \
plmxml_api::Result Class::Set##name( const plmxml_api::Array<int>& arg ) \
{ \
return Object::SetAttributeValue( #name, arg ); \
} \
plmxml_api::Result Class::Get##name( plmxml_api::Array<int>& arg ) const \
{ \
return Object::GetAttributeValue( #name, arg ); \
} \
plmxml_api::logical Class::Has##name() const \
{ \
return Object::HasField( #name, PLMXML_FIELD_ATTRIBUTE ); \
} \
plmxml_api::Result Class::Unset##name() \
{ \
return Object::ResetAttributeValue( #name ); \
} \
//////////////////////////////////////////////////

#define PLMXML_VariableInt_DELETE( Class, name, names, type, n, opt ) \
 \
//////////////////////////////////////////////////

#define PLMXML_VariableInt_DESCRIPTOR( Class, name, names, type, n, opt ) \
 \
pDescriptor->RegisterField( #name, plmxml_api::plmxmlFieldInt ); \
pDescriptor->SetFieldLength( #name, n ); \
//////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
/////////////////////////// VariableDouble ////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


#define PLMXML_VariableDouble_HEADER( Class, name, names, type, n, opt ) \
 \
plmxml_api::Result Set##name( const plmxml_api::Array<double>& arg ); \
 \
plmxml_api::Result Get##name( plmxml_api::Array<double>& arg ) const; \
 \
plmxml_api::logical Has##name() const; \
 \
plmxml_api::Result Unset##name(); \
//////////////////////////////////////////////////

#define PLMXML_VariableDouble_INIT( Class, name, names, type, n, opt ) \
 \
//////////////////////////////////////////////////

#define PLMXML_VariableDouble_CODE( Class, name, names, type, n, opt ) \
plmxml_api::Result Class::Set##name( const plmxml_api::Array<double>& arg ) \
{ \
return Object::SetAttributeValue( #name, arg ); \
} \
plmxml_api::Result Class::Get##name( plmxml_api::Array<double>& arg ) const \
{ \
return Object::GetAttributeValue( #name, arg ); \
} \
plmxml_api::logical Class::Has##name() const \
{ \
return Object::HasField( #name, PLMXML_FIELD_ATTRIBUTE ); \
} \
plmxml_api::Result Class::Unset##name() \
{ \
return Object::ResetAttributeValue( #name ); \
} \
//////////////////////////////////////////////////

#define PLMXML_VariableDouble_DELETE( Class, name, names, type, n, opt ) \
 \
//////////////////////////////////////////////////

#define PLMXML_VariableDouble_DESCRIPTOR( Class, name, names, type, n, opt ) \
 \
pDescriptor->RegisterField( #name, plmxml_api::plmxmlFieldDouble ); \
pDescriptor->SetFieldLength( #name, n ); \
//////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
/////////////////////////// MultipleLogical ////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


#define PLMXML_MultipleLogical_HEADER( Class, name, names, type, n, opt ) \
 \
plmxml_api::Result Set##name( const plmxml_api::logical *arg ); \
 \
plmxml_api::Result Get##name( plmxml_api::logical *arg ) const; \
 \
plmxml_api::logical Has##name() const; \
 \
plmxml_api::Result Unset##name(); \
//////////////////////////////////////////////////

#define PLMXML_MultipleLogical_INIT( Class, name, names, type, n, opt ) \
 \
//////////////////////////////////////////////////

#define PLMXML_MultipleLogical_CODE( Class, name, names, type, n, opt ) \
plmxml_api::Result Class::Set##name( const plmxml_api::logical *arg ) \
{ \
plmxml_api::Array<plmxml_api::logical> value( n ); \
value.RemoveAll( ); \
value.Add( n, arg ); \
 \
return Object::SetAttributeValue( #name, value ); \
} \
plmxml_api::Result Class::Get##name( plmxml_api::logical *arg ) const \
{ \
static plmxml_api::Array<plmxml_api::logical> value; \
value.RemoveAll( ); \
 \
plmxml_api::Result result = Object::GetAttributeValue( #name, value ); \
if ( result.Ok( ) ) \
memcpy( arg, value.GetData( ), sizeof(plmxml_api::logical) * value.GetSize( ) ); \
return result; \
} \
plmxml_api::logical Class::Has##name() const \
{ \
return Object::HasField( #name, PLMXML_FIELD_ATTRIBUTE ); \
} \
plmxml_api::Result Class::Unset##name() \
{ \
return Object::ResetAttributeValue( #name ); \
} \
//////////////////////////////////////////////////

#define PLMXML_MultipleLogical_DELETE( Class, name, names, type, n, opt ) \
 \
//////////////////////////////////////////////////

#define PLMXML_MultipleLogical_DESCRIPTOR( Class, name, names, type, n, opt ) \
 \
pDescriptor->RegisterField( #name, plmxml_api::plmxmlFieldLogical ); \
pDescriptor->SetFieldLength( #name, n ); \
//////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
/////////////////////////// MultipleInt ////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


#define PLMXML_MultipleInt_HEADER( Class, name, names, type, n, opt ) \
 \
plmxml_api::Result Set##name( const int *arg ); \
 \
plmxml_api::Result Get##name( int *arg ) const; \
 \
plmxml_api::logical Has##name() const; \
 \
plmxml_api::Result Unset##name(); \
//////////////////////////////////////////////////

#define PLMXML_MultipleInt_INIT( Class, name, names, type, n, opt ) \
 \
//////////////////////////////////////////////////

#define PLMXML_MultipleInt_CODE( Class, name, names, type, n, opt ) \
plmxml_api::Result Class::Set##name( const int *arg ) \
{ \
plmxml_api::Array<int> value( n ); \
value.RemoveAll( ); \
value.Add( n, arg ); \
 \
return Object::SetAttributeValue( #name, value ); \
} \
plmxml_api::Result Class::Get##name( int *arg ) const \
{ \
static plmxml_api::Array<int> value; \
value.RemoveAll( ); \
 \
plmxml_api::Result result = Object::GetAttributeValue( #name, value ); \
if ( result.Ok( ) ) \
memcpy( arg, value.GetData( ), sizeof(int)*value.GetSize( ) ); \
return result; \
} \
plmxml_api::logical Class::Has##name() const \
{ \
return Object::HasField( #name, PLMXML_FIELD_ATTRIBUTE ); \
} \
plmxml_api::Result Class::Unset##name() \
{ \
return Object::ResetAttributeValue( #name ); \
} \
//////////////////////////////////////////////////

#define PLMXML_MultipleInt_DELETE( Class, name, names, type, n, opt ) \
 \
//////////////////////////////////////////////////

#define PLMXML_MultipleInt_DESCRIPTOR( Class, name, names, type, n, opt ) \
 \
pDescriptor->RegisterField( #name, plmxml_api::plmxmlFieldInt ); \
pDescriptor->SetFieldLength( #name, n ); \
//////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
/////////////////////////// Logical ////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


#define PLMXML_Logical_HEADER( Class, name, names, type, n, opt ) \
 \
plmxml_api::Result Set##name( plmxml_api::logical arg ); \
 \
plmxml_api::logical Get##name() const; \
 \
plmxml_api::logical Has##name() const; \
 \
plmxml_api::Result Unset##name(); \
//////////////////////////////////////////////////

#define PLMXML_Logical_INIT( Class, name, names, type, n, opt ) \
 \
//////////////////////////////////////////////////

#define PLMXML_Logical_CODE( Class, name, names, type, n, opt ) \
plmxml_api::Result Class::Set##name( plmxml_api::logical arg ) \
{ \
return Object::SetAttributeValue( #name, arg ); \
} \
plmxml_api::logical Class::Get##name() const \
{ \
plmxml_api::logical value = FALSE; \
 \
Object::GetAttributeValue( #name, value ); \
return value; \
} \
plmxml_api::logical Class::Has##name() const \
{ \
return Object::HasField( #name, PLMXML_FIELD_ATTRIBUTE ); \
} \
plmxml_api::Result Class::Unset##name() \
{ \
return Object::ResetAttributeValue( #name ); \
} \
//////////////////////////////////////////////////

#define PLMXML_Logical_DELETE( Class, name, names, type, n, opt ) \
 \
//////////////////////////////////////////////////

#define PLMXML_Logical_DESCRIPTOR( Class, name, names, type, n, opt ) \
 \
pDescriptor->RegisterField( #name, plmxml_api::plmxmlFieldLogical ); \
//////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
/////////////////////////// MultipleReference ////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


#define PLMXML_MultipleReference_HEADER( Class, name, names, type, n, opt ) \
 \
int NumberOf##name##Refs() const; \
 \
/*!
Returns FALSE if 'arg's Id is unset otherwise TRUE.
*/ \
plmxml_api::logical Add##name##Ref( plmxml60::IdObject *arg ); \
 \
/*!
Returns FALSE if input String is empty otherwise TRUE.
*/ \
plmxml_api::logical Add##name##Id( const plmxml_api::String &u ); \
 \
/*!
Returns FALSE if 'arg's Id is unset otherwise TRUE.
*/ \
plmxml_api::logical Set##name##Ref( int i, plmxml60::IdObject *arg ); \
 \
/*!
Returns FALSE if input String is empty otherwise TRUE.
*/ \
plmxml_api::logical Set##name##Id( int i, const plmxml_api::String &u ); \
 \
plmxml60::IdObject *Resolve##name##Ref( int i, plmxml_api::Configuration* config = NULL ); \
 \
void Resolve##name##Refs( plmxml_api::Array<plmxml60::IdObject *> & array, plmxml_api::Configuration* config = NULL ); \
 \
plmxml_api::String Get##name##Id( int i ) const; \
 \
void Get##name##Ids( plmxml_api::Array<plmxml_api::String> &array ) const; \
 \
void Remove##name##Ref( int i ); \
 \
void Remove##name##Ref( const plmxml_api::String &u ); \
 \
void Remove##name##Ref( plmxml60::IdObject *arg ); \
 \
void Remove##name##Refs(); \
 \
plmxml_api::logical Has##name##Refs( ) const; \
//////////////////////////////////////////////////

#define PLMXML_MultipleReference_INIT( Class, name, names, type, n, opt ) \
 \
//////////////////////////////////////////////////

#define PLMXML_MultipleReference_CODE( Class, name, names, type, n, opt ) \
plmxml_api::logical Class::Add##name##Ref( plmxml60::IdObject *arg ) \
{ \
plmxml_api::Array<plmxml_api::Reference> refs; \
if ( Object::GetAttributeValue( #names, refs ).HasError( ) ) \
return FALSE; \
refs.Add( plmxml_api::Reference( arg ) ); \
 \
return Object::SetAttributeValue( #names, refs ).Ok( ); \
} \
plmxml_api::logical Class::Add##name##Id( const plmxml_api::String &u ) \
{ \
plmxml_api::Array<plmxml_api::Reference> refs; \
if ( Object::GetAttributeValue( #names, refs ).HasError( ) ) \
return FALSE; \
 \
refs.Add( plmxml_api::Reference( u ) ); \
 \
return Object::SetAttributeValue(#names, refs ).Ok( ); \
} \
plmxml_api::logical Class::Set##name##Ref( int i, plmxml60::IdObject *arg ) \
{ \
if ( i < 0 ) \
return FALSE; \
 \
plmxml_api::Array<plmxml_api::Reference> refs; \
if ( Object::GetAttributeValue( #names, refs ).HasError( ) ) \
return FALSE; \
 \
if ( i <refs.GetSize( ) ) \
{ \
refs[i] = plmxml_api::Reference( arg ); \
return Object::SetAttributeValue( #names, refs ).Ok( ); \
} \
 \
return FALSE; \
} \
plmxml_api::logical Class::Set##name##Id( int i, const plmxml_api::String &u ) \
{ \
if ( i < 0 ) \
return FALSE; \
 \
plmxml_api::Array<plmxml_api::Reference> refs; \
if ( Object::GetAttributeValue(#names, refs ).HasError( ) ) \
return FALSE; \
 \
if ( i <refs.GetSize( ) ) \
{ \
refs[i].SetString( u ); \
return Object::SetAttributeValue( #names, refs ).Ok( ); \
} \
 \
return FALSE; \
} \
plmxml_api::String Class::Get##name##Id( int i ) const \
{ \
if ( i < 0 ) \
throw plmxml_api::Exception( plmxml_api::ErrorCodeInvalidIndex ); \
 \
plmxml_api::Array<plmxml_api::Reference> refs; \
if ( Object::GetAttributeValue( #names, refs ).HasError( ) ) \
return plmxml_api::String::EmptyString( ); \
 \
if ( i < refs.GetSize( ) ) \
return refs[i].GetString( ); \
else \
throw plmxml_api::Exception( plmxml_api::ErrorCodeInvalidIndex ); \
} \
void Class::Remove##name##Refs() \
{ \
Object::ResetAttributeValue( #names ); \
} \
void Class::Remove##name##Ref( int i ) \
{ \
if ( i < 0 ) \
throw plmxml_api::Exception( plmxml_api::ErrorCodeInvalidIndex ); \
 \
plmxml_api::Array<plmxml_api::Reference> refs; \
if ( Object::GetAttributeValue( #names, refs ).HasError( ) ) \
return; \
 \
if ( i < refs.GetSize( ) ) \
{ \
refs.RemoveAt( i ); \
Object::SetAttributeValue( #names, refs ); \
} \
else \
throw plmxml_api::Exception( plmxml_api::ErrorCodeInvalidIndex ); \
} \
void Class::Remove##name##Ref( const plmxml_api::String &u ) \
{ \
plmxml_api::Array<plmxml_api::Reference> refs; \
if ( Object::GetAttributeValue( #names, refs ).HasError( ) ) \
return; \
 \
for ( int i = 0; i < refs.GetSize( ); i++ ) \
{ \
if ( refs[ i ].GetString( ) == u ) \
{ \
refs.RemoveAt( i ); \
Object::SetAttributeValue( #names, refs ); \
break; \
} \
} \
} \
void Class::Remove##name##Ref( plmxml60::IdObject *arg ) \
{ \
plmxml_api::Array<plmxml_api::Reference> refs; \
if ( Object::GetAttributeValue( #names, refs ).HasError( ) ) \
return; \
 \
for ( int i = 0; i < refs.GetSize( ); i++ ) \
{ \
if ( refs[ i ].GetHandle( ).GetObject( ) == arg ) \
{ \
refs.RemoveAt( i ); \
Object::SetAttributeValue( #names, refs ); \
break; \
} \
} \
} \
int Class::NumberOf##name##Refs() const \
{ \
plmxml_api::Array<plmxml_api::Reference> refs; \
if ( Object::GetAttributeValue( #names, refs ).HasError( ) ) \
return 0; \
 \
return refs.GetSize( ); \
} \
plmxml60::IdObject *Class::Resolve##name##Ref( int i, plmxml_api::Configuration* config ) \
{ \
static plmxml_api::Array<plmxml_api::Reference> values; \
 \
if ( i < 0 ) \
return NULL; \
 \
values.RemoveAll(); \
if ( Object::ResolveAttributeValue( #names, values, config ).HasError( ) ) \
return NULL; \
else if ( i < values.GetSize( ) ) \
return (plmxml60::IdObject*)values[i].GetHandle( ).GetObject( ); \
else \
return NULL; \
} \
void Class::Resolve##name##Refs( plmxml_api::Array<plmxml60::IdObject *> & array, plmxml_api::Configuration* config ) \
{ \
plmxml_api::Array<plmxml_api::Reference> value; \
value.RemoveAll(); \
 \
Object::ResolveAttributeValue( #names, value, config ); \
for ( int i = 0; i < value.GetSize( ); i++ ) \
array.Add( (plmxml60::IdObject*)value[i].GetHandle().GetObject( ) ); \
} \
void Class::Get##name##Ids( plmxml_api::Array<plmxml_api::String> &array ) const \
{ \
plmxml_api::Array<plmxml_api::Reference> values; \
values.RemoveAll(); \
 \
Object::GetAttributeValue( #names, values ); \
for ( int i = 0; i < values.GetSize(); i++ ) \
array.Add( values[i].GetString( ) ); \
} \
plmxml_api::logical Class::Has##name##Refs( ) const \
{ \
return Object::HasField( #names, PLMXML_FIELD_ATTRIBUTE ); \
} \
//////////////////////////////////////////////////

#define PLMXML_MultipleReference_DELETE( Class, name, names, type, n, opt ) \
 \
//////////////////////////////////////////////////

#define PLMXML_MultipleReference_DESCRIPTOR( Class, name, names, type, n, opt ) \
 \
pDescriptor->RegisterField( #names, plmxml_api::plmxmlFieldMultipleReference ); \
pDescriptor->SetFieldClass( #names, #type ); \
//////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
/////////////////////////// Int ////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


#define PLMXML_Int_HEADER( Class, name, names, type, n, opt ) \
 \
plmxml_api::Result Set##name( int arg ); \
 \
int Get##name() const; \
 \
plmxml_api::logical Has##name() const; \
 \
plmxml_api::Result Unset##name(); \
//////////////////////////////////////////////////

#define PLMXML_Int_INIT( Class, name, names, type, n, opt ) \
 \
//////////////////////////////////////////////////

#define PLMXML_Int_CODE( Class, name, names, type, n, opt ) \
plmxml_api::Result Class::Set##name( int arg ) \
{ \
return Object::SetAttributeValue( #name, arg ); \
} \
int Class::Get##name() const \
{ \
int value = 0; \
Object::GetAttributeValue( #name, value ); \
 \
return value; \
} \
plmxml_api::logical Class::Has##name() const \
{ \
return Object::HasField( #name, PLMXML_FIELD_ATTRIBUTE ); \
} \
plmxml_api::Result Class::Unset##name() \
{ \
return Object::ResetAttributeValue( #name ); \
} \
//////////////////////////////////////////////////

#define PLMXML_Int_DELETE( Class, name, names, type, n, opt ) \
 \
//////////////////////////////////////////////////

#define PLMXML_Int_DESCRIPTOR( Class, name, names, type, n, opt ) \
 \
pDescriptor->RegisterField( #name, plmxml_api::plmxmlFieldInt ); \
//////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
/////////////////////////// EnumFacetFinType /////////////////////////////
//////////////////////////////////////////////////////////////////////////

#define PLMXML_EnumFacetFinType_HEADER( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_HEADER( FacetFinType, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumFacetFinType_INIT( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_INIT( FacetFinType, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumFacetFinType_PARSE( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_PARSE( FacetFinType, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumFacetFinType_CODE( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_CODE( FacetFinType, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumFacetFinType_DESCRIPTOR( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_DESCRIPTOR( FacetFinType, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumFacetFinType_DELETE( base, name, pluralname, type, n, opt ) \
PLMXML_Enum_DELETE( FacetFinType, Class, name, pluralname, type, n, opt )

//////////////////////////////////////////////////////////////////////////
/////////////////////////// EnumPartType /////////////////////////////
//////////////////////////////////////////////////////////////////////////

#define PLMXML_EnumPartType_HEADER( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_HEADER( PartType, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumPartType_INIT( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_INIT( PartType, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumPartType_PARSE( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_PARSE( PartType, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumPartType_CODE( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_CODE( PartType, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumPartType_DESCRIPTOR( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_DESCRIPTOR( PartType, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumPartType_DELETE( base, name, pluralname, type, n, opt ) \
PLMXML_Enum_DELETE( PartType, Class, name, pluralname, type, n, opt )

//////////////////////////////////////////////////////////////////////////
/////////////////////////// EnumSplineCurveFormType /////////////////////////////
//////////////////////////////////////////////////////////////////////////

#define PLMXML_EnumSplineCurveFormType_HEADER( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_HEADER( SplineCurveFormType, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumSplineCurveFormType_INIT( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_INIT( SplineCurveFormType, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumSplineCurveFormType_PARSE( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_PARSE( SplineCurveFormType, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumSplineCurveFormType_CODE( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_CODE( SplineCurveFormType, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumSplineCurveFormType_DESCRIPTOR( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_DESCRIPTOR( SplineCurveFormType, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumSplineCurveFormType_DELETE( base, name, pluralname, type, n, opt ) \
PLMXML_Enum_DELETE( SplineCurveFormType, Class, name, pluralname, type, n, opt )

//////////////////////////////////////////////////////////////////////////
/////////////////////////// EnumTransformType /////////////////////////////
//////////////////////////////////////////////////////////////////////////

#define PLMXML_EnumTransformType_HEADER( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_HEADER( TransformType, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumTransformType_INIT( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_INIT( TransformType, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumTransformType_PARSE( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_PARSE( TransformType, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumTransformType_CODE( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_CODE( TransformType, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumTransformType_DESCRIPTOR( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_DESCRIPTOR( TransformType, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumTransformType_DELETE( base, name, pluralname, type, n, opt ) \
PLMXML_Enum_DELETE( TransformType, Class, name, pluralname, type, n, opt )

//////////////////////////////////////////////////////////////////////////
/////////////////////////// EnumBoundType /////////////////////////////
//////////////////////////////////////////////////////////////////////////

#define PLMXML_EnumBoundType_HEADER( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_HEADER( BoundType, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumBoundType_INIT( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_INIT( BoundType, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumBoundType_PARSE( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_PARSE( BoundType, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumBoundType_CODE( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_CODE( BoundType, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumBoundType_DESCRIPTOR( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_DESCRIPTOR( BoundType, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumBoundType_DELETE( base, name, pluralname, type, n, opt ) \
PLMXML_Enum_DELETE( BoundType, Class, name, pluralname, type, n, opt )

//////////////////////////////////////////////////////////////////////////
/////////////////////////// EnumRepresentationFormat /////////////////////////////
//////////////////////////////////////////////////////////////////////////

#define PLMXML_EnumRepresentationFormat_HEADER( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_HEADER( RepresentationFormat, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumRepresentationFormat_INIT( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_INIT( RepresentationFormat, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumRepresentationFormat_PARSE( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_PARSE( RepresentationFormat, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumRepresentationFormat_CODE( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_CODE( RepresentationFormat, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumRepresentationFormat_DESCRIPTOR( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_DESCRIPTOR( RepresentationFormat, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumRepresentationFormat_DELETE( base, name, pluralname, type, n, opt ) \
PLMXML_Enum_DELETE( RepresentationFormat, Class, name, pluralname, type, n, opt )

/////////////////////////////////////////////////////////////////////////
/////////////////////////// EnumDrawingStyle /////////////////////////////
//////////////////////////////////////////////////////////////////////////

#define PLMXML_EnumDrawingStyle_HEADER( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_HEADER( DrawingStyle, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumDrawingStyle_INIT( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_INIT( DrawingStyle, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumDrawingStyle_PARSE( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_PARSE( DrawingStyle, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumDrawingStyle_CODE( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_CODE( DrawingStyle, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumDrawingStyle_DESCRIPTOR( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_DESCRIPTOR( DrawingStyle, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumDrawingStyle_DELETE( base, name, pluralname, type, n, opt ) \
PLMXML_Enum_DELETE( DrawingStyle, Class, name, pluralname, type, n, opt )

/////////////////////////////////////////////////////////////////////////
/////////////////////////// EnumShadingStyle /////////////////////////////
//////////////////////////////////////////////////////////////////////////

#define PLMXML_EnumShadingStyle_HEADER( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_HEADER( ShadingStyle, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumShadingStyle_INIT( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_INIT( ShadingStyle, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumShadingStyle_PARSE( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_PARSE( ShadingStyle, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumShadingStyle_CODE( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_CODE( ShadingStyle, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumShadingStyle_DESCRIPTOR( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_DESCRIPTOR( ShadingStyle, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumShadingStyle_DELETE( base, name, pluralname, type, n, opt ) \
PLMXML_Enum_DELETE( ShadingStyle, Class, name, pluralname, type, n, opt )

/////////////////////////////////////////////////////////////////////////
/////////////////////////// EnumUserValueDataType /////////////////////////////
//////////////////////////////////////////////////////////////////////////

#define PLMXML_EnumUserValueDataType_HEADER( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_HEADER( UserValueDataType, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumUserValueDataType_INIT( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_INIT( UserValueDataType, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumUserValueDataType_PARSE( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_PARSE( UserValueDataType, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumUserValueDataType_CODE( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_CODE( UserValueDataType, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumUserValueDataType_DESCRIPTOR( Class, name, pluralname, type, n, opt ) \
PLMXML_Enum_DESCRIPTOR( UserValueDataType, Class, name, pluralname, type, n, opt )

#define PLMXML_EnumUserValueDataType_DELETE( base, name, pluralname, type, n, opt ) \
PLMXML_Enum_DELETE( UserValueDataType, Class, name, pluralname, type, n, opt)  

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

// This macro expands to declarations to support the given class, in particular 
// two constructors, a destructor, and field access and modification functions
//
// The arguments are the class name and base class name - for example
//               PLMXML_DECLARE_CLASS( Part, Entity3D )
//
#define PLMXML_DECLARE_CLASS( module, name, base ) \
	PLMXML_DECLARE_CLASS1( module, name, base ) \
	PLMXML_DECLARE_CLASS2( module, name, base )


#ifndef PLMXML_DECLARE_CLASS_DESCRIPTOR
#define PLMXML_DECLARE_CLASS_DESCRIPTOR
#endif

//////////////////////////////////////////////////////////////////////////

#define PLMXML_DECLARE_CLASS1( module, name, base ) \
class module##_API name : public base \
{ \
private: \
	name& operator=(const name& iSrc ); \
	name( const name& original ); \
public: \
    name(); \
    name( plmxml_api::Object* parent ); \
    virtual ~name(); \
\
	PLMXML_FIELD_HEADER( name ) \
public: \

///////////////////////////////////////////////////////////////////////////

#define PLMXML_DECLARE_CLASS2( module, name, base ) \
}; \
extern module##_API plmxml_api::plmxmlClass plmxmlClass##name;

/*
//
// The following macros expand to code to support the given class, in particular 
// two constructors, a destructor, and field access and modification functions
//
// The arguments are:
// Module name: 
//      e.g. MYPLMXMLMODULE
//
//      "_API" will be appended to YOURDLL.
//      if you are building a DLL then you need to define:
//      #define YOURDLL_API __declspec(dllexport)
//      otherwise define as empty
//      #define YOURDLL_API 
//
// Classname: name of C++ class
//
// Baseclass: C++ class name of base class
//		e.g. BaseObject
//
// Elementname: global element name, or class name if none
//		e.g. Instance, Length, Circle, plmxmlHeaderInformation
//
// Equivclass: Class descriptor of the equivalence class, or NULL. Please use PLMXML_CLASS_DESCRIPTOR() macro.
//		e.g. PLMXML_CLASS_DESCRIPTOR(Attribute), PLMXML_CLASS_DESCRIPTOR(Curve), Null
//
//
// - for example
//
//       PLMXML_DEFINE_CLASS( MYPLMXMLMODULE, Circle, PlaneCurve, Circle, PLMXML_CLASS_DESCRIPTOR(Curve) )
//
//
//
// It is possible to include extra code for class constructors and destructor and 
// associate it with XML namespace as shown below.
//
// (optional)   #define NAMESPACE_HD "http://www.jumpstart.plmxml.org/Schemas/HeaderAttribute"
// (optional)   #define PREFIX_HD    "HD"
//
// (optional)   PLMXML_DEFINE_XMLNS( PREFIX_HD, NAMESPACE_HD ) 
//
//  if XML namespace is defined:
// (optional)   PLMXML_DEFINE_CLASS_BEGIN_XMLNS( PLMXML_TEST, HDName, Object, Name, NULL )
//
//  otherwise
//              PLMXML_DEFINE_CLASS_BEGIN( PLMXML, DisplayControl, BaseObject, DisplayControl, NULL )
//
//              PLMXML_DEFINE_CLASS_CR_PARSE( DisplayControl, BaseObject )
//
//              // This constructor is called when object is created during XML parsing.
//
//              PLMXML_DEFINE_CLASS_FIELDS_PARSE( DisplayControl, BaseObject )
//
//              // This function is called during XML parsing of attributes.
//              // Any extra attribute processing can be done here.
//
//              PLMXML_DEFINE_CLASS_CR_DEFAULT( DisplayControl, BaseObject )
//
//              // This constructor is called when object is created from the application itself.
//
//	            SetBackgroundColour( ... );
//
//              PLMXML_DEFINE_CLASS_DR( DisplayControl )
//
//              // Extra destructor code
//
//              PLMXML_DEFINE_CLASS_END( DisplayControl )
//
*/

#define PLMXML_CLASS_DESCRIPTOR( name ) name

#define PLMXML_DEFINE_XMLNS( xmlPrefix, xmlNamespace ) \
	static const char* __xmlPrefix = xmlPrefix; \
	static const char* __xmlNamespace = xmlNamespace;

#define PLMXML_DEFINE_CLASS_DESCRIPTOR_START( module, name, tagname, baseDescriptor, equivDescriptor ) \
    module##_API plmxml_api::plmxmlClass plmxmlClass##name = plmxml_api::plmxmlClassUnset; \
	static void __##name##RegisterFields( plmxml_api::ClassDescriptor* pDescriptor ); \
	static plmxml_api::logical __##name##RegisterClass( void* cd ); \
	static plmxml_api::Object* __##name##MakeClassInstance( ) \
	{ \
		return new name( ); \
	} \
	static plmxml_api::LinkNode __##name##LinkNode( __##name##RegisterClass, plmxmlLinkTypeClass ); \
	static plmxml_api::logical __##name##RegisterClass( void* cd ) \
	{ \
		if ( cd == NULL ) \
			return FALSE; \
		struct _ClassDescriptorLayout \
		{ \
			int							m_version; \
			plmxml_api::ClassDescriptor*	m_pDescriptor; \
			plmxml_api::plmxmlClass*		m_pClass; \
		}; \
		_ClassDescriptorLayout* pClassDescriptorLayOut = (_ClassDescriptorLayout*)cd; \
		plmxml_api::ClassDescriptor* pDescriptor = pClassDescriptorLayOut->m_pDescriptor; \
		plmxmlClass##name	= pDescriptor->GetClass(); \
		pClassDescriptorLayOut->m_pClass = &plmxmlClass##name;	\
		pDescriptor->SetVersion( "6.0" ); \
		pDescriptor->SetName( #name ); \
		pDescriptor->SetOutputName( tagname ); \
		pDescriptor->SetMakeFunction( __##name##MakeClassInstance ); \
		pDescriptor->SetBaseClass( #baseDescriptor ); \
		pDescriptor->SetEquivalenceClass( #equivDescriptor ); \
		__##name##RegisterFields( pDescriptor );

#define PLMXML_DEFINE_CLASS_DESCRIPTOR_END() \
		return TRUE; \
	}

#define PLMXML_DEFINE_CLASS_DESCRIPTOR( module, name, tagname, baseDescriptor, equivDescriptor ) \
    PLMXML_DEFINE_CLASS_DESCRIPTOR_START( module, name, tagname, baseDescriptor, equivDescriptor )

#define PLMXML_DEFINE_CLASS_DESCRIPTOR_XMLNS( module, name, tagname, baseDescriptor, equivDescriptor ) \
    PLMXML_DEFINE_CLASS_DESCRIPTOR( module, name, tagname, baseDescriptor, equivDescriptor ) \
	pDescriptor->SetNamespace( __xmlNamespace, __xmlPrefix );
    
#define PLMXML_DEFINE_CLASS_BEGIN( module, name, base, elementname, equivDescriptor ) \
    PLMXML_DEFINE_CLASS_DESCRIPTOR( module, name, #elementname, base, equivDescriptor )

#define PLMXML_DEFINE_CLASS_BEGIN_XMLNS( module, name, base, elementname, equivDescriptor ) \
    PLMXML_DEFINE_CLASS_DESCRIPTOR_XMLNS( module, name, #elementname, base, equivDescriptor )

#define PLMXML_DEFINE_CLASS_XMLNS( xmlPrefix, xmlNamespace )
     
#define PLMXML_DEFINE_CLASS_CR_PARSE( name, base ) \
    PLMXML_DEFINE_CLASS_DESCRIPTOR_END()

#define PLMXML_DEFINE_CLASS_CR_DEFAULT( name, base ) \
    name::name( const name& original ) \
    { \
    } \
    name& name::operator=(const name& iSrc ) \
    { \
		return (*this); \
	} \
    name::name( plmxml_api::Object* parent ) \
    { \
		InitData( plmxmlClass##name ); \
		PLMXML_FIELD_INIT( name ) \
		if ( parent != NULL ) \
		{ \
			plmxml_api::Result result = SetOwner( parent ); \
			if ( result.HasError( ) ) \
			{ \
				InitData( plmxml_api::plmxmlClassNull ); \
				throw plmxml_api::Exception( plmxml_api::ErrorCodeFailed, result.GetMessage( ) ); \
			} \
		} \
	} \
	name::name( ) : base( ) \
    { \
	    InitData( plmxmlClass##name ); \
	    PLMXML_FIELD_INIT( name )

#define PLMXML_DEFINE_CLASS_DR( name ) \
    } \
    name::~name() \
    { 

#define PLMXML_DEFINE_CLASS_END( name ) \
    } \
    void __##name##RegisterFields( plmxml_api::ClassDescriptor* pDescriptor ) \
    { \
	if ( pDescriptor == NULL ) \
			return; \
	    \
	    PLMXML_FIELD_DESCRIPTOR( name ) \
    } \
    PLMXML_FIELD_CODE( name )

#define PLMXML_DEFINE_CLASS( module, name, base, elementname, equivDescriptor ) \
    PLMXML_DEFINE_CLASS_BEGIN( module, name, base, elementname, equivDescriptor ) \
    PLMXML_DEFINE_CLASS_CR_PARSE( name, base ) \
    PLMXML_DEFINE_CLASS_CR_DEFAULT( name, base ) \
    PLMXML_DEFINE_CLASS_DR( name ) \
    PLMXML_DEFINE_CLASS_END( name )
    
#define PLMXML_DEFINE_CLASS_FIELDS_PARSE( name, base )

// </PLMXML_UserCode>

/////////////////////////////////////////////////////////////////////////

PLMXML_END_NAMESPACE

//////////////////////////////////////////////////////////////////////

#endif
